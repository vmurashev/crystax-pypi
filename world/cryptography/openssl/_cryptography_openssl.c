#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.
*/
#ifndef _CFFI_USE_EMBEDDING
#  include <pyconfig.h>
#  if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
#    define Py_LIMITED_API
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47

#define _CFFI__NUM_PRIM         48
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _CFFI_NUM_EXPORTS 26

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/


#include <openssl/opensslv.h>


#if defined(LIBRESSL_VERSION_NUMBER)
#define CRYPTOGRAPHY_IS_LIBRESSL 1
#else
#define CRYPTOGRAPHY_IS_LIBRESSL 0
#endif

/*
    LibreSSL removed e_os2.h from the public headers so we'll only include it
    if we're using vanilla OpenSSL.
*/
#if !CRYPTOGRAPHY_IS_LIBRESSL
#include <openssl/e_os2.h>
#endif
#if defined(_WIN32)
#include <windows.h>
#endif

#define CRYPTOGRAPHY_OPENSSL_102BETA2_OR_GREATER     (OPENSSL_VERSION_NUMBER >= 0x10002002 && !CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER     (OPENSSL_VERSION_NUMBER >= 0x100020cf && !CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_110_OR_GREATER     (OPENSSL_VERSION_NUMBER >= 0x10100000 && !CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER     (OPENSSL_VERSION_NUMBER >= 0x1010006f && !CRYPTOGRAPHY_IS_LIBRESSL)

#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_102     (OPENSSL_VERSION_NUMBER < 0x10002000 || CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_102BETA3     (OPENSSL_VERSION_NUMBER < 0x10002003 || CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I     (OPENSSL_VERSION_NUMBER < 0x1000209f || CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_110     (OPENSSL_VERSION_NUMBER < 0x10100000 || CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE4     (OPENSSL_VERSION_NUMBER < 0x10100004 || CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE5     (OPENSSL_VERSION_NUMBER < 0x10100005 || CRYPTOGRAPHY_IS_LIBRESSL)
#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE6     (OPENSSL_VERSION_NUMBER < 0x10100006 || CRYPTOGRAPHY_IS_LIBRESSL)


#include <openssl/aes.h>


#include <openssl/asn1.h>


#include <openssl/bn.h>


#include <openssl/bio.h>


#if !defined(OPENSSL_NO_CMAC)
#include <openssl/cmac.h>
#endif


#if !defined(OPENSSL_NO_CMS)
#include <openssl/cms.h>
#endif


#include <openssl/conf.h>


#include <openssl/crypto.h>


#if CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
#include <openssl/ct.h>

typedef STACK_OF(SCT) Cryptography_STACK_OF_SCT;
#endif


#include <openssl/dh.h>


#include <openssl/dsa.h>


#include <openssl/ec.h>
#include <openssl/obj_mac.h>


#include <openssl/ecdh.h>


#include <openssl/ecdsa.h>


#include <openssl/engine.h>


#include <openssl/err.h>


#include <openssl/evp.h>


#include <openssl/hmac.h>


#include <openssl/obj_mac.h>


#include <openssl/objects.h>


#include <openssl/ocsp.h>


#include <openssl/opensslv.h>

#ifdef _WIN32
  #include <Wincrypt.h>
#else
  #include <fcntl.h>
  #include <unistd.h>
   /* for defined(BSD) */
  #include <sys/param.h>

  #ifdef BSD
    /* for SYS_getentropy */
    #include <sys/syscall.h>
  #endif

  #ifdef __APPLE__
    #include <sys/random.h>
    #include <AvailabilityMacros.h>
  #endif

  #ifdef __linux__
    /* for SYS_getrandom */
    #include <sys/syscall.h>
    #ifndef GRND_NONBLOCK
      #define GRND_NONBLOCK 0x0001
    #endif /* GRND_NONBLOCK */
  #endif /* __linux__ */
#endif /* _WIN32 */

#define CRYPTOGRAPHY_OSRANDOM_ENGINE_CRYPTGENRANDOM 1
#define CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY 2
#define CRYPTOGRAPHY_OSRANDOM_ENGINE_GETRANDOM 3
#define CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM 4

#ifndef CRYPTOGRAPHY_OSRANDOM_ENGINE
  #if defined(_WIN32)
    /* Windows */
    #define CRYPTOGRAPHY_OSRANDOM_ENGINE CRYPTOGRAPHY_OSRANDOM_ENGINE_CRYPTGENRANDOM
  #elif defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED >= 101200
    /* macOS 10.12+ */
    #define CRYPTOGRAPHY_OSRANDOM_ENGINE CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY
  #elif defined(BSD) && defined(SYS_getentropy) && !defined(__APPLE__)
    /* OpenBSD 5.6+ */
    #define CRYPTOGRAPHY_OSRANDOM_ENGINE CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY
  #elif defined(__linux__) && defined(SYS_getrandom)
    /* Linux 3.4.17+ */
    #define CRYPTOGRAPHY_OSRANDOM_ENGINE CRYPTOGRAPHY_OSRANDOM_ENGINE_GETRANDOM
  #else
    /* Keep this as last entry, fall back to /dev/urandom */
    #define CRYPTOGRAPHY_OSRANDOM_ENGINE CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM
  #endif
#endif /* CRYPTOGRAPHY_OSRANDOM_ENGINE */

/* Fallbacks need /dev/urandom helper functions. */
#if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_GETRANDOM || \
     CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM
  #define CRYPTOGRAPHY_OSRANDOM_NEEDS_DEV_URANDOM 1
#endif

enum {
    CRYPTOGRAPHY_OSRANDOM_GETRANDOM_INIT_FAILED = -2,
    CRYPTOGRAPHY_OSRANDOM_GETRANDOM_NOT_INIT,
    CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK,
    CRYPTOGRAPHY_OSRANDOM_GETRANDOM_WORKS
};

/* engine ctrl */
#define CRYPTOGRAPHY_OSRANDOM_GET_IMPLEMENTATION ENGINE_CMD_BASE

/* error reporting */
static void ERR_load_Cryptography_OSRandom_strings(void);
static void ERR_Cryptography_OSRandom_error(int function, int reason,
                                            char *file, int line);

#define CRYPTOGRAPHY_OSRANDOM_F_INIT 100
#define CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES 101
#define CRYPTOGRAPHY_OSRANDOM_F_FINISH 102
#define CRYPTOGRAPHY_OSRANDOM_F_DEV_URANDOM_FD 300
#define CRYPTOGRAPHY_OSRANDOM_F_DEV_URANDOM_READ 301

#define CRYPTOGRAPHY_OSRANDOM_R_CRYPTACQUIRECONTEXT 100
#define CRYPTOGRAPHY_OSRANDOM_R_CRYPTGENRANDOM 101
#define CRYPTOGRAPHY_OSRANDOM_R_CRYPTRELEASECONTEXT 102

#define CRYPTOGRAPHY_OSRANDOM_R_GETENTROPY_FAILED 200

#define CRYPTOGRAPHY_OSRANDOM_R_DEV_URANDOM_OPEN_FAILED 300
#define CRYPTOGRAPHY_OSRANDOM_R_DEV_URANDOM_READ_FAILED 301

#define CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED 400
#define CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED_EAGAIN 401
#define CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED_UNEXPECTED 402
#define CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_FAILED 403
#define CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_NOT_INIT 404


#include <openssl/pem.h>


#include <openssl/pkcs12.h>


#include <openssl/rand.h>


#include <openssl/rsa.h>


#include <openssl/ssl.h>

typedef STACK_OF(SSL_CIPHER) Cryptography_STACK_OF_SSL_CIPHER;


#include <openssl/ssl.h>

/*
 * This is part of a work-around for the difficulty cffi has in dealing with
 * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that
 * will be an alias for this type and use the alias throughout.  This works
 * together with another opaque typedef for the same name in the TYPES section.
 * Note that the result is an opaque type.
 */
typedef STACK_OF(X509) Cryptography_STACK_OF_X509;
typedef STACK_OF(X509_CRL) Cryptography_STACK_OF_X509_CRL;
typedef STACK_OF(X509_REVOKED) Cryptography_STACK_OF_X509_REVOKED;


#include <openssl/x509.h>

/*
 * See the comment above Cryptography_STACK_OF_X509 in x509.py
 */
typedef STACK_OF(X509_NAME) Cryptography_STACK_OF_X509_NAME;
typedef STACK_OF(X509_NAME_ENTRY) Cryptography_STACK_OF_X509_NAME_ENTRY;


#include <openssl/x509v3.h>

/*
 * This is part of a work-around for the difficulty cffi has in dealing with
 * `LHASH_OF(foo)` as the name of a type.  We invent a new, simpler name that
 * will be an alias for this type and use the alias throughout.  This works
 * together with another opaque typedef for the same name in the TYPES section.
 * Note that the result is an opaque type.
 */
typedef LHASH_OF(CONF_VALUE) Cryptography_LHASH_OF_CONF_VALUE;

typedef STACK_OF(ACCESS_DESCRIPTION) Cryptography_STACK_OF_ACCESS_DESCRIPTION;
typedef STACK_OF(DIST_POINT) Cryptography_STACK_OF_DIST_POINT;
typedef STACK_OF(POLICYQUALINFO) Cryptography_STACK_OF_POLICYQUALINFO;
typedef STACK_OF(POLICYINFO) Cryptography_STACK_OF_POLICYINFO;
typedef STACK_OF(ASN1_INTEGER) Cryptography_STACK_OF_ASN1_INTEGER;
typedef STACK_OF(GENERAL_SUBTREE) Cryptography_STACK_OF_GENERAL_SUBTREE;


#include <openssl/x509_vfy.h>

/*
 * This is part of a work-around for the difficulty cffi has in dealing with
 * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that
 * will be an alias for this type and use the alias throughout.  This works
 * together with another opaque typedef for the same name in the TYPES section.
 * Note that the result is an opaque type.
 */
typedef STACK_OF(ASN1_OBJECT) Cryptography_STACK_OF_ASN1_OBJECT;
typedef STACK_OF(X509_OBJECT) Cryptography_STACK_OF_X509_OBJECT;


#include <openssl/pkcs7.h>


#include <openssl/ssl.h>
#include <openssl/x509.h>
#include <openssl/x509_vfy.h>
#include <openssl/crypto.h>

#include <pythread.h>




int AES_set_encrypt_key(const unsigned char *, const int, AES_KEY *);
int AES_set_decrypt_key(const unsigned char *, const int, AES_KEY *);

int AES_wrap_key(AES_KEY *, const unsigned char *, unsigned char *,
                 const unsigned char *, unsigned int);
int AES_unwrap_key(AES_KEY *, const unsigned char *, unsigned char *,
                   const unsigned char *, unsigned int);


ASN1_OBJECT *ASN1_OBJECT_new(void);
void ASN1_OBJECT_free(ASN1_OBJECT *);

/*  ASN1 OBJECT IDENTIFIER */
ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **, const unsigned char **, long);

/*  ASN1 STRING */
ASN1_STRING *ASN1_STRING_new(void);
ASN1_STRING *ASN1_STRING_type_new(int);
void ASN1_STRING_free(ASN1_STRING *);
unsigned char *ASN1_STRING_data(ASN1_STRING *);
int ASN1_STRING_set(ASN1_STRING *, const void *, int);

/*  ASN1 OCTET STRING */
ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void);
void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *);
int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *, const unsigned char *, int);

/* ASN1 IA5STRING */
ASN1_IA5STRING *ASN1_IA5STRING_new(void);

/*  ASN1 INTEGER */
ASN1_INTEGER *ASN1_INTEGER_new(void);
void ASN1_INTEGER_free(ASN1_INTEGER *);
int ASN1_INTEGER_set(ASN1_INTEGER *, long);

/*  ASN1 TIME */
ASN1_TIME *ASN1_TIME_new(void);
void ASN1_TIME_free(ASN1_TIME *);
ASN1_TIME *ASN1_TIME_set(ASN1_TIME *, time_t);
int ASN1_TIME_set_string(ASN1_TIME *, const char *);

/*  ASN1 UTCTIME */
ASN1_UTCTIME *ASN1_UTCTIME_new(void);
void ASN1_UTCTIME_free(ASN1_UTCTIME *);
int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *, time_t);
ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *, time_t);

/*  ASN1 GENERALIZEDTIME */
int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *, const char *);
ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *, time_t);
void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *);
int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *, unsigned char **);

/*  ASN1 ENUMERATED */
ASN1_ENUMERATED *ASN1_ENUMERATED_new(void);
void ASN1_ENUMERATED_free(ASN1_ENUMERATED *);
int ASN1_ENUMERATED_set(ASN1_ENUMERATED *, long);
int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *, unsigned char **);

ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **, const unsigned char **, long,
                          const ASN1_ITEM *);
int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *, int, int);


BIGNUM *BN_new(void);
void BN_free(BIGNUM *);

BN_CTX *BN_CTX_new(void);
void BN_CTX_free(BN_CTX *);

void BN_CTX_start(BN_CTX *);
BIGNUM *BN_CTX_get(BN_CTX *);
void BN_CTX_end(BN_CTX *);

BIGNUM *BN_copy(BIGNUM *, const BIGNUM *);
BIGNUM *BN_dup(const BIGNUM *);

int BN_set_word(BIGNUM *, BN_ULONG);
BN_ULONG BN_get_word(const BIGNUM *);

const BIGNUM *BN_value_one(void);

char *BN_bn2hex(const BIGNUM *);
int BN_hex2bn(BIGNUM **, const char *);
int BN_dec2bn(BIGNUM **, const char *);

int BN_bn2bin(const BIGNUM *, unsigned char *);
BIGNUM *BN_bin2bn(const unsigned char *, int, BIGNUM *);

int BN_num_bits(const BIGNUM *);

int BN_cmp(const BIGNUM *, const BIGNUM *);
int BN_add(BIGNUM *, const BIGNUM *, const BIGNUM *);
int BN_sub(BIGNUM *, const BIGNUM *, const BIGNUM *);
int BN_mul(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
int BN_sqr(BIGNUM *, const BIGNUM *, BN_CTX *);
int BN_div(BIGNUM *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
int BN_nnmod(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
int BN_mod_add(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
               BN_CTX *);
int BN_mod_sub(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
               BN_CTX *);
int BN_mod_mul(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
               BN_CTX *);
int BN_mod_sqr(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
int BN_exp(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
int BN_mod_exp(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
               BN_CTX *);
int BN_gcd(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
BIGNUM *BN_mod_inverse(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);

int BN_set_bit(BIGNUM *, int);
int BN_clear_bit(BIGNUM *, int);

int BN_is_bit_set(const BIGNUM *, int);

int BN_mask_bits(BIGNUM *, int);


int BIO_free(BIO *);
void BIO_vfree(BIO *);
void BIO_free_all(BIO *);
BIO *BIO_push(BIO *, BIO *);
BIO *BIO_pop(BIO *);
BIO *BIO_next(BIO *);
BIO *BIO_find_type(BIO *, int);
BIO *BIO_new_file(const char *, const char *);
BIO *BIO_new_fp(FILE *, int);
BIO *BIO_new_fd(int, int);
BIO *BIO_new_socket(int, int);
long BIO_ctrl(BIO *, int, long, void *);
long BIO_callback_ctrl(
    BIO *,
    int,
    void (*)(struct bio_st *, int, const char *, int, long, long)
);
long BIO_int_ctrl(BIO *, int, long, int);
size_t BIO_ctrl_pending(BIO *);
size_t BIO_ctrl_wpending(BIO *);
int BIO_read(BIO *, void *, int);
int BIO_gets(BIO *, char *, int);
int BIO_write(BIO *, const void *, int);
int BIO_puts(BIO *, const char *);
int BIO_method_type(const BIO *);






void OPENSSL_config(const char *);


int CRYPTO_mem_ctrl(int);




DH *DH_new(void);
void DH_free(DH *);
int DH_size(const DH *);
int DH_check_pub_key(const DH *, const BIGNUM *, int *);
int DH_generate_key(DH *);
int DH_compute_key(unsigned char *, const BIGNUM *, DH *);
int DH_set_ex_data(DH *, int, void *);
void *DH_get_ex_data(DH *, int);
DH *d2i_DHparams(DH **, const unsigned char **, long);
int i2d_DHparams(const DH *, unsigned char **);
int DHparams_print_fp(FILE *, const DH *);
int DHparams_print(BIO *, const DH *);
DH *DHparams_dup(DH *);

/* added in 1.1.0 when the DH struct was opaqued */
void DH_get0_pqg(const DH *, const BIGNUM **, const BIGNUM **,
                 const BIGNUM **);
int DH_set0_pqg(DH *, BIGNUM *, BIGNUM *, BIGNUM *);
void DH_get0_key(const DH *, const BIGNUM **, const BIGNUM **);
int DH_set0_key(DH *, BIGNUM *, BIGNUM *);

int Cryptography_DH_check(const DH *, int *);


int DSA_generate_key(DSA *);
DSA *DSA_new(void);
void DSA_free(DSA *);
DSA *DSAparams_dup(DSA *);
int DSA_size(const DSA *);
int DSA_sign(int, const unsigned char *, int, unsigned char *, unsigned int *,
             DSA *);
int DSA_verify(int, const unsigned char *, int, const unsigned char *, int,
               DSA *);

/* added in 1.1.0 to access the opaque struct */
void DSA_get0_pqg(const DSA *, const BIGNUM **, const BIGNUM **,
                  const BIGNUM **);
int DSA_set0_pqg(DSA *, BIGNUM *, BIGNUM *, BIGNUM *);
void DSA_get0_key(const DSA *, const BIGNUM **, const BIGNUM **);
int DSA_set0_key(DSA *, BIGNUM *, BIGNUM *);








ENGINE *ENGINE_get_first(void);
ENGINE *ENGINE_get_last(void);
ENGINE *ENGINE_get_next(ENGINE *);
ENGINE *ENGINE_get_prev(ENGINE *);
int ENGINE_add(ENGINE *);
int ENGINE_remove(ENGINE *);
ENGINE *ENGINE_by_id(const char *);
int ENGINE_init(ENGINE *);
int ENGINE_finish(ENGINE *);
void ENGINE_load_builtin_engines(void);
ENGINE *ENGINE_get_default_RSA(void);
ENGINE *ENGINE_get_default_DSA(void);
ENGINE *ENGINE_get_default_DH(void);
ENGINE *ENGINE_get_default_RAND(void);
ENGINE *ENGINE_get_cipher_engine(int);
ENGINE *ENGINE_get_digest_engine(int);
int ENGINE_set_default_RSA(ENGINE *);
int ENGINE_set_default_DSA(ENGINE *);
int ENGINE_set_default_DH(ENGINE *);
int ENGINE_set_default_RAND(ENGINE *);
int ENGINE_set_default_ciphers(ENGINE *);
int ENGINE_set_default_digests(ENGINE *);
int ENGINE_set_default_string(ENGINE *, const char *);
int ENGINE_set_default(ENGINE *, unsigned int);
unsigned int ENGINE_get_table_flags(void);
void ENGINE_set_table_flags(unsigned int);
int ENGINE_register_RSA(ENGINE *);
void ENGINE_unregister_RSA(ENGINE *);
void ENGINE_register_all_RSA(void);
int ENGINE_register_DSA(ENGINE *);
void ENGINE_unregister_DSA(ENGINE *);
void ENGINE_register_all_DSA(void);
int ENGINE_register_DH(ENGINE *);
void ENGINE_unregister_DH(ENGINE *);
void ENGINE_register_all_DH(void);
int ENGINE_register_RAND(ENGINE *);
void ENGINE_unregister_RAND(ENGINE *);
void ENGINE_register_all_RAND(void);
int ENGINE_register_ciphers(ENGINE *);
void ENGINE_unregister_ciphers(ENGINE *);
void ENGINE_register_all_ciphers(void);
int ENGINE_register_digests(ENGINE *);
void ENGINE_unregister_digests(ENGINE *);
void ENGINE_register_all_digests(void);
int ENGINE_register_complete(ENGINE *);
int ENGINE_register_all_complete(void);
int ENGINE_ctrl(ENGINE *, int, long, void *, void (*)(void));
int ENGINE_cmd_is_executable(ENGINE *, int);
int ENGINE_ctrl_cmd(ENGINE *, const char *, long, void *, void (*)(void), int);
int ENGINE_ctrl_cmd_string(ENGINE *, const char *, const char *, int);

ENGINE *ENGINE_new(void);
int ENGINE_free(ENGINE *);
int ENGINE_up_ref(ENGINE *);
int ENGINE_set_id(ENGINE *, const char *);
int ENGINE_set_name(ENGINE *, const char *);
int ENGINE_set_RSA(ENGINE *, const RSA_METHOD *);
int ENGINE_set_DSA(ENGINE *, const DSA_METHOD *);
int ENGINE_set_DH(ENGINE *, const DH_METHOD *);
int ENGINE_set_RAND(ENGINE *, const RAND_METHOD *);
int ENGINE_set_destroy_function(ENGINE *, ENGINE_GEN_INT_FUNC_PTR);
int ENGINE_set_init_function(ENGINE *, ENGINE_GEN_INT_FUNC_PTR);
int ENGINE_set_finish_function(ENGINE *, ENGINE_GEN_INT_FUNC_PTR);
int ENGINE_set_ctrl_function(ENGINE *, ENGINE_CTRL_FUNC_PTR);
int ENGINE_set_load_privkey_function(ENGINE *, ENGINE_LOAD_KEY_PTR);
int ENGINE_set_load_pubkey_function(ENGINE *, ENGINE_LOAD_KEY_PTR);
int ENGINE_set_ciphers(ENGINE *, ENGINE_CIPHERS_PTR);
int ENGINE_set_digests(ENGINE *, ENGINE_DIGESTS_PTR);
int ENGINE_set_flags(ENGINE *, int);
int ENGINE_set_cmd_defns(ENGINE *, const ENGINE_CMD_DEFN *);
const char *ENGINE_get_id(const ENGINE *);
const char *ENGINE_get_name(const ENGINE *);
const RSA_METHOD *ENGINE_get_RSA(const ENGINE *);
const DSA_METHOD *ENGINE_get_DSA(const ENGINE *);
const DH_METHOD *ENGINE_get_DH(const ENGINE *);
const RAND_METHOD *ENGINE_get_RAND(const ENGINE *);

const EVP_CIPHER *ENGINE_get_cipher(ENGINE *, int);
const EVP_MD *ENGINE_get_digest(ENGINE *, int);
int ENGINE_get_flags(const ENGINE *);
const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *);
EVP_PKEY *ENGINE_load_private_key(ENGINE *, const char *, UI_METHOD *, void *);
EVP_PKEY *ENGINE_load_public_key(ENGINE *, const char *, UI_METHOD *, void *);
void ENGINE_add_conf_module(void);


char *ERR_error_string(unsigned long, char *);
void ERR_error_string_n(unsigned long, char *, size_t);
const char *ERR_lib_error_string(unsigned long);
const char *ERR_func_error_string(unsigned long);
const char *ERR_reason_error_string(unsigned long);
void ERR_print_errors(BIO *);
void ERR_print_errors_fp(FILE *);
unsigned long ERR_get_error(void);
unsigned long ERR_peek_error(void);
unsigned long ERR_peek_last_error(void);
unsigned long ERR_get_error_line(const char **, int *);
unsigned long ERR_peek_error_line(const char **, int *);
unsigned long ERR_peek_last_error_line(const char **, int *);
unsigned long ERR_get_error_line_data(const char **, int *,
                                      const char **, int *);
void ERR_clear_error(void);
unsigned long ERR_peek_error_line_data(const char **,
                                       int *, const char **, int *);
unsigned long ERR_peek_last_error_line_data(const char **,
                                            int *, const char **, int *);
void ERR_put_error(int, int, int, const char *, int);
void ERR_add_error_data(int, ...);
int ERR_get_next_error_library(void);
ERR_STATE *ERR_get_state(void);


const EVP_CIPHER *EVP_get_cipherbyname(const char *);
int EVP_EncryptInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
                       const unsigned char *, const unsigned char *);
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *, int);
int EVP_EncryptUpdate(EVP_CIPHER_CTX *, unsigned char *, int *,
                      const unsigned char *, int);
int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *, unsigned char *, int *);
int EVP_DecryptInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
                       const unsigned char *, const unsigned char *);
int EVP_DecryptUpdate(EVP_CIPHER_CTX *, unsigned char *, int *,
                      const unsigned char *, int);
int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *, unsigned char *, int *);
int EVP_CipherInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
                      const unsigned char *, const unsigned char *, int);
int EVP_CipherUpdate(EVP_CIPHER_CTX *, unsigned char *, int *,
                     const unsigned char *, int);
int EVP_CipherFinal_ex(EVP_CIPHER_CTX *, unsigned char *, int *);
int EVP_CIPHER_block_size(const EVP_CIPHER *);
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *);
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *);
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *, int);
const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *);

int EVP_MD_CTX_copy_ex(EVP_MD_CTX *, const EVP_MD_CTX *);
int EVP_DigestInit_ex(EVP_MD_CTX *, const EVP_MD *, ENGINE *);
int EVP_DigestUpdate(EVP_MD_CTX *, const void *, size_t);
int EVP_DigestFinal_ex(EVP_MD_CTX *, unsigned char *, unsigned int *);
const EVP_MD *EVP_get_digestbyname(const char *);
const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *);
int EVP_MD_size(const EVP_MD *);

EVP_PKEY *EVP_PKEY_new(void);
void EVP_PKEY_free(EVP_PKEY *);
int EVP_PKEY_type(int);
int EVP_PKEY_size(EVP_PKEY *);
RSA *EVP_PKEY_get1_RSA(EVP_PKEY *);
DSA *EVP_PKEY_get1_DSA(EVP_PKEY *);
DH *EVP_PKEY_get1_DH(EVP_PKEY *);

int EVP_PKEY_encrypt(EVP_PKEY_CTX *, unsigned char *, size_t *,
                     const unsigned char *, size_t);
int EVP_PKEY_decrypt(EVP_PKEY_CTX *, unsigned char *, size_t *,
                     const unsigned char *, size_t);

int EVP_SignInit(EVP_MD_CTX *, const EVP_MD *);
int EVP_SignUpdate(EVP_MD_CTX *, const void *, size_t);
int EVP_SignFinal(EVP_MD_CTX *, unsigned char *, unsigned int *, EVP_PKEY *);

int EVP_VerifyInit(EVP_MD_CTX *, const EVP_MD *);
int EVP_VerifyUpdate(EVP_MD_CTX *, const void *, size_t);
int EVP_VerifyFinal(EVP_MD_CTX *, const unsigned char *, unsigned int,
                    EVP_PKEY *);

const EVP_MD *EVP_md5(void);
const EVP_MD *EVP_sha1(void);
const EVP_MD *EVP_ripemd160(void);
const EVP_MD *EVP_sha224(void);
const EVP_MD *EVP_sha256(void);
const EVP_MD *EVP_sha384(void);
const EVP_MD *EVP_sha512(void);

int PKCS5_PBKDF2_HMAC_SHA1(const char *, int, const unsigned char *, int, int,
                           int, unsigned char *);

EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *, ENGINE *);
EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int, ENGINE *);
EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *);
void EVP_PKEY_CTX_free(EVP_PKEY_CTX *);
int EVP_PKEY_sign_init(EVP_PKEY_CTX *);
int EVP_PKEY_sign(EVP_PKEY_CTX *, unsigned char *, size_t *,
                  const unsigned char *, size_t);
int EVP_PKEY_verify_init(EVP_PKEY_CTX *);
int EVP_PKEY_verify(EVP_PKEY_CTX *, const unsigned char *, size_t,
                    const unsigned char *, size_t);
int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *);
int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *);

int EVP_PKEY_set1_RSA(EVP_PKEY *, RSA *);
int EVP_PKEY_set1_DSA(EVP_PKEY *, DSA *);
int EVP_PKEY_set1_DH(EVP_PKEY *, DH *);

int EVP_PKEY_get_attr_count(const EVP_PKEY *);
int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *, int, int);
X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *, int);
X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *, int);
int EVP_PKEY_add1_attr(EVP_PKEY *, X509_ATTRIBUTE *);
int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *, const ASN1_OBJECT *, int,
                              const unsigned char *, int);
int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *, int, int,
                              const unsigned char *, int);
int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *, const char *, int,
                              const unsigned char *, int);

int EVP_PKEY_cmp(const EVP_PKEY *, const EVP_PKEY *);

int EVP_PKEY_id(const EVP_PKEY *);
int Cryptography_EVP_PKEY_id(const EVP_PKEY *);

/* in 1.1.0 _create and _destroy were renamed to _new and _free. The following
   two functions wrap both the old and new functions so we can call them
   without worrying about what OpenSSL we're running against. */
EVP_MD_CTX *Cryptography_EVP_MD_CTX_new(void);
void Cryptography_EVP_MD_CTX_free(EVP_MD_CTX *);


int HMAC_Init_ex(HMAC_CTX *, const void *, int, const EVP_MD *, ENGINE *);
int HMAC_Update(HMAC_CTX *, const unsigned char *, size_t);
int HMAC_Final(HMAC_CTX *, unsigned char *, unsigned int *);
int HMAC_CTX_copy(HMAC_CTX *, HMAC_CTX *);

HMAC_CTX *Cryptography_HMAC_CTX_new(void);
void Cryptography_HMAC_CTX_free(HMAC_CTX *ctx);




ASN1_OBJECT *OBJ_nid2obj(int);
const char *OBJ_nid2ln(int);
const char *OBJ_nid2sn(int);
int OBJ_obj2nid(const ASN1_OBJECT *);
int OBJ_ln2nid(const char *);
int OBJ_sn2nid(const char *);
int OBJ_txt2nid(const char *);
ASN1_OBJECT *OBJ_txt2obj(const char *, int);
int OBJ_obj2txt(char *, int, const ASN1_OBJECT *, int);
int OBJ_cmp(const ASN1_OBJECT *, const ASN1_OBJECT *);
ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *);
int OBJ_create(const char *, const char *, const char *);
void OBJ_NAME_do_all(int, void (*) (const OBJ_NAME *, void *), void *);


int OCSP_response_status(OCSP_RESPONSE *);
OCSP_BASICRESP *OCSP_response_get1_basic(OCSP_RESPONSE *);
int OCSP_BASICRESP_get_ext_count(OCSP_BASICRESP *);
X509_EXTENSION *OCSP_BASICRESP_get_ext(OCSP_BASICRESP *, int);
int OCSP_resp_count(OCSP_BASICRESP *);
OCSP_SINGLERESP *OCSP_resp_get0(OCSP_BASICRESP *, int);
int OCSP_SINGLERESP_get_ext_count(OCSP_SINGLERESP *);
X509_EXTENSION *OCSP_SINGLERESP_get_ext(OCSP_SINGLERESP *, int);

int OCSP_single_get0_status(OCSP_SINGLERESP *, int *, ASN1_GENERALIZEDTIME **,
                            ASN1_GENERALIZEDTIME **, ASN1_GENERALIZEDTIME **);

int OCSP_request_onereq_count(OCSP_REQUEST *);
OCSP_ONEREQ *OCSP_request_onereq_get0(OCSP_REQUEST *, int);
int OCSP_ONEREQ_get_ext_count(OCSP_ONEREQ *);
X509_EXTENSION *OCSP_ONEREQ_get_ext(OCSP_ONEREQ *, int);
OCSP_CERTID *OCSP_onereq_get0_id(OCSP_ONEREQ *);


OCSP_BASICRESP *OCSP_BASICRESP_new(void);
void OCSP_BASICRESP_free(OCSP_BASICRESP *);
OCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP *, OCSP_CERTID *, int,
                                        int, ASN1_TIME *, ASN1_TIME *,
                                        ASN1_TIME *);
int OCSP_basic_add1_nonce(OCSP_BASICRESP *, unsigned char *, int);
int OCSP_basic_add1_cert(OCSP_BASICRESP *, X509 *);
int OCSP_BASICRESP_add1_ext_i2d(OCSP_BASICRESP *, int, void *, int,
                                unsigned long);
int OCSP_basic_sign(OCSP_BASICRESP *, X509 *, EVP_PKEY *, const EVP_MD *,
                    Cryptography_STACK_OF_X509 *, unsigned long);
OCSP_RESPONSE *OCSP_response_create(int, OCSP_BASICRESP *);

OCSP_REQUEST *OCSP_REQUEST_new(void);
void OCSP_REQUEST_free(OCSP_REQUEST *);
int OCSP_request_add1_nonce(OCSP_REQUEST *, unsigned char *, int);
int OCSP_REQUEST_add1_ext_i2d(OCSP_REQUEST *, int, void *, int, unsigned long);




int Cryptography_add_osrandom_engine(void);


X509 *PEM_read_bio_X509(BIO *, X509 **, pem_password_cb *, void *);
int PEM_write_bio_X509(BIO *, X509 *);

int PEM_write_bio_PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
                             unsigned char *, int, pem_password_cb *, void *);

EVP_PKEY *PEM_read_bio_PrivateKey(BIO *, EVP_PKEY **, pem_password_cb *,
                                 void *);

int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
                                  char *, int, pem_password_cb *, void *);
int PEM_write_bio_PKCS8PrivateKey_nid(BIO *, EVP_PKEY *, int, char *, int,
                                      pem_password_cb *, void *);

int i2d_PKCS8PrivateKey_bio(BIO *, EVP_PKEY *, const EVP_CIPHER *,
                            char *, int, pem_password_cb *, void *);
int i2d_PKCS8PrivateKey_nid_bio(BIO *, EVP_PKEY *, int,
                                char *, int, pem_password_cb *, void *);

int i2d_PKCS7_bio(BIO *, PKCS7 *);
PKCS7 *d2i_PKCS7_bio(BIO *, PKCS7 **);

EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *, EVP_PKEY **, pem_password_cb *,
                                  void *);

int PEM_write_bio_X509_REQ(BIO *, X509_REQ *);

X509_REQ *PEM_read_bio_X509_REQ(BIO *, X509_REQ **, pem_password_cb *, void *);

X509_CRL *PEM_read_bio_X509_CRL(BIO *, X509_CRL **, pem_password_cb *, void *);

int PEM_write_bio_X509_CRL(BIO *, X509_CRL *);

X509 *PEM_read_bio_X509_AUX(BIO *, X509 **, pem_password_cb *, void *);

PKCS7 *PEM_read_bio_PKCS7(BIO *, PKCS7 **, pem_password_cb *, void *);
int PEM_write_bio_PKCS7(BIO *, PKCS7 *);

DH *PEM_read_bio_DHparams(BIO *, DH **, pem_password_cb *, void *);

DSA *PEM_read_bio_DSAPrivateKey(BIO *, DSA **, pem_password_cb *, void *);

RSA *PEM_read_bio_RSAPrivateKey(BIO *, RSA **, pem_password_cb *, void *);

int PEM_write_bio_DSAPrivateKey(BIO *, DSA *, const EVP_CIPHER *,
                                unsigned char *, int,
                                pem_password_cb *, void *);

int PEM_write_bio_RSAPrivateKey(BIO *, RSA *, const EVP_CIPHER *,
                                unsigned char *, int,
                                pem_password_cb *, void *);

DSA *PEM_read_bio_DSA_PUBKEY(BIO *, DSA **, pem_password_cb *, void *);

RSA *PEM_read_bio_RSAPublicKey(BIO *, RSA **, pem_password_cb *, void *);

int PEM_write_bio_DSA_PUBKEY(BIO *, DSA *);

int PEM_write_bio_RSAPublicKey(BIO *, const RSA *);

EVP_PKEY *PEM_read_bio_PUBKEY(BIO *, EVP_PKEY **, pem_password_cb *, void *);
int PEM_write_bio_PUBKEY(BIO *, EVP_PKEY *);


void PKCS12_free(PKCS12 *);

PKCS12 *d2i_PKCS12_bio(BIO *, PKCS12 **);
int i2d_PKCS12_bio(BIO *, PKCS12 *);


void RAND_seed(const void *, int);
void RAND_add(const void *, int, double);
int RAND_status(void);
const char *RAND_file_name(char *, size_t);
int RAND_load_file(const char *, long);
int RAND_write_file(const char *);
int RAND_bytes(unsigned char *, int);


RSA *RSA_new(void);
void RSA_free(RSA *);
int RSA_size(const RSA *);
int RSA_generate_key_ex(RSA *, int, BIGNUM *, BN_GENCB *);
int RSA_check_key(const RSA *);
RSA *RSAPublicKey_dup(RSA *);
int RSA_blinding_on(RSA *, BN_CTX *);
void RSA_blinding_off(RSA *);
int RSA_public_encrypt(int, const unsigned char *, unsigned char *,
                       RSA *, int);
int RSA_private_encrypt(int, const unsigned char *, unsigned char *,
                        RSA *, int);
int RSA_public_decrypt(int, const unsigned char *, unsigned char *,
                       RSA *, int);
int RSA_private_decrypt(int, const unsigned char *, unsigned char *,
                        RSA *, int);
int RSA_print(BIO *, const RSA *, int);
int RSA_verify_PKCS1_PSS(RSA *, const unsigned char *, const EVP_MD *,
                         const unsigned char *, int);
int RSA_padding_add_PKCS1_PSS(RSA *, unsigned char *, const unsigned char *,
                              const EVP_MD *, int);
int RSA_padding_add_PKCS1_OAEP(unsigned char *, int, const unsigned char *,
                               int, const unsigned char *, int);
int RSA_padding_check_PKCS1_OAEP(unsigned char *, int, const unsigned char *,
                                 int, int, const unsigned char *, int);

/* added in 1.1.0 when the RSA struct was opaqued */
int RSA_set0_key(RSA *, BIGNUM *, BIGNUM *, BIGNUM *);
int RSA_set0_factors(RSA *, BIGNUM *, BIGNUM *);
int RSA_set0_crt_params(RSA *, BIGNUM *, BIGNUM *, BIGNUM *);
void RSA_get0_key(const RSA *, const BIGNUM **, const BIGNUM **,
                  const BIGNUM **);
void RSA_get0_factors(const RSA *, const BIGNUM **, const BIGNUM **);
void RSA_get0_crt_params(const RSA *, const BIGNUM **, const BIGNUM **,
                         const BIGNUM **);


/*  SSL */
const char *SSL_state_string_long(const SSL *);
SSL_SESSION *SSL_get1_session(SSL *);
int SSL_set_session(SSL *, SSL_SESSION *);
int SSL_get_verify_mode(const SSL *);
void SSL_set_verify(SSL *, int, int (*)(int, X509_STORE_CTX *));
void SSL_set_verify_depth(SSL *, int);
int SSL_get_verify_depth(const SSL *);
int (*SSL_get_verify_callback(const SSL *))(int, X509_STORE_CTX *);
void SSL_set_info_callback(SSL *ssl, void (*)(const SSL *, int, int));
void (*SSL_get_info_callback(const SSL *))(const SSL *, int, int);
SSL *SSL_new(SSL_CTX *);
void SSL_free(SSL *);
int SSL_set_fd(SSL *, int);
SSL_CTX *SSL_get_SSL_CTX(const SSL *);
SSL_CTX *SSL_set_SSL_CTX(SSL *, SSL_CTX *);
BIO *SSL_get_rbio(const SSL *);
BIO *SSL_get_wbio(const SSL *);
void SSL_set_bio(SSL *, BIO *, BIO *);
void SSL_set_connect_state(SSL *);
void SSL_set_accept_state(SSL *);
void SSL_set_shutdown(SSL *, int);
int SSL_get_shutdown(const SSL *);
int SSL_pending(const SSL *);
int SSL_write(SSL *, const void *, int);
int SSL_read(SSL *, void *, int);
int SSL_peek(SSL *, void *, int);
X509 *SSL_get_peer_certificate(const SSL *);
int SSL_get_ex_data_X509_STORE_CTX_idx(void);

int SSL_use_certificate(SSL *, X509 *);
int SSL_use_certificate_ASN1(SSL *, const unsigned char *, int);
int SSL_use_certificate_file(SSL *, const char *, int);
int SSL_use_PrivateKey(SSL *, EVP_PKEY *);
int SSL_use_PrivateKey_ASN1(int, SSL *, const unsigned char *, long);
int SSL_use_PrivateKey_file(SSL *, const char *, int);
int SSL_check_private_key(const SSL *);

Cryptography_STACK_OF_X509 *SSL_get_peer_cert_chain(const SSL *);
Cryptography_STACK_OF_X509_NAME *SSL_get_client_CA_list(const SSL *);

int SSL_get_error(const SSL *, int);
int SSL_do_handshake(SSL *);
int SSL_shutdown(SSL *);
int SSL_renegotiate(SSL *);
int SSL_renegotiate_pending(SSL *);
const char *SSL_get_cipher_list(const SSL *, int);
Cryptography_STACK_OF_SSL_CIPHER *SSL_get_ciphers(const SSL *);

/*  context */
void SSL_CTX_free(SSL_CTX *);
long SSL_CTX_set_timeout(SSL_CTX *, long);
int SSL_CTX_set_default_verify_paths(SSL_CTX *);
void SSL_CTX_set_verify(SSL_CTX *, int, int (*)(int, X509_STORE_CTX *));
void SSL_CTX_set_verify_depth(SSL_CTX *, int);
int (*SSL_CTX_get_verify_callback(const SSL_CTX *))(int, X509_STORE_CTX *);
int SSL_CTX_get_verify_mode(const SSL_CTX *);
int SSL_CTX_get_verify_depth(const SSL_CTX *);
int SSL_CTX_set_cipher_list(SSL_CTX *, const char *);
int SSL_CTX_load_verify_locations(SSL_CTX *, const char *, const char *);
void SSL_CTX_set_default_passwd_cb(SSL_CTX *, pem_password_cb *);
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *, void *);
int SSL_CTX_use_certificate(SSL_CTX *, X509 *);
int SSL_CTX_use_certificate_ASN1(SSL_CTX *, int, const unsigned char *);
int SSL_CTX_use_certificate_file(SSL_CTX *, const char *, int);
int SSL_CTX_use_certificate_chain_file(SSL_CTX *, const char *);
int SSL_CTX_use_PrivateKey(SSL_CTX *, EVP_PKEY *);
int SSL_CTX_use_PrivateKey_ASN1(int, SSL_CTX *, const unsigned char *, long);
int SSL_CTX_use_PrivateKey_file(SSL_CTX *, const char *, int);
int SSL_CTX_check_private_key(const SSL_CTX *);
void SSL_CTX_set_cert_verify_callback(SSL_CTX *,
                                      int (*)(X509_STORE_CTX *,void *),
                                      void *);
int SSL_CTX_set_session_id_context(SSL_CTX *, const unsigned char *,
                                   unsigned int);

void SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);
X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);
int SSL_CTX_add_client_CA(SSL_CTX *, X509 *);

void SSL_CTX_set_client_CA_list(SSL_CTX *, Cryptography_STACK_OF_X509_NAME *);

void SSL_CTX_set_info_callback(SSL_CTX *, void (*)(const SSL *, int, int));
void (*SSL_CTX_get_info_callback(SSL_CTX *))(const SSL *, int, int);

/*  SSL_SESSION */
void SSL_SESSION_free(SSL_SESSION *);

/* Information about actually used cipher */
const char *SSL_CIPHER_get_name(const SSL_CIPHER *);
int SSL_CIPHER_get_bits(const SSL_CIPHER *, int *);

size_t SSL_get_finished(const SSL *, void *, size_t);
size_t SSL_get_peer_finished(const SSL *, void *, size_t);
Cryptography_STACK_OF_X509_NAME *SSL_load_client_CA_file(const char *);

const char *SSL_get_servername(const SSL *, const int);


X509 *X509_new(void);
void X509_free(X509 *);
X509 *X509_dup(X509 *);
int X509_cmp(const X509 *, const X509 *);

int X509_print_ex(BIO *, X509 *, unsigned long, unsigned long);

int X509_set_version(X509 *, long);

EVP_PKEY *X509_get_pubkey(X509 *);
int X509_set_pubkey(X509 *, EVP_PKEY *);

unsigned char *X509_alias_get0(X509 *, int *);
int X509_sign(X509 *, EVP_PKEY *, const EVP_MD *);

int X509_digest(const X509 *, const EVP_MD *, unsigned char *, unsigned int *);

ASN1_TIME *X509_gmtime_adj(ASN1_TIME *, long);

unsigned long X509_subject_name_hash(X509 *);

int X509_set_subject_name(X509 *, X509_NAME *);

int X509_set_issuer_name(X509 *, X509_NAME *);

int X509_add_ext(X509 *, X509_EXTENSION *, int);
X509_EXTENSION *X509_delete_ext(X509 *, int);
X509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *);

ASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *);
void X509_EXTENSION_free(X509_EXTENSION *);

int i2d_X509(X509 *, unsigned char **);

int X509_REQ_set_version(X509_REQ *, long);
X509_REQ *X509_REQ_new(void);
void X509_REQ_free(X509_REQ *);
int X509_REQ_set_pubkey(X509_REQ *, EVP_PKEY *);
int X509_REQ_set_subject_name(X509_REQ *, X509_NAME *);
int X509_REQ_sign(X509_REQ *, EVP_PKEY *, const EVP_MD *);
int X509_REQ_verify(X509_REQ *, EVP_PKEY *);
int X509_REQ_digest(const X509_REQ *, const EVP_MD *,
                    unsigned char *, unsigned int *);
EVP_PKEY *X509_REQ_get_pubkey(X509_REQ *);
int X509_REQ_print(BIO *, X509_REQ *);
int X509_REQ_print_ex(BIO *, X509_REQ *, unsigned long, unsigned long);
int X509_REQ_add_extensions(X509_REQ *, X509_EXTENSIONS *);
X509_EXTENSIONS *X509_REQ_get_extensions(X509_REQ *);

int X509V3_EXT_print(BIO *, X509_EXTENSION *, unsigned long, int);
ASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *);

X509_REVOKED *X509_REVOKED_new(void);
void X509_REVOKED_free(X509_REVOKED *);

int X509_REVOKED_set_serialNumber(X509_REVOKED *, ASN1_INTEGER *);

int X509_REVOKED_add_ext(X509_REVOKED *, X509_EXTENSION*, int);
int X509_REVOKED_add1_ext_i2d(X509_REVOKED *, int, void *, int, unsigned long);
X509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *, int);

int X509_REVOKED_set_revocationDate(X509_REVOKED *, ASN1_TIME *);

X509_CRL *X509_CRL_new(void);
X509_CRL *d2i_X509_CRL_bio(BIO *, X509_CRL **);
int X509_CRL_add0_revoked(X509_CRL *, X509_REVOKED *);
int X509_CRL_add_ext(X509_CRL *, X509_EXTENSION *, int);
int X509_CRL_cmp(const X509_CRL *, const X509_CRL *);
int X509_CRL_print(BIO *, X509_CRL *);
int X509_CRL_set_issuer_name(X509_CRL *, X509_NAME *);
int X509_CRL_set_version(X509_CRL *, long);
int X509_CRL_sign(X509_CRL *, EVP_PKEY *, const EVP_MD *);
int X509_CRL_sort(X509_CRL *);
int X509_CRL_verify(X509_CRL *, EVP_PKEY *);
int i2d_X509_CRL_bio(BIO *, X509_CRL *);
void X509_CRL_free(X509_CRL *);

int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *, EVP_PKEY *);
int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *, EVP_PKEY *, const EVP_MD *);
char *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *);
NETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *, int);
EVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *);
int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *, EVP_PKEY *);
NETSCAPE_SPKI *NETSCAPE_SPKI_new(void);
void NETSCAPE_SPKI_free(NETSCAPE_SPKI *);

/*  ASN1 serialization */
int i2d_X509_bio(BIO *, X509 *);
X509 *d2i_X509_bio(BIO *, X509 **);

int i2d_X509_REQ_bio(BIO *, X509_REQ *);
X509_REQ *d2i_X509_REQ_bio(BIO *, X509_REQ **);

int i2d_PrivateKey_bio(BIO *, EVP_PKEY *);
EVP_PKEY *d2i_PrivateKey_bio(BIO *, EVP_PKEY **);
int i2d_PUBKEY_bio(BIO *, EVP_PKEY *);
EVP_PKEY *d2i_PUBKEY_bio(BIO *, EVP_PKEY **);

ASN1_INTEGER *X509_get_serialNumber(X509 *);
int X509_set_serialNumber(X509 *, ASN1_INTEGER *);

const char *X509_verify_cert_error_string(long);

const char *X509_get_default_cert_area(void);
const char *X509_get_default_cert_dir(void);
const char *X509_get_default_cert_file(void);
const char *X509_get_default_cert_dir_env(void);
const char *X509_get_default_cert_file_env(void);
const char *X509_get_default_private_dir(void);

int i2d_RSA_PUBKEY(RSA *, unsigned char **);
RSA *d2i_RSA_PUBKEY(RSA **, const unsigned char **, long);
RSA *d2i_RSAPublicKey(RSA **, const unsigned char **, long);
RSA *d2i_RSAPrivateKey(RSA **, const unsigned char **, long);
int i2d_DSA_PUBKEY(DSA *, unsigned char **);
DSA *d2i_DSA_PUBKEY(DSA **, const unsigned char **, long);
DSA *d2i_DSAPublicKey(DSA **, const unsigned char **, long);
DSA *d2i_DSAPrivateKey(DSA **, const unsigned char **, long);

RSA *d2i_RSAPrivateKey_bio(BIO *, RSA **);
int i2d_RSAPrivateKey_bio(BIO *, RSA *);
RSA *d2i_RSAPublicKey_bio(BIO *, RSA **);
int i2d_RSAPublicKey_bio(BIO *, RSA *);
RSA *d2i_RSA_PUBKEY_bio(BIO *, RSA **);
int i2d_RSA_PUBKEY_bio(BIO *, RSA *);
DSA *d2i_DSA_PUBKEY_bio(BIO *, DSA **);
int i2d_DSA_PUBKEY_bio(BIO *, DSA *);
DSA *d2i_DSAPrivateKey_bio(BIO *, DSA **);
int i2d_DSAPrivateKey_bio(BIO *, DSA *);

PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *,
                                                 PKCS8_PRIV_KEY_INFO **);
void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *);


X509_NAME *X509_NAME_new(void);
void X509_NAME_free(X509_NAME *);

unsigned long X509_NAME_hash(X509_NAME *);

int i2d_X509_NAME(X509_NAME *, unsigned char **);
int X509_NAME_add_entry_by_txt(X509_NAME *, const char *, int,
                               const unsigned char *, int, int, int);
X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *, int);
void X509_NAME_ENTRY_free(X509_NAME_ENTRY *);
int X509_NAME_get_index_by_NID(X509_NAME *, int, int);
int X509_NAME_cmp(const X509_NAME *, const X509_NAME *);
X509_NAME *X509_NAME_dup(X509_NAME *);
int Cryptography_X509_NAME_ENTRY_set(X509_NAME_ENTRY *);


int X509V3_EXT_add_alias(int, int);
void X509V3_set_ctx(X509V3_CTX *, X509 *, X509 *, X509_REQ *, X509_CRL *, int);
int GENERAL_NAME_print(BIO *, GENERAL_NAME *);
GENERAL_NAMES *GENERAL_NAMES_new(void);
void GENERAL_NAMES_free(GENERAL_NAMES *);
void *X509V3_EXT_d2i(X509_EXTENSION *);
int X509_check_ca(X509 *);


int X509_verify_cert(X509_STORE_CTX *);

/* X509_STORE */
X509_STORE *X509_STORE_new(void);
int X509_STORE_add_cert(X509_STORE *, X509 *);
int X509_STORE_add_crl(X509_STORE *, X509_CRL *);
int X509_STORE_load_locations(X509_STORE *, const char *, const char *);
int X509_STORE_set1_param(X509_STORE *, X509_VERIFY_PARAM *);
int X509_STORE_set_default_paths(X509_STORE *);
int X509_STORE_set_flags(X509_STORE *, unsigned long);
void X509_STORE_free(X509_STORE *);

/* X509_STORE_CTX */
X509_STORE_CTX *X509_STORE_CTX_new(void);
void X509_STORE_CTX_cleanup(X509_STORE_CTX *);
void X509_STORE_CTX_free(X509_STORE_CTX *);
int X509_STORE_CTX_init(X509_STORE_CTX *, X509_STORE *, X509 *,
                        Cryptography_STACK_OF_X509 *);
void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *,
                                  Cryptography_STACK_OF_X509 *);
void X509_STORE_CTX_set_cert(X509_STORE_CTX *, X509 *);
void X509_STORE_CTX_set_chain(X509_STORE_CTX *,Cryptography_STACK_OF_X509 *);
X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *);
void X509_STORE_CTX_set0_param(X509_STORE_CTX *, X509_VERIFY_PARAM *);
int X509_STORE_CTX_set_default(X509_STORE_CTX *, const char *);
void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *,
                                  int (*)(int, X509_STORE_CTX *));
Cryptography_STACK_OF_X509 *X509_STORE_CTX_get_chain(X509_STORE_CTX *);
Cryptography_STACK_OF_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *);
int X509_STORE_CTX_get_error(X509_STORE_CTX *);
void X509_STORE_CTX_set_error(X509_STORE_CTX *, int);
int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *);
X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *);
int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *, int, void *);
void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *, int);
int X509_STORE_CTX_get1_issuer(X509 **, X509_STORE_CTX *, X509 *);

/* X509_VERIFY_PARAM */
X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);
int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *, unsigned long);
int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *, unsigned long);
unsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *);
int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *, int);
int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *, int);
void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *, time_t);
int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *, ASN1_OBJECT *);
int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *,
                                    Cryptography_STACK_OF_ASN1_OBJECT *);
void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *, int);
int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *);
void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *);


PKCS7 *SMIME_read_PKCS7(BIO *, BIO **);
int SMIME_write_PKCS7(BIO *, PKCS7 *, BIO *, int);

void PKCS7_free(PKCS7 *);

PKCS7 *PKCS7_sign(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *,
                  BIO *, int);
int PKCS7_verify(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *,
                 BIO *, int);
Cryptography_STACK_OF_X509 *PKCS7_get0_signers(PKCS7 *,
                                               Cryptography_STACK_OF_X509 *,
                                               int);

PKCS7 *PKCS7_encrypt(Cryptography_STACK_OF_X509 *, BIO *,
                     const EVP_CIPHER *, int);
int PKCS7_decrypt(PKCS7 *, EVP_PKEY *, X509 *, BIO *, int);

BIO *PKCS7_dataInit(PKCS7 *, BIO *);


int _setup_ssl_threads(void);
int Cryptography_pem_password_cb(char *, int, int, void *);




static const long Cryptography_HAS_AES_WRAP = 1;


/* This macro is removed in 1.1.0. We re-add it if required to support
   pyOpenSSL versions older than whatever resolves
   https://github.com/pyca/pyopenssl/issues/431 */
#if !defined(M_ASN1_TIME_dup)
#define M_ASN1_TIME_dup(a) (ASN1_TIME *)ASN1_STRING_dup((const ASN1_STRING *)a)
#endif




#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE4
int BIO_up_ref(BIO *b) {
    CRYPTO_add(&b->references, 1, CRYPTO_LOCK_BIO);
    return 1;
}
#endif


static const long Cryptography_HAS_CMAC = 1;


#if !defined(OPENSSL_NO_CMS)
static const long Cryptography_HAS_CMS = 1;
static const long Cryptography_HAS_CMS_BIO_FUNCTIONS = 1;
#else
static const long Cryptography_HAS_CMS = 0;
static const long Cryptography_HAS_CMS_BIO_FUNCTIONS = 0;
typedef void CMS_ContentInfo;
typedef void CMS_SignerInfo;
typedef void CMS_CertificateChoices;
typedef void CMS_RevocationInfoChoice;
typedef void CMS_RecipientInfo;
typedef void CMS_ReceiptRequest;
typedef void CMS_Receipt;
const long CMS_TEXT = 0;
const long CMS_NOCERTS = 0;
const long CMS_NO_CONTENT_VERIFY = 0;
const long CMS_NO_ATTR_VERIFY = 0;
const long CMS_NOSIGS = 0;
const long CMS_NOINTERN = 0;
const long CMS_NO_SIGNER_CERT_VERIFY = 0;
const long CMS_NOVERIFY = 0;
const long CMS_DETACHED = 0;
const long CMS_BINARY = 0;
const long CMS_NOATTR = 0;
const long CMS_NOSMIMECAP = 0;
const long CMS_NOOLDMIMETYPE = 0;
const long CMS_CRLFEOL = 0;
const long CMS_STREAM = 0;
const long CMS_NOCRL = 0;
const long CMS_PARTIAL = 0;
const long CMS_REUSE_DIGEST = 0;
const long CMS_USE_KEYID = 0;
const long CMS_DEBUG_DECRYPT = 0;
BIO *(*BIO_new_CMS)(BIO *, CMS_ContentInfo *) = NULL;
int (*i2d_CMS_bio_stream)(BIO *, CMS_ContentInfo *, BIO *, int) = NULL;
int (*PEM_write_bio_CMS_stream)(BIO *, CMS_ContentInfo *, BIO *, int) = NULL;
int (*CMS_final)(CMS_ContentInfo *, BIO *, BIO *, unsigned int) = NULL;
CMS_ContentInfo *(*CMS_sign)(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *,
                             BIO *, unsigned int) = NULL;
int (*CMS_verify)(CMS_ContentInfo *, Cryptography_STACK_OF_X509 *,
                  X509_STORE *, BIO *, BIO *, unsigned int) = NULL;
CMS_ContentInfo *(*CMS_encrypt)(Cryptography_STACK_OF_X509 *, BIO *,
                                const EVP_CIPHER *, unsigned int) = NULL;
int (*CMS_decrypt)(CMS_ContentInfo *, EVP_PKEY *, X509 *, BIO *, BIO *,
                   unsigned int) = NULL;
CMS_SignerInfo *(*CMS_add1_signer)(CMS_ContentInfo *, X509 *, EVP_PKEY *,
                                   const EVP_MD *, unsigned int) = NULL;
#endif




/* In 1.1.0 SSLeay has finally been retired. We bidirectionally define the
   values so you can use either one. This is so we can use the new function
   names no matter what OpenSSL we're running on, but users on older pyOpenSSL
   releases won't see issues if they're running OpenSSL 1.1.0 */
#if !defined(SSLEAY_VERSION)
# define SSLeay                  OpenSSL_version_num
# define SSLeay_version          OpenSSL_version
# define SSLEAY_VERSION_NUMBER   OPENSSL_VERSION_NUMBER
# define SSLEAY_VERSION          OPENSSL_VERSION
# define SSLEAY_CFLAGS           OPENSSL_CFLAGS
# define SSLEAY_BUILT_ON         OPENSSL_BUILT_ON
# define SSLEAY_PLATFORM         OPENSSL_PLATFORM
# define SSLEAY_DIR              OPENSSL_DIR
#endif
#if !defined(OPENSSL_VERSION)
# define OpenSSL_version_num     SSLeay
# define OpenSSL_version         SSLeay_version
# define OPENSSL_VERSION         SSLEAY_VERSION
# define OPENSSL_CFLAGS          SSLEAY_CFLAGS
# define OPENSSL_BUILT_ON        SSLEAY_BUILT_ON
# define OPENSSL_PLATFORM        SSLEAY_PLATFORM
# define OPENSSL_DIR             SSLEAY_DIR
#endif
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
static const long Cryptography_HAS_LOCKING_CALLBACKS = 1;
#else
static const long Cryptography_HAS_LOCKING_CALLBACKS = 0;
#if !defined(CRYPTO_LOCK)
static const long CRYPTO_LOCK = 0;
#endif
#if !defined(CRYPTO_UNLOCK)
static const long CRYPTO_UNLOCK = 0;
#endif
#if !defined(CRYPTO_READ)
static const long CRYPTO_READ = 0;
#endif
#if !defined(CRYPTO_LOCK_SSL)
static const long CRYPTO_LOCK_SSL = 0;
#endif
void (*CRYPTO_lock)(int, int, const char *, int) = NULL;
#endif

#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
/* This function has a significantly different signature pre-1.1.0. since it is
 * for testing only, we don't bother to expose it on older OpenSSLs.
 */
static const long Cryptography_HAS_MEM_FUNCTIONS = 0;
int (*Cryptography_CRYPTO_set_mem_functions)(
    void *(*)(size_t, const char *, int),
    void *(*)(void *, size_t, const char *, int),
    void (*)(void *, const char *, int)) = NULL;

#else
static const long Cryptography_HAS_MEM_FUNCTIONS = 1;

int Cryptography_CRYPTO_set_mem_functions(
    void *(*m)(size_t, const char *, int),
    void *(*r)(void *, size_t, const char *, int),
    void (*f)(void *, const char *, int)
) {
    return CRYPTO_set_mem_functions(m, r, f);
}
#endif

void *Cryptography_malloc_wrapper(size_t size, const char *path, int line) {
    return malloc(size);
}

void *Cryptography_realloc_wrapper(void *ptr, size_t size, const char *path,
                                   int line) {
    return realloc(ptr, size);
}

void Cryptography_free_wrapper(void *ptr, const char *path, int line) {
    return free(ptr);
}


#if CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
static const long Cryptography_HAS_SCT = 1;
#else
static const long Cryptography_HAS_SCT = 0;

typedef enum {
    SCT_VERSION_NOT_SET,
    SCT_VERSION_V1
} sct_version_t;
typedef enum {
    CT_LOG_ENTRY_TYPE_NOT_SET,
    CT_LOG_ENTRY_TYPE_X509,
    CT_LOG_ENTRY_TYPE_PRECERT
} ct_log_entry_type_t;
typedef enum {
    SCT_SOURCE_UNKNOWN,
    SCT_SOURCE_TLS_EXTENSION,
    SCT_SOURCE_X509V3_EXTENSION,
    SCT_SOURCE_OCSP_STAPLED_RESPONSE
} sct_source_t;
typedef void SCT;
typedef void Cryptography_STACK_OF_SCT;

sct_version_t (*SCT_get_version)(const SCT *) = NULL;
ct_log_entry_type_t (*SCT_get_log_entry_type)(const SCT *) = NULL;
size_t (*SCT_get0_log_id)(const SCT *, unsigned char **) = NULL;
uint64_t (*SCT_get_timestamp)(const SCT *) = NULL;

int (*SCT_set_source)(SCT *, sct_source_t) = NULL;

int (*sk_SCT_num)(const Cryptography_STACK_OF_SCT *) = NULL;
SCT *(*sk_SCT_value)(const Cryptography_STACK_OF_SCT *, int) = NULL;

void (*SCT_LIST_free)(Cryptography_STACK_OF_SCT *) = NULL;
#endif


/* These functions were added in OpenSSL 1.1.0-pre5 (beta2) */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE5
void DH_get0_pqg(const DH *dh,
                 const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
{
    if (p != NULL)
        *p = dh->p;
    if (q != NULL)
        *q = dh->q;
    if (g != NULL)
        *g = dh->g;
}

int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
{
    /* If the fields p and g in d are NULL, the corresponding input
     * parameters MUST be non-NULL.  q may remain NULL.
     */
    if ((dh->p == NULL && p == NULL)
        || (dh->g == NULL && g == NULL))
        return 0;

    if (p != NULL) {
        BN_free(dh->p);
        dh->p = p;
    }
    if (q != NULL) {
        BN_free(dh->q);
        dh->q = q;
    }
    if (g != NULL) {
        BN_free(dh->g);
        dh->g = g;
    }

    if (q != NULL) {
        dh->length = BN_num_bits(q);
    }

    return 1;
}

void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key)
{
    if (pub_key != NULL)
        *pub_key = dh->pub_key;
    if (priv_key != NULL)
        *priv_key = dh->priv_key;
}

int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
{
    /* If the field pub_key in dh is NULL, the corresponding input
     * parameters MUST be non-NULL.  The priv_key field may
     * be left NULL.
     */
    if (dh->pub_key == NULL && pub_key == NULL)
        return 0;

    if (pub_key != NULL) {
        BN_free(dh->pub_key);
        dh->pub_key = pub_key;
    }
    if (priv_key != NULL) {
        BN_free(dh->priv_key);
        dh->priv_key = priv_key;
    }

    return 1;
}
#endif

#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
#ifndef DH_CHECK_Q_NOT_PRIME
#define DH_CHECK_Q_NOT_PRIME            0x10
#endif

#ifndef DH_CHECK_INVALID_Q_VALUE
#define DH_CHECK_INVALID_Q_VALUE        0x20
#endif

#ifndef DH_CHECK_INVALID_J_VALUE
#define DH_CHECK_INVALID_J_VALUE        0x40
#endif

/* DH_check implementation taken from OpenSSL 1.1.0pre6 */

/*-
 * Check that p is a safe prime and
 * if g is 2, 3 or 5, check that it is a suitable generator
 * where
 * for 2, p mod 24 == 11
 * for 3, p mod 12 == 5
 * for 5, p mod 10 == 3 or 7
 * should hold.
 */

int Cryptography_DH_check(const DH *dh, int *ret)
{
    int ok = 0, r;
    BN_CTX *ctx = NULL;
    BN_ULONG l;
    BIGNUM *t1 = NULL, *t2 = NULL;

    *ret = 0;
    ctx = BN_CTX_new();
    if (ctx == NULL)
        goto err;
    BN_CTX_start(ctx);
    t1 = BN_CTX_get(ctx);
    if (t1 == NULL)
        goto err;
    t2 = BN_CTX_get(ctx);
    if (t2 == NULL)
        goto err;

    if (dh->q) {
        if (BN_cmp(dh->g, BN_value_one()) <= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else if (BN_cmp(dh->g, dh->p) >= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else {
            /* Check g^q == 1 mod p */
            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))
                goto err;
            if (!BN_is_one(t1))
                *ret |= DH_NOT_SUITABLE_GENERATOR;
        }
        r = BN_is_prime_ex(dh->q, BN_prime_checks, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_Q_NOT_PRIME;
        /* Check p == 1 mod q  i.e. q divides p - 1 */
        if (!BN_div(t1, t2, dh->p, dh->q, ctx))
            goto err;
        if (!BN_is_one(t2))
            *ret |= DH_CHECK_INVALID_Q_VALUE;
        if (dh->j && BN_cmp(dh->j, t1))
            *ret |= DH_CHECK_INVALID_J_VALUE;

    } else if (BN_is_word(dh->g, DH_GENERATOR_2)) {
        l = BN_mod_word(dh->p, 24);
        if (l == (BN_ULONG)-1)
            goto err;
        if (l != 11)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
    } else if (BN_is_word(dh->g, DH_GENERATOR_5)) {
        l = BN_mod_word(dh->p, 10);
        if (l == (BN_ULONG)-1)
            goto err;
        if ((l != 3) && (l != 7))
            *ret |= DH_NOT_SUITABLE_GENERATOR;
    } else
        *ret |= DH_UNABLE_TO_CHECK_GENERATOR;

    r = BN_is_prime_ex(dh->p, BN_prime_checks, ctx, NULL);
    if (r < 0)
        goto err;
    if (!r)
        *ret |= DH_CHECK_P_NOT_PRIME;
    else if (!dh->q) {
        if (!BN_rshift1(t1, dh->p))
            goto err;
        r = BN_is_prime_ex(t1, BN_prime_checks, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;
    }
    ok = 1;
 err:
    if (ctx != NULL) {
        BN_CTX_end(ctx);
        BN_CTX_free(ctx);
    }
    return (ok);
}
#else
int Cryptography_DH_check(const DH *dh, int *ret) {
    return DH_check(dh, ret);
}
#endif

/* These functions were added in OpenSSL 1.1.0f commit d0c50e80a8 */
/* Define our own to simplify support across all versions. */
#if defined(EVP_PKEY_DHX) && EVP_PKEY_DHX != -1
DH *Cryptography_d2i_DHxparams_bio(BIO *bp, DH **x) {
    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x);
}
int Cryptography_i2d_DHxparams_bio(BIO *bp, DH *x) {
    return ASN1_i2d_bio_of_const(DH, i2d_DHxparams, bp, x);
}
#else
DH *(*Cryptography_d2i_DHxparams_bio)(BIO *bp, DH **x) = NULL;
int (*Cryptography_i2d_DHxparams_bio)(BIO *bp, DH *x) = NULL;
#endif


/* These functions were added in OpenSSL 1.1.0-pre5 (beta2) */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE5
void DSA_get0_pqg(const DSA *d,
                  const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
{
    if (p != NULL)
        *p = d->p;
    if (q != NULL)
        *q = d->q;
    if (g != NULL)
        *g = d->g;
}
int DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
{
    /* If the fields p, q and g in d are NULL, the corresponding input
     * parameters MUST be non-NULL.
     */
    if ((d->p == NULL && p == NULL)
        || (d->q == NULL && q == NULL)
        || (d->g == NULL && g == NULL))
        return 0;

    if (p != NULL) {
        BN_free(d->p);
        d->p = p;
    }
    if (q != NULL) {
        BN_free(d->q);
        d->q = q;
    }
    if (g != NULL) {
        BN_free(d->g);
        d->g = g;
    }

    return 1;
}
void DSA_get0_key(const DSA *d,
                  const BIGNUM **pub_key, const BIGNUM **priv_key)
{
    if (pub_key != NULL)
        *pub_key = d->pub_key;
    if (priv_key != NULL)
        *priv_key = d->priv_key;
}
int DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)
{
    /* If the field pub_key in d is NULL, the corresponding input
     * parameters MUST be non-NULL.  The priv_key field may
     * be left NULL.
     */
    if (d->pub_key == NULL && pub_key == NULL)
        return 0;

    if (pub_key != NULL) {
        BN_free(d->pub_key);
        d->pub_key = pub_key;
    }
    if (priv_key != NULL) {
        BN_free(d->priv_key);
        d->priv_key = priv_key;
    }

    return 1;
}
#endif


static const long Cryptography_HAS_EC = 1;

#if defined(OPENSSL_NO_EC2M)
static const long Cryptography_HAS_EC2M = 0;

const EC_METHOD *(*EC_GF2m_simple_method)() = NULL;

int (*EC_POINT_set_affine_coordinates_GF2m)(const EC_GROUP *, EC_POINT *,
    const BIGNUM *, const BIGNUM *, BN_CTX *) = NULL;

int (*EC_POINT_get_affine_coordinates_GF2m)(const EC_GROUP *,
    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *) = NULL;

int (*EC_POINT_set_compressed_coordinates_GF2m)(const EC_GROUP *, EC_POINT *,
    const BIGNUM *, int, BN_CTX *) = NULL;

int (*EC_GROUP_set_curve_GF2m)(
    EC_GROUP *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);

int (*EC_GROUP_get_curve_GF2m)(
    const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);

EC_GROUP *(*EC_GROUP_new_curve_GF2m)(
    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
#else
static const long Cryptography_HAS_EC2M = 1;
#endif

#if (!CRYPTOGRAPHY_IS_LIBRESSL && CRYPTOGRAPHY_OPENSSL_LESS_THAN_102) ||     (CRYPTOGRAPHY_IS_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x20020002L)
static const long Cryptography_HAS_EC_1_0_2 = 0;
const char *(*EC_curve_nid2nist)(int) = NULL;
#else
static const long Cryptography_HAS_EC_1_0_2 = 1;
#endif


static const long Cryptography_HAS_ECDH = 1;

#ifndef SSL_CTX_set_ecdh_auto
static const long Cryptography_HAS_SET_ECDH_AUTO = 0;
int (*SSL_CTX_set_ecdh_auto)(SSL_CTX *, int) = NULL;
#else
static const long Cryptography_HAS_SET_ECDH_AUTO = 1;
#endif


static const long Cryptography_HAS_ECDSA = 1;


#if CRYPTOGRAPHY_IS_LIBRESSL
static const long Cryptography_HAS_ENGINE_CRYPTODEV = 0;
void (*ENGINE_load_cryptodev)(void) = NULL;
#else
static const long Cryptography_HAS_ENGINE_CRYPTODEV = 1;
#endif


static const long Cryptography_HAS_EC_CODES = 1;

#ifdef RSA_R_PKCS_DECODING_ERROR
static const long Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR = 1;
#else
static const long Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR = 0;
static const long RSA_R_PKCS_DECODING_ERROR = 0;
#endif


const long Cryptography_HAS_GCM = 1;

const long Cryptography_HAS_PBKDF2_HMAC = 1;
const long Cryptography_HAS_PKEY_CTX = 1;

#ifdef EVP_PKEY_DHX
const long Cryptography_HAS_EVP_PKEY_DHX = 1;
#else
const long Cryptography_HAS_EVP_PKEY_DHX = 0;
const long EVP_PKEY_DHX = -1;
#endif

int Cryptography_EVP_PKEY_id(const EVP_PKEY *key) {
    return EVP_PKEY_id(key);
}

EVP_MD_CTX *Cryptography_EVP_MD_CTX_new(void) {
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
    return EVP_MD_CTX_create();
#else
    return EVP_MD_CTX_new();
#endif
}
void Cryptography_EVP_MD_CTX_free(EVP_MD_CTX *ctx) {
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
    EVP_MD_CTX_destroy(ctx);
#else
    EVP_MD_CTX_free(ctx);
#endif
}
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110 || defined(OPENSSL_NO_SCRYPT)
static const long Cryptography_HAS_SCRYPT = 0;
int (*EVP_PBE_scrypt)(const char *, size_t, const unsigned char *, size_t,
                      uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *,
                      size_t) = NULL;
#else
static const long Cryptography_HAS_SCRYPT = 1;
#endif


HMAC_CTX *Cryptography_HMAC_CTX_new(void) {
#if CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
    return HMAC_CTX_new();
#else
    /* This uses OPENSSL_zalloc in 1.1.0, which is malloc + memset */
    HMAC_CTX *ctx = (HMAC_CTX *)OPENSSL_malloc(sizeof(HMAC_CTX));
    memset(ctx, 0, sizeof(HMAC_CTX));
    return ctx;
#endif
}


void Cryptography_HMAC_CTX_free(HMAC_CTX *ctx) {
#if CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
    return HMAC_CTX_free(ctx);
#else
    if (ctx != NULL) {
        HMAC_CTX_cleanup(ctx);
        OPENSSL_free(ctx);
    }
#endif
}


#ifndef NID_X25519
static const long Cryptography_HAS_X25519 = 0;
static const int NID_X25519 = 0;
#else
static const long Cryptography_HAS_X25519 = 1;
#endif







/* osurandom engine
 *
 * Windows         CryptGenRandom()
 * macOS >= 10.12  getentropy()
 * OpenBSD 5.6+    getentropy()
 * other BSD       getentropy() if SYS_getentropy is defined
 * Linux 3.4.17+   getrandom() with fallback to /dev/urandom
 * other           /dev/urandom with cached fd
 *
 * The /dev/urandom, getrandom and getentropy code is derived from Python's
 * Python/random.c, written by Antoine Pitrou and Victor Stinner.
 *
 * Copyright 2001-2016 Python Software Foundation; All Rights Reserved.
 */

static const char *Cryptography_osrandom_engine_id = "osrandom";

/****************************************************************************
 * Windows
 */
#if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_CRYPTGENRANDOM
static const char *Cryptography_osrandom_engine_name = "osrandom_engine CryptGenRandom()";
static HCRYPTPROV hCryptProv = 0;

static int osrandom_init(ENGINE *e) {
    if (hCryptProv != 0) {
        return 1;
    }
    if (CryptAcquireContext(&hCryptProv, NULL, NULL,
                            PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        return 1;
    } else {
        ERR_Cryptography_OSRandom_error(
            CRYPTOGRAPHY_OSRANDOM_F_INIT,
            CRYPTOGRAPHY_OSRANDOM_R_CRYPTACQUIRECONTEXT,
            __FILE__, __LINE__
        );
        return 0;
    }
}

static int osrandom_rand_bytes(unsigned char *buffer, int size) {
    if (hCryptProv == 0) {
        return 0;
    }

    if (!CryptGenRandom(hCryptProv, (DWORD)size, buffer)) {
        ERR_Cryptography_OSRandom_error(
            CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
            CRYPTOGRAPHY_OSRANDOM_R_CRYPTGENRANDOM,
            __FILE__, __LINE__
        );
        return 0;
    }
    return 1;
}

static int osrandom_finish(ENGINE *e) {
    if (CryptReleaseContext(hCryptProv, 0)) {
        hCryptProv = 0;
        return 1;
    } else {
        ERR_Cryptography_OSRandom_error(
            CRYPTOGRAPHY_OSRANDOM_F_FINISH,
            CRYPTOGRAPHY_OSRANDOM_R_CRYPTRELEASECONTEXT,
            __FILE__, __LINE__
        );
        return 0;
    }
}

static int osrandom_rand_status(void) {
    return hCryptProv != 0;
}

static const char *osurandom_get_implementation(void) {
    return "CryptGenRandom";
}

#endif /* CRYPTOGRAPHY_OSRANDOM_ENGINE_CRYPTGENRANDOM */

/****************************************************************************
 * BSD getentropy
 */
#if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY
static const char *Cryptography_osrandom_engine_name = "osrandom_engine getentropy()";

static int osrandom_init(ENGINE *e) {
    return 1;
}

static int osrandom_rand_bytes(unsigned char *buffer, int size) {
    int len, res;
    while (size > 0) {
        /* OpenBSD and macOS restrict maximum buffer size to 256. */
        len = size > 256 ? 256 : size;
        res = getentropy(buffer, len);
        if (res < 0) {
            ERR_Cryptography_OSRandom_error(
                CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
                CRYPTOGRAPHY_OSRANDOM_R_GETENTROPY_FAILED,
                __FILE__, __LINE__
            );
            return 0;
        }
        buffer += len;
        size -= len;
    }
    return 1;
}

static int osrandom_finish(ENGINE *e) {
    return 1;
}

static int osrandom_rand_status(void) {
    return 1;
}

static const char *osurandom_get_implementation(void) {
    return "getentropy";
}
#endif /* CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY */

/****************************************************************************
 * /dev/urandom helpers for all non-BSD Unix platforms
 */
#ifdef CRYPTOGRAPHY_OSRANDOM_NEEDS_DEV_URANDOM

static struct {
    int fd;
    dev_t st_dev;
    ino_t st_ino;
} urandom_cache = { -1 };

/* return -1 on error */
static int dev_urandom_fd(void) {
    int fd, n, flags;
    struct stat st;

    /* Check that fd still points to the correct device */
    if (urandom_cache.fd >= 0) {
        if (fstat(urandom_cache.fd, &st)
                || st.st_dev != urandom_cache.st_dev
                || st.st_ino != urandom_cache.st_ino) {
            /* Somebody replaced our FD. Invalidate our cache but don't
             * close the fd. */
            urandom_cache.fd = -1;
        }
    }
    if (urandom_cache.fd < 0) {
        fd = open("/dev/urandom", O_RDONLY);
        if (fd < 0) {
            goto error;
        }
        if (fstat(fd, &st)) {
            goto error;
        }
        /* set CLOEXEC flag */
        flags = fcntl(fd, F_GETFD);
        if (flags == -1) {
            goto error;
        } else if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1) {
            goto error;
        }
        /* Another thread initialized the fd */
        if (urandom_cache.fd >= 0) {
            do {
                n = close(fd);
            } while (n < 0 && errno == EINTR);
            return urandom_cache.fd;
        }
        urandom_cache.st_dev = st.st_dev;
        urandom_cache.st_ino = st.st_ino;
        urandom_cache.fd = fd;
    }
    return urandom_cache.fd;

  error:
    if (fd != -1) {
        do {
            n = close(fd);
        } while (n < 0 && errno == EINTR);
    }
    ERR_Cryptography_OSRandom_error(
        CRYPTOGRAPHY_OSRANDOM_F_DEV_URANDOM_FD,
        CRYPTOGRAPHY_OSRANDOM_R_DEV_URANDOM_OPEN_FAILED,
        __FILE__, __LINE__
    );
    return -1;
}

static int dev_urandom_read(unsigned char *buffer, int size) {
    int fd;
    ssize_t n;

    fd = dev_urandom_fd();
    if (fd < 0) {
        return 0;
    }

    while (size > 0) {
        do {
            n = read(fd, buffer, (size_t)size);
        } while (n < 0 && errno == EINTR);

        if (n <= 0) {
            ERR_Cryptography_OSRandom_error(
                CRYPTOGRAPHY_OSRANDOM_F_DEV_URANDOM_READ,
                CRYPTOGRAPHY_OSRANDOM_R_DEV_URANDOM_READ_FAILED,
                __FILE__, __LINE__
            );
            return 0;
        }
        buffer += n;
        size -= n;
    }
    return 1;
}

static void dev_urandom_close(void) {
    if (urandom_cache.fd >= 0) {
        int fd, n;
        struct stat st;

        if (fstat(urandom_cache.fd, &st)
                && st.st_dev == urandom_cache.st_dev
                && st.st_ino == urandom_cache.st_ino) {
            fd = urandom_cache.fd;
            urandom_cache.fd = -1;
            do {
                n = close(fd);
            } while (n < 0 && errno == EINTR);
        }
    }
}
#endif /* CRYPTOGRAPHY_OSRANDOM_NEEDS_DEV_URANDOM */

/****************************************************************************
 * Linux getrandom engine with fallback to dev_urandom
 */

#if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_GETRANDOM
static const char *Cryptography_osrandom_engine_name = "osrandom_engine getrandom()";

static int getrandom_works = CRYPTOGRAPHY_OSRANDOM_GETRANDOM_NOT_INIT;

static int osrandom_init(ENGINE *e) {
    /* We try to detect working getrandom until we succeed. */
    if (getrandom_works != CRYPTOGRAPHY_OSRANDOM_GETRANDOM_WORKS) {
        long n;
        char dest[1];
        n = syscall(SYS_getrandom, dest, sizeof(dest), GRND_NONBLOCK);
        if (n == sizeof(dest)) {
            getrandom_works = CRYPTOGRAPHY_OSRANDOM_GETRANDOM_WORKS;
        } else {
            int e = errno;
            switch(e) {
            case ENOSYS:
                /* Fallback: Kernel does not support the syscall. */
                getrandom_works = CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK;
                break;
            case EPERM:
                /* Fallback: seccomp prevents syscall */
                getrandom_works = CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK;
                break;
            case EAGAIN:
               /* Failure: Kernel CRPNG has not been seeded yet */
                ERR_Cryptography_OSRandom_error(
                    CRYPTOGRAPHY_OSRANDOM_F_INIT,
                    CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED_EAGAIN,
                    __FILE__, __LINE__
                );
                getrandom_works = CRYPTOGRAPHY_OSRANDOM_GETRANDOM_INIT_FAILED;
                break;
            default:
                /* EINTR cannot occur for buflen < 256. */
                ERR_Cryptography_OSRandom_error(
                    CRYPTOGRAPHY_OSRANDOM_F_INIT,
                    CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED_UNEXPECTED,
                    "errno", e
                );
                getrandom_works = CRYPTOGRAPHY_OSRANDOM_GETRANDOM_INIT_FAILED;
                break;
            }
        }
    }

    /* fallback to dev urandom */
    if (getrandom_works == CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK) {
        int fd = dev_urandom_fd();
        if (fd < 0) {
            return 0;
        }
    }
    return 1;
}

static int osrandom_rand_bytes(unsigned char *buffer, int size) {
    long n;

    switch(getrandom_works) {
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_INIT_FAILED:
        ERR_Cryptography_OSRandom_error(
            CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
            CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED,
            __FILE__, __LINE__
        );
        return 0;
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_NOT_INIT:
        ERR_Cryptography_OSRandom_error(
            CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
            CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_NOT_INIT,
            __FILE__, __LINE__
        );
        return 0;
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK:
        return dev_urandom_read(buffer, size);
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_WORKS:
        while (size > 0) {
            do {
                n = syscall(SYS_getrandom, buffer, size, GRND_NONBLOCK);
            } while (n < 0 && errno == EINTR);

            if (n <= 0) {
                ERR_Cryptography_OSRandom_error(
                    CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
                    CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_FAILED,
                    __FILE__, __LINE__
                );
                return 0;
            }
            buffer += n;
            size -= n;
        }
        return 1;
    }
    __builtin_unreachable();
}

static int osrandom_finish(ENGINE *e) {
    dev_urandom_close();
    return 1;
}

static int osrandom_rand_status(void) {
    switch(getrandom_works) {
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_INIT_FAILED:
        return 0;
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_NOT_INIT:
        return 0;
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK:
        return urandom_cache.fd >= 0;
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_WORKS:
        return 1;
    }
    __builtin_unreachable();
}

static const char *osurandom_get_implementation(void) {
    switch(getrandom_works) {
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_INIT_FAILED:
        return "<failed>";
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_NOT_INIT:
        return "<not initialized>";
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_FALLBACK:
        return "/dev/urandom";
    case CRYPTOGRAPHY_OSRANDOM_GETRANDOM_WORKS:
        return "getrandom";
    }
    __builtin_unreachable();
}
#endif /* CRYPTOGRAPHY_OSRANDOM_ENGINE_GETRANDOM */

/****************************************************************************
 * dev_urandom engine for all remaining platforms
 */

#if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM
static const char *Cryptography_osrandom_engine_name = "osrandom_engine /dev/urandom";

static int osrandom_init(ENGINE *e) {
    int fd = dev_urandom_fd();
    if (fd < 0) {
        return 0;
    }
    return 1;
}

static int osrandom_rand_bytes(unsigned char *buffer, int size) {
    return dev_urandom_read(buffer, size);
}

static int osrandom_finish(ENGINE *e) {
    dev_urandom_close();
    return 1;
}

static int osrandom_rand_status(void) {
    return urandom_cache.fd >= 0;
}

static const char *osurandom_get_implementation(void) {
    return "/dev/urandom";
}
#endif /* CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM */

/****************************************************************************
 * ENGINE boiler plate
 */

/* This replicates the behavior of the OpenSSL FIPS RNG, which returns a
   -1 in the event that there is an error when calling RAND_pseudo_bytes. */
static int osrandom_pseudo_rand_bytes(unsigned char *buffer, int size) {
    int res = osrandom_rand_bytes(buffer, size);
    if (res == 0) {
        return -1;
    } else {
        return res;
    }
}

static RAND_METHOD osrandom_rand = {
    NULL,
    osrandom_rand_bytes,
    NULL,
    NULL,
    osrandom_pseudo_rand_bytes,
    osrandom_rand_status,
};

static const ENGINE_CMD_DEFN osrandom_cmd_defns[] = {
    {CRYPTOGRAPHY_OSRANDOM_GET_IMPLEMENTATION,
     "get_implementation",
     "Get CPRNG implementation.",
     ENGINE_CMD_FLAG_NO_INPUT},
     {0, NULL, NULL, 0}
};

static int osrandom_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) {
    const char *name;
    size_t len;

    switch (cmd) {
    case CRYPTOGRAPHY_OSRANDOM_GET_IMPLEMENTATION:
        /* i: buffer size, p: char* buffer */
        name = osurandom_get_implementation();
        len = strlen(name);
        if ((p == NULL) && (i == 0)) {
            /* return required buffer len */
            return len;
        }
        if ((p == NULL) || i < 0 || ((size_t)i <= len)) {
            /* no buffer or buffer too small */
            ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_INVALID_ARGUMENT);
            return 0;
        }
        strncpy((char *)p, name, len);
        return len;
    default:
        ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);
        return 0;
    }
}

/* error reporting */
#define ERR_FUNC(func) ERR_PACK(0, func, 0)
#define ERR_REASON(reason) ERR_PACK(0, 0, reason)

static ERR_STRING_DATA CRYPTOGRAPHY_OSRANDOM_lib_name[] = {
    {0, "osrandom_engine"},
    {0, NULL}
};

static ERR_STRING_DATA CRYPTOGRAPHY_OSRANDOM_str_funcs[] = {
    {ERR_FUNC(CRYPTOGRAPHY_OSRANDOM_F_INIT),
     "osrandom_init"},
    {ERR_FUNC(CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES),
     "osrandom_rand_bytes"},
    {ERR_FUNC(CRYPTOGRAPHY_OSRANDOM_F_FINISH),
     "osrandom_finish"},
    {ERR_FUNC(CRYPTOGRAPHY_OSRANDOM_F_DEV_URANDOM_FD),
     "dev_urandom_fd"},
    {ERR_FUNC(CRYPTOGRAPHY_OSRANDOM_F_DEV_URANDOM_READ),
     "dev_urandom_read"},
    {0, NULL}
};

static ERR_STRING_DATA CRYPTOGRAPHY_OSRANDOM_str_reasons[] = {
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_CRYPTACQUIRECONTEXT),
     "CryptAcquireContext() failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_CRYPTGENRANDOM),
     "CryptGenRandom() failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_CRYPTRELEASECONTEXT),
     "CryptReleaseContext() failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_GETENTROPY_FAILED),
     "getentropy() failed"},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_DEV_URANDOM_OPEN_FAILED),
     "open('/dev/urandom') failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_DEV_URANDOM_READ_FAILED),
     "Reading from /dev/urandom fd failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED),
     "getrandom() initialization failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED_EAGAIN),
     "getrandom() initialization failed with EAGAIN. Most likely Kernel "
     "CPRNG is not seeded yet."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_INIT_FAILED_UNEXPECTED),
     "getrandom() initialization failed with unexpected errno."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_FAILED),
     "getrandom() syscall failed."},
    {ERR_REASON(CRYPTOGRAPHY_OSRANDOM_R_GETRANDOM_NOT_INIT),
     "getrandom() engine was not properly initialized."},
    {0, NULL}
};

static int Cryptography_OSRandom_lib_error_code = 0;

static void ERR_load_Cryptography_OSRandom_strings(void)
{
    if (Cryptography_OSRandom_lib_error_code == 0) {
        Cryptography_OSRandom_lib_error_code = ERR_get_next_error_library();
        ERR_load_strings(Cryptography_OSRandom_lib_error_code,
                         CRYPTOGRAPHY_OSRANDOM_lib_name);
        ERR_load_strings(Cryptography_OSRandom_lib_error_code,
                         CRYPTOGRAPHY_OSRANDOM_str_funcs);
        ERR_load_strings(Cryptography_OSRandom_lib_error_code,
                         CRYPTOGRAPHY_OSRANDOM_str_reasons);
    }
}

static void ERR_Cryptography_OSRandom_error(int function, int reason,
                                            char *file, int line)
{
    ERR_PUT_error(Cryptography_OSRandom_lib_error_code, function, reason,
                  file, line);
}

/* Returns 1 if successfully added, 2 if engine has previously been added,
   and 0 for error. */
int Cryptography_add_osrandom_engine(void) {
    ENGINE *e;

    ERR_load_Cryptography_OSRandom_strings();

    e = ENGINE_by_id(Cryptography_osrandom_engine_id);
    if (e != NULL) {
        ENGINE_free(e);
        return 2;
    } else {
        ERR_clear_error();
    }

    e = ENGINE_new();
    if (e == NULL) {
        return 0;
    }
    if (!ENGINE_set_id(e, Cryptography_osrandom_engine_id) ||
            !ENGINE_set_name(e, Cryptography_osrandom_engine_name) ||
            !ENGINE_set_RAND(e, &osrandom_rand) ||
            !ENGINE_set_init_function(e, osrandom_init) ||
            !ENGINE_set_finish_function(e, osrandom_finish) ||
            !ENGINE_set_cmd_defns(e, osrandom_cmd_defns) ||
            !ENGINE_set_ctrl_function(e, osrandom_ctrl)) {
        ENGINE_free(e);
        return 0;
    }
    if (!ENGINE_add(e)) {
        ENGINE_free(e);
        return 0;
    }
    if (!ENGINE_free(e)) {
        return 0;
    }

    return 1;
}


#if !defined(EVP_PKEY_DHX) || EVP_PKEY_DHX == -1
int (*PEM_write_bio_DHxparams)(BIO *, DH *) = NULL;
#endif




#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
static const long Cryptography_HAS_EGD = 0;
int (*RAND_egd)(const char *) = NULL;
int (*RAND_egd_bytes)(const char *, int) = NULL;
int (*RAND_query_egd_bytes)(const char *, unsigned char *, int) = NULL;
#else
static const long Cryptography_HAS_EGD = 1;
#endif


static const long Cryptography_HAS_PSS_PADDING = 1;

#if defined(EVP_PKEY_CTX_set_rsa_oaep_md)
static const long Cryptography_HAS_RSA_OAEP_MD = 1;
#else
static const long Cryptography_HAS_RSA_OAEP_MD = 0;
int (*EVP_PKEY_CTX_set_rsa_oaep_md)(EVP_PKEY_CTX *, EVP_MD *) = NULL;
#endif

/* These functions were added in OpenSSL 1.1.0-pre5 (beta2) */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE5
int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)
{
    /* If the fields n and e in r are NULL, the corresponding input
     * parameters MUST be non-NULL for n and e.  d may be
     * left NULL (in case only the public key is used).
     */
    if ((r->n == NULL && n == NULL)
        || (r->e == NULL && e == NULL))
        return 0;

    if (n != NULL) {
        BN_free(r->n);
        r->n = n;
    }
    if (e != NULL) {
        BN_free(r->e);
        r->e = e;
    }
    if (d != NULL) {
        BN_free(r->d);
        r->d = d;
    }

    return 1;
}

int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)
{
    /* If the fields p and q in r are NULL, the corresponding input
     * parameters MUST be non-NULL.
     */
    if ((r->p == NULL && p == NULL)
        || (r->q == NULL && q == NULL))
        return 0;

    if (p != NULL) {
        BN_free(r->p);
        r->p = p;
    }
    if (q != NULL) {
        BN_free(r->q);
        r->q = q;
    }

    return 1;
}

int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp)
{
    /* If the fields dmp1, dmq1 and iqmp in r are NULL, the corresponding input
     * parameters MUST be non-NULL.
     */
    if ((r->dmp1 == NULL && dmp1 == NULL)
        || (r->dmq1 == NULL && dmq1 == NULL)
        || (r->iqmp == NULL && iqmp == NULL))
        return 0;

    if (dmp1 != NULL) {
        BN_free(r->dmp1);
        r->dmp1 = dmp1;
    }
    if (dmq1 != NULL) {
        BN_free(r->dmq1);
        r->dmq1 = dmq1;
    }
    if (iqmp != NULL) {
        BN_free(r->iqmp);
        r->iqmp = iqmp;
    }

    return 1;
}

void RSA_get0_key(const RSA *r,
                  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
{
    if (n != NULL)
        *n = r->n;
    if (e != NULL)
        *e = r->e;
    if (d != NULL)
        *d = r->d;
}

void RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q)
{
    if (p != NULL)
        *p = r->p;
    if (q != NULL)
        *q = r->q;
}

void RSA_get0_crt_params(const RSA *r,
                         const BIGNUM **dmp1, const BIGNUM **dmq1,
                         const BIGNUM **iqmp)
{
    if (dmp1 != NULL)
        *dmp1 = r->dmp1;
    if (dmq1 != NULL)
        *dmq1 = r->dmq1;
    if (iqmp != NULL)
        *iqmp = r->iqmp;
}
#endif


/* Added in 1.0.2 but we need it in all versions now due to the great
   opaquing. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_102
/* from ssl/ssl_lib.c */
const SSL_METHOD *SSL_CTX_get_ssl_method(SSL_CTX *ctx) {
    return ctx->method;
}
#endif

/* Added in 1.1.0 in the great opaquing, but we need to define it for older
   OpenSSLs. Such is our burden. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
/* from ssl/ssl_lib.c */
size_t SSL_get_client_random(const SSL *ssl, unsigned char *out, size_t outlen)
{
    if (outlen == 0)
        return sizeof(ssl->s3->client_random);
    if (outlen > sizeof(ssl->s3->client_random))
        outlen = sizeof(ssl->s3->client_random);
    memcpy(out, ssl->s3->client_random, outlen);
    return outlen;
}
/* Added in 1.1.0 as well */
/* from ssl/ssl_lib.c */
size_t SSL_get_server_random(const SSL *ssl, unsigned char *out, size_t outlen)
{
    if (outlen == 0)
        return sizeof(ssl->s3->server_random);
    if (outlen > sizeof(ssl->s3->server_random))
        outlen = sizeof(ssl->s3->server_random);
    memcpy(out, ssl->s3->server_random, outlen);
    return outlen;
}
/* Added in 1.1.0 as well */
/* from ssl/ssl_lib.c */
size_t SSL_SESSION_get_master_key(const SSL_SESSION *session,
                               unsigned char *out, size_t outlen)
{
    if (session->master_key_length < 0) {
        /* Should never happen */
        return 0;
    }
    if (outlen == 0)
        return session->master_key_length;
    if (outlen > (size_t)session->master_key_length)
        outlen = session->master_key_length;
    memcpy(out, session->master_key, outlen);
    return outlen;
}
#endif

static const long Cryptography_HAS_SECURE_RENEGOTIATION = 1;

/* Cryptography now compiles out all SSLv2 bindings. This exists to allow
 * clients that use it to check for SSLv2 support to keep functioning as
 * expected.
 */
static const long Cryptography_HAS_SSL2 = 0;

#ifdef OPENSSL_NO_SSL3_METHOD
static const long Cryptography_HAS_SSL3_METHOD = 0;
SSL_METHOD* (*SSLv3_method)(void) = NULL;
SSL_METHOD* (*SSLv3_client_method)(void) = NULL;
SSL_METHOD* (*SSLv3_server_method)(void) = NULL;
#else
static const long Cryptography_HAS_SSL3_METHOD = 1;
#endif

static const long Cryptography_HAS_TLSEXT_HOSTNAME = 1;
static const long Cryptography_HAS_TLSEXT_STATUS_REQ_CB = 1;
static const long Cryptography_HAS_STATUS_REQ_OCSP_RESP = 1;
static const long Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE = 1;
static const long Cryptography_HAS_RELEASE_BUFFERS = 1;
static const long Cryptography_HAS_OP_NO_COMPRESSION = 1;
static const long Cryptography_HAS_TLSv1_1 = 1;
static const long Cryptography_HAS_TLSv1_2 = 1;
static const long Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING = 1;
static const long Cryptography_HAS_SSL_OP_NO_TICKET = 1;
static const long Cryptography_HAS_SSL_SET_SSL_CTX = 1;
static const long Cryptography_HAS_NEXTPROTONEG = 1;

/* ALPN was added in OpenSSL 1.0.2. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_102 && !CRYPTOGRAPHY_IS_LIBRESSL
int (*SSL_CTX_set_alpn_protos)(SSL_CTX *,
                               const unsigned char *,
                               unsigned) = NULL;
int (*SSL_set_alpn_protos)(SSL *, const unsigned char *, unsigned) = NULL;
void (*SSL_CTX_set_alpn_select_cb)(SSL_CTX *,
                                   int (*) (SSL *,
                                            const unsigned char **,
                                            unsigned char *,
                                            const unsigned char *,
                                            unsigned int,
                                            void *),
                                   void *) = NULL;
void (*SSL_get0_alpn_selected)(const SSL *,
                               const unsigned char **,
                               unsigned *) = NULL;
static const long Cryptography_HAS_ALPN = 0;
#else
static const long Cryptography_HAS_ALPN = 1;
#endif

/* SSL_CTX_set_cert_cb was added in OpenSSL 1.0.2. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_102
void (*SSL_CTX_set_cert_cb)(SSL_CTX *, int (*)(SSL *, void *), void *) = NULL;
void (*SSL_set_cert_cb)(SSL *, int (*)(SSL *, void *), void *) = NULL;
static const long Cryptography_HAS_SET_CERT_CB = 0;
#else
static const long Cryptography_HAS_SET_CERT_CB = 1;
#endif


/* In OpenSSL 1.0.2i+ the handling of COMP_METHOD when OPENSSL_NO_COMP was
   changed and we no longer need to typedef void */
#if (defined(OPENSSL_NO_COMP) && CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I) ||     CRYPTOGRAPHY_IS_LIBRESSL
static const long Cryptography_HAS_COMPRESSION = 0;
typedef void COMP_METHOD;
#else
static const long Cryptography_HAS_COMPRESSION = 1;
#endif

#if defined(SSL_CTRL_GET_SERVER_TMP_KEY)
static const long Cryptography_HAS_GET_SERVER_TMP_KEY = 1;
#else
static const long Cryptography_HAS_GET_SERVER_TMP_KEY = 0;
long (*SSL_get_server_tmp_key)(SSL *, EVP_PKEY **) = NULL;
#endif

static const long Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE = 1;

static const long Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS = 1;

/* in OpenSSL 1.1.0 the SSL_ST values were renamed to TLS_ST and several were
   removed */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
static const long Cryptography_HAS_SSL_ST = 1;
#else
static const long Cryptography_HAS_SSL_ST = 0;
static const long SSL_ST_BEFORE = 0;
static const long SSL_ST_OK = 0;
static const long SSL_ST_INIT = 0;
static const long SSL_ST_RENEGOTIATE = 0;
#endif
#if CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
static const long Cryptography_HAS_TLS_ST = 1;
#else
static const long Cryptography_HAS_TLS_ST = 0;
static const long TLS_ST_BEFORE = 0;
static const long TLS_ST_OK = 0;
#endif

#ifndef OPENSSL_NO_DTLS
static const long Cryptography_HAS_DTLS = 1;
/* Wrap DTLSv1_get_timeout to avoid cffi to handle a 'struct timeval'. */
long Cryptography_DTLSv1_get_timeout(SSL *ssl, time_t *ptv_sec,
                                     long *ptv_usec) {
    struct timeval tv = { 0 };
    int r = DTLSv1_get_timeout(ssl, &tv);

    if (r == 1) {
        if (ptv_sec) {
            *ptv_sec = tv.tv_sec;
        }

        if (ptv_usec) {
            *ptv_usec = tv.tv_usec;
        }
    }

    return r;
}
#else
static const long Cryptography_HAS_DTLS = 0;
long (*DTLSv1_get_timeout_wrapped)(SSL *, time_t *, long int *) = NULL;
long (*DTLSv1_handle_timeout)(SSL *) = NULL;
#endif


/* Added in 1.0.2 beta but we need it in all versions now due to the great
   opaquing. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_102
/* from x509/x_x509.c version 1.0.2 */
void X509_get0_signature(ASN1_BIT_STRING **psig, X509_ALGOR **palg,
                         const X509 *x)
{
    if (psig)
        *psig = x->signature;
    if (palg)
        *palg = x->sig_alg;
}

int X509_get_signature_nid(const X509 *x)
{
    return OBJ_obj2nid(x->sig_alg->algorithm);
}

#endif

/* Added in 1.0.2beta3 but we need it in all versions now due to the great
   opaquing. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_102BETA3
/* from x509/x_x509.c */
int i2d_re_X509_tbs(X509 *x, unsigned char **pp)
{
    /* in 1.0.2+ this function also sets x->cert_info->enc.modified = 1
       but older OpenSSLs don't have the enc ASN1_ENCODING member in the
       X509 struct.  Setting modified to 1 marks the encoding
       (x->cert_info->enc.enc) as invalid, but since the entire struct isn't
       present we don't care. */
    return i2d_X509_CINF(x->cert_info, pp);
}
#endif

/* X509_REVOKED_dup only exists on 1.0.2+. It is implemented using
   IMPLEMENT_ASN1_DUP_FUNCTION. The below is the equivalent so we have
   it available on all OpenSSLs. */
X509_REVOKED *Cryptography_X509_REVOKED_dup(X509_REVOKED *rev) {
    return ASN1_item_dup(ASN1_ITEM_rptr(X509_REVOKED), rev);
}

/* Added in 1.1.0 but we need it in all versions now due to the great
   opaquing. */
#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110

const X509_ALGOR *X509_get0_tbs_sigalg(const X509 *x)
{
    return x->cert_info->signature;
}

/* from x509/x509_req.c */
void X509_REQ_get0_signature(const X509_REQ *req, const ASN1_BIT_STRING **psig,
                             const X509_ALGOR **palg)
{
    if (psig != NULL)
        *psig = req->signature;
    if (palg != NULL)
        *palg = req->sig_alg;
}
int i2d_re_X509_REQ_tbs(X509_REQ *req, unsigned char **pp)
{
    req->req_info->enc.modified = 1;
    return i2d_X509_REQ_INFO(req->req_info, pp);
}
int i2d_re_X509_CRL_tbs(X509_CRL *crl, unsigned char **pp) {
    crl->crl->enc.modified = 1;
    return i2d_X509_CRL_INFO(crl->crl, pp);
}

void X509_CRL_get0_signature(const X509_CRL *crl, const ASN1_BIT_STRING **psig,
                             const X509_ALGOR **palg)
{
    if (psig != NULL)
        *psig = crl->signature;
    if (palg != NULL)
        *palg = crl->sig_alg;
}
const ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *x)
{
    return x->revocationDate;
}
const ASN1_INTEGER *X509_REVOKED_get0_serialNumber(const X509_REVOKED *x)
{
    return x->serialNumber;
}
#endif


#if CRYPTOGRAPHY_OPENSSL_110_OR_GREATER
int Cryptography_X509_NAME_ENTRY_set(X509_NAME_ENTRY *ne) {
    return X509_NAME_ENTRY_set(ne);
}
#else
int Cryptography_X509_NAME_ENTRY_set(X509_NAME_ENTRY *ne) {
    return ne->set;
}
#endif




/* OpenSSL 1.0.2beta2+ verification parameters and error codes */
#if CRYPTOGRAPHY_OPENSSL_102BETA2_OR_GREATER
static const long Cryptography_HAS_102_VERIFICATION_ERROR_CODES = 1;
static const long Cryptography_HAS_102_VERIFICATION_PARAMS = 1;
#else
static const long Cryptography_HAS_102_VERIFICATION_ERROR_CODES = 0;
static const long Cryptography_HAS_102_VERIFICATION_PARAMS = 0;

static const long X509_V_ERR_SUITE_B_INVALID_VERSION = 0;
static const long X509_V_ERR_SUITE_B_INVALID_ALGORITHM = 0;
static const long X509_V_ERR_SUITE_B_INVALID_CURVE = 0;
static const long X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = 0;
static const long X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED = 0;
static const long X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = 0;
/* These 3 defines are unavailable in LibreSSL 2.5.x, but may be added
   in the future... */
#ifndef X509_V_ERR_HOSTNAME_MISMATCH
static const long X509_V_ERR_HOSTNAME_MISMATCH = 0;
#endif
#ifndef X509_V_ERR_EMAIL_MISMATCH
static const long X509_V_ERR_EMAIL_MISMATCH = 0;
#endif
#ifndef X509_V_ERR_IP_ADDRESS_MISMATCH
static const long X509_V_ERR_IP_ADDRESS_MISMATCH = 0;
#endif

/* X509_V_FLAG_TRUSTED_FIRST is also new in 1.0.2+, but it is added separately
   below because it shows up in some earlier 3rd party OpenSSL packages. */
static const long X509_V_FLAG_SUITEB_128_LOS_ONLY = 0;
static const long X509_V_FLAG_SUITEB_192_LOS = 0;
static const long X509_V_FLAG_SUITEB_128_LOS = 0;

int (*X509_VERIFY_PARAM_set1_host)(X509_VERIFY_PARAM *, const char *,
                                   size_t) = NULL;
int (*X509_VERIFY_PARAM_set1_email)(X509_VERIFY_PARAM *, const char *,
                                    size_t) = NULL;
int (*X509_VERIFY_PARAM_set1_ip)(X509_VERIFY_PARAM *, const unsigned char *,
                                 size_t) = NULL;
int (*X509_VERIFY_PARAM_set1_ip_asc)(X509_VERIFY_PARAM *, const char *) = NULL;
void (*X509_VERIFY_PARAM_set_hostflags)(X509_VERIFY_PARAM *,
                                        unsigned int) = NULL;
#endif

/* OpenSSL 1.0.2+ or Solaris's backport */
#ifdef X509_V_FLAG_PARTIAL_CHAIN
static const long Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN = 1;
#else
static const long Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN = 0;
static const long X509_V_FLAG_PARTIAL_CHAIN = 0;
#endif

/* OpenSSL 1.0.2+, *or* Fedora 20's flavor of OpenSSL 1.0.1e... */
#ifdef X509_V_FLAG_TRUSTED_FIRST
static const long Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST = 1;
#else
static const long Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST = 0;
static const long X509_V_FLAG_TRUSTED_FIRST = 0;
#endif

#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE6
Cryptography_STACK_OF_X509_OBJECT *X509_STORE_get0_objects(X509_STORE *ctx) {
    return ctx->objs;
}
X509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *store) {
    return store->param;
}
int X509_OBJECT_get_type(const X509_OBJECT *x) {
    return x->type;
}
#endif

#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110PRE5
/* from x509/x509_vfy.c */
X509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx)
{
    return ctx->cert;
}

X509 *X509_OBJECT_get0_X509(X509_OBJECT *x) {
    return x->data.x509;
}
#endif

#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_110
static const long Cryptography_HAS_X509_STORE_CTX_GET_ISSUER = 0;
typedef void *X509_STORE_CTX_get_issuer_fn;
X509_STORE_CTX_get_issuer_fn (*X509_STORE_get_get_issuer)(X509_STORE *) = NULL;
void (*X509_STORE_set_get_issuer)(X509_STORE *,
                                  X509_STORE_CTX_get_issuer_fn) = NULL;
#else
static const long Cryptography_HAS_X509_STORE_CTX_GET_ISSUER = 1;
#endif



/* This code is derived from the locking code found in the Python _ssl module's
   locking callback for OpenSSL.

   Copyright 2001-2016 Python Software Foundation; All Rights Reserved.
*/

static unsigned int _ssl_locks_count = 0;
static PyThread_type_lock *_ssl_locks = NULL;

static void _ssl_thread_locking_function(int mode, int n, const char *file,
                                         int line) {
    /* this function is needed to perform locking on shared data
       structures. (Note that OpenSSL uses a number of global data
       structures that will be implicitly shared whenever multiple
       threads use OpenSSL.) Multi-threaded applications will
       crash at random if it is not set.

       locking_function() must be able to handle up to
       CRYPTO_num_locks() different mutex locks. It sets the n-th
       lock if mode & CRYPTO_LOCK, and releases it otherwise.

       file and line are the file number of the function setting the
       lock. They can be useful for debugging.
    */

    if ((_ssl_locks == NULL) ||
        (n < 0) || ((unsigned)n >= _ssl_locks_count)) {
        return;
    }

    if (mode & CRYPTO_LOCK) {
        PyThread_acquire_lock(_ssl_locks[n], 1);
    } else {
        PyThread_release_lock(_ssl_locks[n]);
    }
}

int _setup_ssl_threads(void) {
    unsigned int i;

    if (_ssl_locks == NULL) {
        _ssl_locks_count = CRYPTO_num_locks();
        _ssl_locks = PyMem_New(PyThread_type_lock, _ssl_locks_count);
        if (_ssl_locks == NULL) {
            PyErr_NoMemory();
            return 0;
        }
        memset(_ssl_locks, 0, sizeof(PyThread_type_lock) * _ssl_locks_count);
        for (i = 0;  i < _ssl_locks_count;  i++) {
            _ssl_locks[i] = PyThread_allocate_lock();
            if (_ssl_locks[i] == NULL) {
                unsigned int j;
                for (j = 0;  j < i;  j++) {
                    PyThread_free_lock(_ssl_locks[j]);
                }
                PyMem_Free(_ssl_locks);
                return 0;
            }
        }
        CRYPTO_set_locking_callback(_ssl_thread_locking_function);
    }
    return 1;
}

typedef struct {
    char *password;
    int length;
    int called;
    int error;
    int maxsize;
} CRYPTOGRAPHY_PASSWORD_DATA;

int Cryptography_pem_password_cb(char *buf, int size,
                                  int rwflag, void *userdata) {
    /* The password cb is only invoked if OpenSSL decides the private
       key is encrypted. So this path only occurs if it needs a password */
    CRYPTOGRAPHY_PASSWORD_DATA *st = (CRYPTOGRAPHY_PASSWORD_DATA *)userdata;
    st->called += 1;
    st->maxsize = size;
    if (st->length == 0) {
        st->error = -1;
        return 0;
    } else if (st->length < size) {
        memcpy(buf, st->password, st->length);
        return st->length;
    } else {
        st->error = -2;
        return 0;
    }
}


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1394), // ACCESS_DESCRIPTION *()(Cryptography_STACK_OF_ACCESS_DESCRIPTION *, int)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 3671), // Cryptography_STACK_OF_ACCESS_DESCRIPTION *
/*  2 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/*  3 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  4 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1394), // ACCESS_DESCRIPTION *()(void)
/*  5 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  6 */ _CFFI_OP(_CFFI_OP_FUNCTION, 980), // ASN1_ENUMERATED *()(void)
/*  7 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  8 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // ASN1_GENERALIZEDTIME *()(ASN1_GENERALIZEDTIME *, time_t)
/*  9 */ _CFFI_OP(_CFFI_OP_POINTER, 3635), // ASN1_GENERALIZEDTIME *
/* 10 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, _cffi_prim_int(sizeof(time_t), (
           ((time_t)-1) | 0 /* check that time_t is an integer type */
         ) <= 0)), // time_t
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 12 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // ASN1_GENERALIZEDTIME *()(ASN1_OCTET_STRING *, ASN1_GENERALIZEDTIME * *)
/* 13 */ _CFFI_OP(_CFFI_OP_POINTER, 3642), // ASN1_OCTET_STRING *
/* 14 */ _CFFI_OP(_CFFI_OP_POINTER, 9), // ASN1_GENERALIZEDTIME * *
/* 15 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 16 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // ASN1_INTEGER *()(ASN1_INTEGER *)
/* 17 */ _CFFI_OP(_CFFI_OP_POINTER, 3637), // ASN1_INTEGER *
/* 18 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 19 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // ASN1_INTEGER *()(BIGNUM *, ASN1_INTEGER *)
/* 20 */ _CFFI_OP(_CFFI_OP_POINTER, 3649), // BIGNUM *
/* 21 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 22 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 23 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // ASN1_INTEGER *()(Cryptography_STACK_OF_ASN1_INTEGER *, int)
/* 24 */ _CFFI_OP(_CFFI_OP_POINTER, 3672), // Cryptography_STACK_OF_ASN1_INTEGER *
/* 25 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 27 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // ASN1_INTEGER *()(X509 *)
/* 28 */ _CFFI_OP(_CFFI_OP_POINTER, 3756), // X509 *
/* 29 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 30 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // ASN1_INTEGER *()(void)
/* 31 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 32 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3636), // ASN1_INTEGER const *()(X509_REVOKED const *)
/* 33 */ _CFFI_OP(_CFFI_OP_POINTER, 3774), // X509_REVOKED const *
/* 34 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 35 */ _CFFI_OP(_CFFI_OP_FUNCTION, 114), // ASN1_ITEM const *()(ASN1_ITEM_EXP *)
/* 36 */ _CFFI_OP(_CFFI_OP_POINTER, 3639), // ASN1_ITEM_EXP *
/* 37 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 38 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(ASN1_OBJECT * *, unsigned char const * *, long)
/* 39 */ _CFFI_OP(_CFFI_OP_POINTER, 811), // ASN1_OBJECT * *
/* 40 */ _CFFI_OP(_CFFI_OP_POINTER, 148), // unsigned char const * *
/* 41 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9), // long
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 43 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(ASN1_OBJECT const *)
/* 44 */ _CFFI_OP(_CFFI_OP_POINTER, 3640), // ASN1_OBJECT const *
/* 45 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 46 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(Cryptography_STACK_OF_ASN1_OBJECT *, int)
/* 47 */ _CFFI_OP(_CFFI_OP_POINTER, 3673), // Cryptography_STACK_OF_ASN1_OBJECT *
/* 48 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 49 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 50 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(X509_EXTENSION *)
/* 51 */ _CFFI_OP(_CFFI_OP_POINTER, 3767), // X509_EXTENSION *
/* 52 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 53 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(X509_NAME_ENTRY *)
/* 54 */ _CFFI_OP(_CFFI_OP_POINTER, 3770), // X509_NAME_ENTRY *
/* 55 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 56 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(char const *, int)
/* 57 */ _CFFI_OP(_CFFI_OP_POINTER, 3779), // char const *
/* 58 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 59 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 60 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(int)
/* 61 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 62 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 63 */ _CFFI_OP(_CFFI_OP_FUNCTION, 811), // ASN1_OBJECT *()(void)
/* 64 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 65 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(ASN1_OCTET_STRING *)
/* 66 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 67 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 68 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(ASN1_OCTET_STRING *, long)
/* 69 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 70 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 71 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 72 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(ASN1_OCTET_STRING *, time_t)
/* 73 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 74 */ _CFFI_OP(_CFFI_OP_NOOP, 10),
/* 75 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 76 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(X509 *)
/* 77 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 78 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 79 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(X509_CRL *)
/* 80 */ _CFFI_OP(_CFFI_OP_POINTER, 3765), // X509_CRL *
/* 81 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 82 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(X509_EXTENSION *)
/* 83 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 84 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 85 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(X509_NAME_ENTRY *)
/* 86 */ _CFFI_OP(_CFFI_OP_NOOP, 54),
/* 87 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 88 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(int)
/* 89 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 90 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 91 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(void *)
/* 92 */ _CFFI_OP(_CFFI_OP_POINTER, 3795), // void *
/* 93 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 94 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // ASN1_OCTET_STRING *()(void)
/* 95 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 96 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3641), // ASN1_OCTET_STRING const *()(X509_REVOKED const *)
/* 97 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 98 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 99 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1056), // ASN1_TYPE *()(ASN1_TYPE * *, unsigned char const * *, long)
/* 100 */ _CFFI_OP(_CFFI_OP_POINTER, 1056), // ASN1_TYPE * *
/* 101 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 102 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 103 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 104 */ _CFFI_OP(_CFFI_OP_FUNCTION, 105), // ASN1_UTCTIME *()(ASN1_UTCTIME *, time_t)
/* 105 */ _CFFI_OP(_CFFI_OP_POINTER, 3644), // ASN1_UTCTIME *
/* 106 */ _CFFI_OP(_CFFI_OP_NOOP, 10),
/* 107 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 108 */ _CFFI_OP(_CFFI_OP_FUNCTION, 105), // ASN1_UTCTIME *()(void)
/* 109 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 110 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3645), // ASN1_VALUE *()(ASN1_VALUE * *, unsigned char const * *, long, ASN1_ITEM const *)
/* 111 */ _CFFI_OP(_CFFI_OP_POINTER, 3645), // ASN1_VALUE * *
/* 112 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 113 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 114 */ _CFFI_OP(_CFFI_OP_POINTER, 3638), // ASN1_ITEM const *
/* 115 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 116 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3155), // AUTHORITY_KEYID *()(void)
/* 117 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 118 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3158), // BASIC_CONSTRAINTS *()(void)
/* 119 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 120 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(ASN1_INTEGER *, BIGNUM *)
/* 121 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 122 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 123 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 124 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(BIGNUM *, BIGNUM const *)
/* 125 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 126 */ _CFFI_OP(_CFFI_OP_POINTER, 3649), // BIGNUM const *
/* 127 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 128 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(BIGNUM *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 129 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 130 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 131 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 132 */ _CFFI_OP(_CFFI_OP_POINTER, 3652), // BN_CTX *
/* 133 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 134 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(BIGNUM const *)
/* 135 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 136 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 137 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(BN_CTX *)
/* 138 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 139 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 140 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(EC_GROUP const *, EC_POINT const *, point_conversion_form_t, BIGNUM *, BN_CTX *)
/* 141 */ _CFFI_OP(_CFFI_OP_POINTER, 3693), // EC_GROUP const *
/* 142 */ _CFFI_OP(_CFFI_OP_POINTER, 3696), // EC_POINT const *
/* 143 */ _CFFI_OP(_CFFI_OP_ENUM, 1), // point_conversion_form_t
/* 144 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 145 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 146 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 147 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(unsigned char const *, int, BIGNUM *)
/* 148 */ _CFFI_OP(_CFFI_OP_POINTER, 3792), // unsigned char const *
/* 149 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 150 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 151 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 152 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // BIGNUM *()(void)
/* 153 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 154 */ _CFFI_OP(_CFFI_OP_FUNCTION, 126), // BIGNUM const *()(EC_KEY const *)
/* 155 */ _CFFI_OP(_CFFI_OP_POINTER, 3694), // EC_KEY const *
/* 156 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 157 */ _CFFI_OP(_CFFI_OP_FUNCTION, 126), // BIGNUM const *()(void)
/* 158 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 159 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(BIO *)
/* 160 */ _CFFI_OP(_CFFI_OP_POINTER, 3650), // BIO *
/* 161 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 162 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(BIO *, BIO *)
/* 163 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 164 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 165 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 166 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(BIO *, CMS_ContentInfo *)
/* 167 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 168 */ _CFFI_OP(_CFFI_OP_POINTER, 3657), // CMS_ContentInfo *
/* 169 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 170 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(BIO *, int)
/* 171 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 172 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 173 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 174 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(BIO_METHOD *)
/* 175 */ _CFFI_OP(_CFFI_OP_POINTER, 3651), // BIO_METHOD *
/* 176 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 177 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(FILE *, int)
/* 178 */ _CFFI_OP(_CFFI_OP_POINTER, 3712), // FILE *
/* 179 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 180 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 181 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(PKCS7 *, BIO *)
/* 182 */ _CFFI_OP(_CFFI_OP_POINTER, 3729), // PKCS7 *
/* 183 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 184 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 185 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(SSL const *)
/* 186 */ _CFFI_OP(_CFFI_OP_POINTER, 3748), // SSL const *
/* 187 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 188 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(char const *, char const *)
/* 189 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 190 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 191 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 192 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(int, int)
/* 193 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 194 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 195 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 196 */ _CFFI_OP(_CFFI_OP_FUNCTION, 160), // BIO *()(void *, int)
/* 197 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 198 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 199 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 200 */ _CFFI_OP(_CFFI_OP_FUNCTION, 175), // BIO_METHOD *()(void)
/* 201 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 202 */ _CFFI_OP(_CFFI_OP_FUNCTION, 132), // BN_CTX *()(void)
/* 203 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 204 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1119), // BN_ULONG()(BIGNUM const *)
/* 205 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 206 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 207 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1347), // CMAC_CTX *()(void)
/* 208 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 209 */ _CFFI_OP(_CFFI_OP_FUNCTION, 168), // CMS_ContentInfo *()(Cryptography_STACK_OF_X509 *, BIO *, EVP_CIPHER const *, unsigned int)
/* 210 */ _CFFI_OP(_CFFI_OP_POINTER, 3680), // Cryptography_STACK_OF_X509 *
/* 211 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 212 */ _CFFI_OP(_CFFI_OP_POINTER, 3705), // EVP_CIPHER const *
/* 213 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8), // unsigned int
/* 214 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 215 */ _CFFI_OP(_CFFI_OP_FUNCTION, 168), // CMS_ContentInfo *()(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *, BIO *, unsigned int)
/* 216 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 217 */ _CFFI_OP(_CFFI_OP_POINTER, 3709), // EVP_PKEY *
/* 218 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 219 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 220 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 221 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 222 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3662), // CMS_SignerInfo *()(CMS_ContentInfo *, X509 *, EVP_PKEY *, EVP_MD const *, unsigned int)
/* 223 */ _CFFI_OP(_CFFI_OP_NOOP, 168),
/* 224 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 225 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 226 */ _CFFI_OP(_CFFI_OP_POINTER, 3707), // EVP_MD const *
/* 227 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 228 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 229 */ _CFFI_OP(_CFFI_OP_FUNCTION, 939), // COMP_METHOD const *()(SSL *)
/* 230 */ _CFFI_OP(_CFFI_OP_POINTER, 3748), // SSL *
/* 231 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 232 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // Cryptography_STACK_OF_ACCESS_DESCRIPTION *()(void)
/* 233 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 234 */ _CFFI_OP(_CFFI_OP_FUNCTION, 24), // Cryptography_STACK_OF_ASN1_INTEGER *()(void)
/* 235 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 236 */ _CFFI_OP(_CFFI_OP_FUNCTION, 47), // Cryptography_STACK_OF_ASN1_OBJECT *()(void)
/* 237 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 238 */ _CFFI_OP(_CFFI_OP_FUNCTION, 310), // Cryptography_STACK_OF_DIST_POINT *()(void)
/* 239 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 240 */ _CFFI_OP(_CFFI_OP_FUNCTION, 531), // Cryptography_STACK_OF_GENERAL_SUBTREE *()(void)
/* 241 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 242 */ _CFFI_OP(_CFFI_OP_FUNCTION, 637), // Cryptography_STACK_OF_POLICYINFO *()(void)
/* 243 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 244 */ _CFFI_OP(_CFFI_OP_FUNCTION, 643), // Cryptography_STACK_OF_POLICYQUALINFO *()(void)
/* 245 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 246 */ _CFFI_OP(_CFFI_OP_FUNCTION, 687), // Cryptography_STACK_OF_SSL_CIPHER *()(SSL const *)
/* 247 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 248 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 249 */ _CFFI_OP(_CFFI_OP_FUNCTION, 210), // Cryptography_STACK_OF_X509 *()(PKCS7 *, Cryptography_STACK_OF_X509 *, int)
/* 250 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 251 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 252 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 253 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 254 */ _CFFI_OP(_CFFI_OP_FUNCTION, 210), // Cryptography_STACK_OF_X509 *()(SSL const *)
/* 255 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 256 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 257 */ _CFFI_OP(_CFFI_OP_FUNCTION, 210), // Cryptography_STACK_OF_X509 *()(X509_STORE_CTX *)
/* 258 */ _CFFI_OP(_CFFI_OP_POINTER, 3776), // X509_STORE_CTX *
/* 259 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 260 */ _CFFI_OP(_CFFI_OP_FUNCTION, 210), // Cryptography_STACK_OF_X509 *()(void)
/* 261 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 262 */ _CFFI_OP(_CFFI_OP_FUNCTION, 772), // Cryptography_STACK_OF_X509_CRL *()(void)
/* 263 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 264 */ _CFFI_OP(_CFFI_OP_FUNCTION, 837), // Cryptography_STACK_OF_X509_NAME *()(SSL const *)
/* 265 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 266 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 267 */ _CFFI_OP(_CFFI_OP_FUNCTION, 837), // Cryptography_STACK_OF_X509_NAME *()(char const *)
/* 268 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 269 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 270 */ _CFFI_OP(_CFFI_OP_FUNCTION, 837), // Cryptography_STACK_OF_X509_NAME *()(void)
/* 271 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 272 */ _CFFI_OP(_CFFI_OP_FUNCTION, 273), // Cryptography_STACK_OF_X509_NAME_ENTRY *()(Cryptography_STACK_OF_X509_NAME_ENTRY *)
/* 273 */ _CFFI_OP(_CFFI_OP_POINTER, 3683), // Cryptography_STACK_OF_X509_NAME_ENTRY *
/* 274 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 275 */ _CFFI_OP(_CFFI_OP_FUNCTION, 273), // Cryptography_STACK_OF_X509_NAME_ENTRY *()(void)
/* 276 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 277 */ _CFFI_OP(_CFFI_OP_FUNCTION, 870), // Cryptography_STACK_OF_X509_OBJECT *()(X509_STORE *)
/* 278 */ _CFFI_OP(_CFFI_OP_POINTER, 3775), // X509_STORE *
/* 279 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 280 */ _CFFI_OP(_CFFI_OP_FUNCTION, 886), // Cryptography_STACK_OF_X509_REVOKED *()(X509_CRL *)
/* 281 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 282 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 283 */ _CFFI_OP(_CFFI_OP_FUNCTION, 299), // DH *()(BIO *, DH * *)
/* 284 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 285 */ _CFFI_OP(_CFFI_OP_POINTER, 299), // DH * *
/* 286 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 287 */ _CFFI_OP(_CFFI_OP_FUNCTION, 299), // DH *()(BIO *, DH * *, int(*)(char *, int, int, void *), void *)
/* 288 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 289 */ _CFFI_OP(_CFFI_OP_NOOP, 285),
/* 290 */ _CFFI_OP(_CFFI_OP_POINTER, 2629), // int(*)(char *, int, int, void *)
/* 291 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 292 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 293 */ _CFFI_OP(_CFFI_OP_FUNCTION, 299), // DH *()(DH * *, unsigned char const * *, long)
/* 294 */ _CFFI_OP(_CFFI_OP_NOOP, 285),
/* 295 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 296 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 297 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 298 */ _CFFI_OP(_CFFI_OP_FUNCTION, 299), // DH *()(DH *)
/* 299 */ _CFFI_OP(_CFFI_OP_POINTER, 3686), // DH *
/* 300 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 301 */ _CFFI_OP(_CFFI_OP_FUNCTION, 299), // DH *()(EVP_PKEY *)
/* 302 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 303 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 304 */ _CFFI_OP(_CFFI_OP_FUNCTION, 299), // DH *()(void)
/* 305 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 306 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1732), // DH_METHOD const *()(ENGINE const *)
/* 307 */ _CFFI_OP(_CFFI_OP_POINTER, 3700), // ENGINE const *
/* 308 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 309 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1415), // DIST_POINT *()(Cryptography_STACK_OF_DIST_POINT *, int)
/* 310 */ _CFFI_OP(_CFFI_OP_POINTER, 3674), // Cryptography_STACK_OF_DIST_POINT *
/* 311 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 312 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 313 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1415), // DIST_POINT *()(void)
/* 314 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 315 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3239), // DIST_POINT_NAME *()(void)
/* 316 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 317 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // DSA *()(BIO *, DSA * *)
/* 318 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 319 */ _CFFI_OP(_CFFI_OP_POINTER, 333), // DSA * *
/* 320 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 321 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // DSA *()(BIO *, DSA * *, int(*)(char *, int, int, void *), void *)
/* 322 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 323 */ _CFFI_OP(_CFFI_OP_NOOP, 319),
/* 324 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 325 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 326 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 327 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // DSA *()(DSA * *, unsigned char const * *, long)
/* 328 */ _CFFI_OP(_CFFI_OP_NOOP, 319),
/* 329 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 330 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 331 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 332 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // DSA *()(DSA *)
/* 333 */ _CFFI_OP(_CFFI_OP_POINTER, 3690), // DSA *
/* 334 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 335 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // DSA *()(EVP_PKEY *)
/* 336 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 337 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 338 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // DSA *()(void)
/* 339 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 340 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1736), // DSA_METHOD const *()(ENGINE const *)
/* 341 */ _CFFI_OP(_CFFI_OP_NOOP, 307),
/* 342 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 343 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3256), // ECDSA_SIG *()(ECDSA_SIG * *, unsigned char const * *, long)
/* 344 */ _CFFI_OP(_CFFI_OP_POINTER, 3256), // ECDSA_SIG * *
/* 345 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 346 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 347 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 348 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3256), // ECDSA_SIG *()(unsigned char const *, int, BIGNUM const *, BIGNUM const *, EC_KEY *)
/* 349 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 350 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 351 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 352 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 353 */ _CFFI_OP(_CFFI_OP_POINTER, 3694), // EC_KEY *
/* 354 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 355 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3256), // ECDSA_SIG *()(unsigned char const *, int, EC_KEY *)
/* 356 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 357 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 358 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 359 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 360 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3256), // ECDSA_SIG *()(void)
/* 361 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 362 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1554), // EC_GROUP *()(BIGNUM const *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 363 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 364 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 365 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 366 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 367 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 368 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1554), // EC_GROUP *()(EC_METHOD const *)
/* 369 */ _CFFI_OP(_CFFI_OP_POINTER, 3695), // EC_METHOD const *
/* 370 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 371 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1554), // EC_GROUP *()(int)
/* 372 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 373 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 374 */ _CFFI_OP(_CFFI_OP_FUNCTION, 141), // EC_GROUP const *()(EC_KEY const *)
/* 375 */ _CFFI_OP(_CFFI_OP_NOOP, 155),
/* 376 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 377 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(BIO *, EC_KEY * *)
/* 378 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 379 */ _CFFI_OP(_CFFI_OP_POINTER, 353), // EC_KEY * *
/* 380 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 381 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(EC_KEY * *, unsigned char const * *, long)
/* 382 */ _CFFI_OP(_CFFI_OP_NOOP, 379),
/* 383 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 384 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 385 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 386 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(EC_KEY *)
/* 387 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 388 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 389 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(EC_KEY *, EC_KEY *)
/* 390 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 391 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 392 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 393 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(EVP_PKEY *)
/* 394 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 395 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 396 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(int)
/* 397 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 398 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 399 */ _CFFI_OP(_CFFI_OP_FUNCTION, 353), // EC_KEY *()(void)
/* 400 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 401 */ _CFFI_OP(_CFFI_OP_FUNCTION, 369), // EC_METHOD const *()(EC_GROUP const *)
/* 402 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 403 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 404 */ _CFFI_OP(_CFFI_OP_FUNCTION, 369), // EC_METHOD const *()(EC_POINT const *)
/* 405 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 406 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 407 */ _CFFI_OP(_CFFI_OP_FUNCTION, 369), // EC_METHOD const *()(void)
/* 408 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 409 */ _CFFI_OP(_CFFI_OP_FUNCTION, 415), // EC_POINT *()(EC_GROUP const *)
/* 410 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 411 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 412 */ _CFFI_OP(_CFFI_OP_FUNCTION, 415), // EC_POINT *()(EC_GROUP const *, BIGNUM const *, EC_POINT *, BN_CTX *)
/* 413 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 414 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 415 */ _CFFI_OP(_CFFI_OP_POINTER, 3696), // EC_POINT *
/* 416 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 417 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 418 */ _CFFI_OP(_CFFI_OP_FUNCTION, 415), // EC_POINT *()(EC_GROUP const *, char const *, EC_POINT *, BN_CTX *)
/* 419 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 420 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 421 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 422 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 423 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 424 */ _CFFI_OP(_CFFI_OP_FUNCTION, 415), // EC_POINT *()(EC_POINT const *, EC_GROUP const *)
/* 425 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 426 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 427 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 428 */ _CFFI_OP(_CFFI_OP_FUNCTION, 142), // EC_POINT const *()(EC_GROUP const *)
/* 429 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 430 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 431 */ _CFFI_OP(_CFFI_OP_FUNCTION, 142), // EC_POINT const *()(EC_KEY const *)
/* 432 */ _CFFI_OP(_CFFI_OP_NOOP, 155),
/* 433 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 434 */ _CFFI_OP(_CFFI_OP_FUNCTION, 435), // ENGINE *()(ENGINE *)
/* 435 */ _CFFI_OP(_CFFI_OP_POINTER, 3700), // ENGINE *
/* 436 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 437 */ _CFFI_OP(_CFFI_OP_FUNCTION, 435), // ENGINE *()(char const *)
/* 438 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 439 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 440 */ _CFFI_OP(_CFFI_OP_FUNCTION, 435), // ENGINE *()(int)
/* 441 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 442 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 443 */ _CFFI_OP(_CFFI_OP_FUNCTION, 435), // ENGINE *()(void)
/* 444 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 445 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1744), // ENGINE_CMD_DEFN const *()(ENGINE const *)
/* 446 */ _CFFI_OP(_CFFI_OP_NOOP, 307),
/* 447 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 448 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3702), // ERR_STATE *()(void)
/* 449 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 450 */ _CFFI_OP(_CFFI_OP_FUNCTION, 212), // EVP_CIPHER const *()(ENGINE *, int)
/* 451 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 452 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 453 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 454 */ _CFFI_OP(_CFFI_OP_FUNCTION, 212), // EVP_CIPHER const *()(EVP_CIPHER_CTX const *)
/* 455 */ _CFFI_OP(_CFFI_OP_POINTER, 3706), // EVP_CIPHER_CTX const *
/* 456 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 457 */ _CFFI_OP(_CFFI_OP_FUNCTION, 212), // EVP_CIPHER const *()(char const *)
/* 458 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 459 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 460 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1810), // EVP_CIPHER_CTX *()(void)
/* 461 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 462 */ _CFFI_OP(_CFFI_OP_FUNCTION, 226), // EVP_MD const *()(ENGINE *, int)
/* 463 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 464 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 465 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 466 */ _CFFI_OP(_CFFI_OP_FUNCTION, 226), // EVP_MD const *()(EVP_MD_CTX const *)
/* 467 */ _CFFI_OP(_CFFI_OP_POINTER, 3708), // EVP_MD_CTX const *
/* 468 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 469 */ _CFFI_OP(_CFFI_OP_FUNCTION, 226), // EVP_MD const *()(char const *)
/* 470 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 471 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 472 */ _CFFI_OP(_CFFI_OP_FUNCTION, 226), // EVP_MD const *()(void)
/* 473 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 474 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1856), // EVP_MD_CTX *()(void)
/* 475 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 476 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(BIO *, EVP_PKEY * *)
/* 477 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 478 */ _CFFI_OP(_CFFI_OP_POINTER, 217), // EVP_PKEY * *
/* 479 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 480 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(BIO *, EVP_PKEY * *, int(*)(char *, int, int, void *), void *)
/* 481 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 482 */ _CFFI_OP(_CFFI_OP_NOOP, 478),
/* 483 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 484 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 485 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 486 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(ENGINE *, char const *, UI_METHOD *, void *)
/* 487 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 488 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 489 */ _CFFI_OP(_CFFI_OP_POINTER, 3754), // UI_METHOD *
/* 490 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 491 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 492 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(NETSCAPE_SPKI *)
/* 493 */ _CFFI_OP(_CFFI_OP_POINTER, 3718), // NETSCAPE_SPKI *
/* 494 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 495 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(PKCS8_PRIV_KEY_INFO *)
/* 496 */ _CFFI_OP(_CFFI_OP_POINTER, 3740), // PKCS8_PRIV_KEY_INFO *
/* 497 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 498 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(X509 *)
/* 499 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 500 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 501 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(X509_REQ *)
/* 502 */ _CFFI_OP(_CFFI_OP_POINTER, 3772), // X509_REQ *
/* 503 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 504 */ _CFFI_OP(_CFFI_OP_FUNCTION, 217), // EVP_PKEY *()(void)
/* 505 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 506 */ _CFFI_OP(_CFFI_OP_FUNCTION, 511), // EVP_PKEY_CTX *()(EVP_PKEY *, ENGINE *)
/* 507 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 508 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 509 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 510 */ _CFFI_OP(_CFFI_OP_FUNCTION, 511), // EVP_PKEY_CTX *()(EVP_PKEY_CTX *)
/* 511 */ _CFFI_OP(_CFFI_OP_POINTER, 3710), // EVP_PKEY_CTX *
/* 512 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 513 */ _CFFI_OP(_CFFI_OP_FUNCTION, 511), // EVP_PKEY_CTX *()(int, ENGINE *)
/* 514 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 515 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 516 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 517 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1228), // GENERAL_NAME *()(GENERAL_NAMES *, int)
/* 518 */ _CFFI_OP(_CFFI_OP_POINTER, 3714), // GENERAL_NAMES *
/* 519 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 520 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 521 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1228), // GENERAL_NAME *()(void)
/* 522 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 523 */ _CFFI_OP(_CFFI_OP_FUNCTION, 518), // GENERAL_NAMES *()(GENERAL_NAMES * *, unsigned char const * *, long)
/* 524 */ _CFFI_OP(_CFFI_OP_POINTER, 518), // GENERAL_NAMES * *
/* 525 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 526 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 527 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 528 */ _CFFI_OP(_CFFI_OP_FUNCTION, 518), // GENERAL_NAMES *()(void)
/* 529 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 530 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1422), // GENERAL_SUBTREE *()(Cryptography_STACK_OF_GENERAL_SUBTREE *, int)
/* 531 */ _CFFI_OP(_CFFI_OP_POINTER, 3675), // Cryptography_STACK_OF_GENERAL_SUBTREE *
/* 532 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 533 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 534 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1422), // GENERAL_SUBTREE *()(void)
/* 535 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 536 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1994), // HMAC_CTX *()(void)
/* 537 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 538 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3319), // NAME_CONSTRAINTS *()(void)
/* 539 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 540 */ _CFFI_OP(_CFFI_OP_FUNCTION, 493), // NETSCAPE_SPKI *()(char const *, int)
/* 541 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 542 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 543 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 544 */ _CFFI_OP(_CFFI_OP_FUNCTION, 493), // NETSCAPE_SPKI *()(void)
/* 545 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 546 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3325), // NOTICEREF *()(void)
/* 547 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 548 */ _CFFI_OP(_CFFI_OP_FUNCTION, 572), // OCSP_BASICRESP *()(OCSP_RESPONSE *)
/* 549 */ _CFFI_OP(_CFFI_OP_POINTER, 3725), // OCSP_RESPONSE *
/* 550 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 551 */ _CFFI_OP(_CFFI_OP_FUNCTION, 572), // OCSP_BASICRESP *()(void)
/* 552 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 553 */ _CFFI_OP(_CFFI_OP_FUNCTION, 576), // OCSP_CERTID *()(OCSP_ONEREQ *)
/* 554 */ _CFFI_OP(_CFFI_OP_POINTER, 3723), // OCSP_ONEREQ *
/* 555 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 556 */ _CFFI_OP(_CFFI_OP_FUNCTION, 554), // OCSP_ONEREQ *()(OCSP_REQUEST *, int)
/* 557 */ _CFFI_OP(_CFFI_OP_POINTER, 3724), // OCSP_REQUEST *
/* 558 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 559 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 560 */ _CFFI_OP(_CFFI_OP_FUNCTION, 557), // OCSP_REQUEST *()(BIO *, OCSP_REQUEST * *)
/* 561 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 562 */ _CFFI_OP(_CFFI_OP_POINTER, 557), // OCSP_REQUEST * *
/* 563 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 564 */ _CFFI_OP(_CFFI_OP_FUNCTION, 557), // OCSP_REQUEST *()(void)
/* 565 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 566 */ _CFFI_OP(_CFFI_OP_FUNCTION, 549), // OCSP_RESPONSE *()(BIO *, OCSP_RESPONSE * *)
/* 567 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 568 */ _CFFI_OP(_CFFI_OP_POINTER, 549), // OCSP_RESPONSE * *
/* 569 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 570 */ _CFFI_OP(_CFFI_OP_FUNCTION, 549), // OCSP_RESPONSE *()(int, OCSP_BASICRESP *)
/* 571 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 572 */ _CFFI_OP(_CFFI_OP_POINTER, 3721), // OCSP_BASICRESP *
/* 573 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 574 */ _CFFI_OP(_CFFI_OP_FUNCTION, 798), // OCSP_SINGLERESP *()(OCSP_BASICRESP *, OCSP_CERTID *, int, int, ASN1_OCTET_STRING *, ASN1_OCTET_STRING *, ASN1_OCTET_STRING *)
/* 575 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 576 */ _CFFI_OP(_CFFI_OP_POINTER, 3722), // OCSP_CERTID *
/* 577 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 578 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 579 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 580 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 581 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 582 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 583 */ _CFFI_OP(_CFFI_OP_FUNCTION, 798), // OCSP_SINGLERESP *()(OCSP_BASICRESP *, int)
/* 584 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 585 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 586 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 587 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3338), // OTHERNAME *()(void)
/* 588 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 589 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1240), // PKCS12 *()(BIO *, PKCS12 * *)
/* 590 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 591 */ _CFFI_OP(_CFFI_OP_POINTER, 1240), // PKCS12 * *
/* 592 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 593 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1240), // PKCS12 *()(char *, char *, EVP_PKEY *, X509 *, Cryptography_STACK_OF_X509 *, int, int, int, int, int)
/* 594 */ _CFFI_OP(_CFFI_OP_POINTER, 3779), // char *
/* 595 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 596 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 597 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 598 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 599 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 600 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 601 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 602 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 603 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 604 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 605 */ _CFFI_OP(_CFFI_OP_FUNCTION, 182), // PKCS7 *()(BIO *, BIO * *)
/* 606 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 607 */ _CFFI_OP(_CFFI_OP_POINTER, 160), // BIO * *
/* 608 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 609 */ _CFFI_OP(_CFFI_OP_FUNCTION, 182), // PKCS7 *()(BIO *, PKCS7 * *)
/* 610 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 611 */ _CFFI_OP(_CFFI_OP_POINTER, 182), // PKCS7 * *
/* 612 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 613 */ _CFFI_OP(_CFFI_OP_FUNCTION, 182), // PKCS7 *()(BIO *, PKCS7 * *, int(*)(char *, int, int, void *), void *)
/* 614 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 615 */ _CFFI_OP(_CFFI_OP_NOOP, 611),
/* 616 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 617 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 618 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 619 */ _CFFI_OP(_CFFI_OP_FUNCTION, 182), // PKCS7 *()(Cryptography_STACK_OF_X509 *, BIO *, EVP_CIPHER const *, int)
/* 620 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 621 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 622 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 623 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 624 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 625 */ _CFFI_OP(_CFFI_OP_FUNCTION, 182), // PKCS7 *()(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *, BIO *, int)
/* 626 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 627 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 628 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 629 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 630 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 631 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 632 */ _CFFI_OP(_CFFI_OP_FUNCTION, 496), // PKCS8_PRIV_KEY_INFO *()(BIO *, PKCS8_PRIV_KEY_INFO * *)
/* 633 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 634 */ _CFFI_OP(_CFFI_OP_POINTER, 496), // PKCS8_PRIV_KEY_INFO * *
/* 635 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 636 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1429), // POLICYINFO *()(Cryptography_STACK_OF_POLICYINFO *, int)
/* 637 */ _CFFI_OP(_CFFI_OP_POINTER, 3676), // Cryptography_STACK_OF_POLICYINFO *
/* 638 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 639 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 640 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1429), // POLICYINFO *()(void)
/* 641 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 642 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1436), // POLICYQUALINFO *()(Cryptography_STACK_OF_POLICYQUALINFO *, int)
/* 643 */ _CFFI_OP(_CFFI_OP_POINTER, 3677), // Cryptography_STACK_OF_POLICYQUALINFO *
/* 644 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 645 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 646 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1436), // POLICYQUALINFO *()(void)
/* 647 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 648 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3356), // POLICY_CONSTRAINTS *()(void)
/* 649 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 650 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1760), // RAND_METHOD const *()(ENGINE const *)
/* 651 */ _CFFI_OP(_CFFI_OP_NOOP, 307),
/* 652 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 653 */ _CFFI_OP(_CFFI_OP_FUNCTION, 672), // RSA *()(BIO *, RSA * *)
/* 654 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 655 */ _CFFI_OP(_CFFI_OP_POINTER, 672), // RSA * *
/* 656 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 657 */ _CFFI_OP(_CFFI_OP_FUNCTION, 672), // RSA *()(BIO *, RSA * *, int(*)(char *, int, int, void *), void *)
/* 658 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 659 */ _CFFI_OP(_CFFI_OP_NOOP, 655),
/* 660 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 661 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 662 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 663 */ _CFFI_OP(_CFFI_OP_FUNCTION, 672), // RSA *()(EVP_PKEY *)
/* 664 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 665 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 666 */ _CFFI_OP(_CFFI_OP_FUNCTION, 672), // RSA *()(RSA * *, unsigned char const * *, long)
/* 667 */ _CFFI_OP(_CFFI_OP_NOOP, 655),
/* 668 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 669 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 670 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 671 */ _CFFI_OP(_CFFI_OP_FUNCTION, 672), // RSA *()(RSA *)
/* 672 */ _CFFI_OP(_CFFI_OP_POINTER, 3745), // RSA *
/* 673 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 674 */ _CFFI_OP(_CFFI_OP_FUNCTION, 672), // RSA *()(void)
/* 675 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 676 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1764), // RSA_METHOD const *()(ENGINE const *)
/* 677 */ _CFFI_OP(_CFFI_OP_NOOP, 307),
/* 678 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 679 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2149), // SCT *()(Cryptography_STACK_OF_SCT const *, int)
/* 680 */ _CFFI_OP(_CFFI_OP_POINTER, 3678), // Cryptography_STACK_OF_SCT const *
/* 681 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 682 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 683 */ _CFFI_OP(_CFFI_OP_FUNCTION, 230), // SSL *()(SSL_CTX *)
/* 684 */ _CFFI_OP(_CFFI_OP_POINTER, 3750), // SSL_CTX *
/* 685 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 686 */ _CFFI_OP(_CFFI_OP_FUNCTION, 925), // SSL_CIPHER const *()(Cryptography_STACK_OF_SSL_CIPHER *, int)
/* 687 */ _CFFI_OP(_CFFI_OP_POINTER, 3679), // Cryptography_STACK_OF_SSL_CIPHER *
/* 688 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 689 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 690 */ _CFFI_OP(_CFFI_OP_FUNCTION, 925), // SSL_CIPHER const *()(SSL const *)
/* 691 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 692 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 693 */ _CFFI_OP(_CFFI_OP_FUNCTION, 684), // SSL_CTX *()(SSL *, SSL_CTX *)
/* 694 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 695 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 696 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 697 */ _CFFI_OP(_CFFI_OP_FUNCTION, 684), // SSL_CTX *()(SSL const *)
/* 698 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 699 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 700 */ _CFFI_OP(_CFFI_OP_FUNCTION, 684), // SSL_CTX *()(SSL_METHOD *)
/* 701 */ _CFFI_OP(_CFFI_OP_POINTER, 3752), // SSL_METHOD *
/* 702 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 703 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3751), // SSL_METHOD const *()(SSL_CTX *)
/* 704 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 705 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 706 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3751), // SSL_METHOD const *()(void)
/* 707 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 708 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2161), // SSL_SESSION *()(SSL *)
/* 709 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 710 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 711 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2161), // SSL_SESSION *()(SSL const *)
/* 712 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 713 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 714 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3477), // USERNOTICE *()(void)
/* 715 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 716 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(BIO *, X509 * *)
/* 717 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 718 */ _CFFI_OP(_CFFI_OP_POINTER, 28), // X509 * *
/* 719 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 720 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(BIO *, X509 * *, int(*)(char *, int, int, void *), void *)
/* 721 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 722 */ _CFFI_OP(_CFFI_OP_NOOP, 718),
/* 723 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 724 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 725 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 726 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(Cryptography_STACK_OF_X509 *, int)
/* 727 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 728 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 729 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 730 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(SSL const *)
/* 731 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 732 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 733 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(X509 *)
/* 734 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 735 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 736 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(X509_OBJECT *)
/* 737 */ _CFFI_OP(_CFFI_OP_POINTER, 3771), // X509_OBJECT *
/* 738 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 739 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(X509_STORE_CTX *)
/* 740 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 741 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 742 */ _CFFI_OP(_CFFI_OP_FUNCTION, 28), // X509 *()(void)
/* 743 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 744 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3758), // X509V3_EXT_METHOD const *()(X509_EXTENSION *)
/* 745 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 746 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 747 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3758), // X509V3_EXT_METHOD const *()(int)
/* 748 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 749 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 750 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3761), // X509_ALGOR const *()(X509 const *)
/* 751 */ _CFFI_OP(_CFFI_OP_POINTER, 3756), // X509 const *
/* 752 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 753 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1921), // X509_ATTRIBUTE *()(EVP_PKEY *, int)
/* 754 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 755 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 756 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 757 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1921), // X509_ATTRIBUTE *()(EVP_PKEY const *, int)
/* 758 */ _CFFI_OP(_CFFI_OP_POINTER, 3709), // EVP_PKEY const *
/* 759 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 760 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 761 */ _CFFI_OP(_CFFI_OP_FUNCTION, 80), // X509_CRL *()(BIO *, X509_CRL * *)
/* 762 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 763 */ _CFFI_OP(_CFFI_OP_POINTER, 80), // X509_CRL * *
/* 764 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 765 */ _CFFI_OP(_CFFI_OP_FUNCTION, 80), // X509_CRL *()(BIO *, X509_CRL * *, int(*)(char *, int, int, void *), void *)
/* 766 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 767 */ _CFFI_OP(_CFFI_OP_NOOP, 763),
/* 768 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 769 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 770 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 771 */ _CFFI_OP(_CFFI_OP_FUNCTION, 80), // X509_CRL *()(Cryptography_STACK_OF_X509_CRL *, int)
/* 772 */ _CFFI_OP(_CFFI_OP_POINTER, 3681), // Cryptography_STACK_OF_X509_CRL *
/* 773 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 774 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 775 */ _CFFI_OP(_CFFI_OP_FUNCTION, 80), // X509_CRL *()(void)
/* 776 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 777 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(CONF *, X509V3_CTX *, char *, char *)
/* 778 */ _CFFI_OP(_CFFI_OP_POINTER, 3665), // CONF *
/* 779 */ _CFFI_OP(_CFFI_OP_POINTER, 3757), // X509V3_CTX *
/* 780 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 781 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 782 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 783 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(Cryptography_LHASH_OF_CONF_VALUE *, X509V3_CTX *, int, char *)
/* 784 */ _CFFI_OP(_CFFI_OP_POINTER, 3670), // Cryptography_LHASH_OF_CONF_VALUE *
/* 785 */ _CFFI_OP(_CFFI_OP_NOOP, 779),
/* 786 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 787 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 788 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 789 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(OCSP_BASICRESP *, int)
/* 790 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 791 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 792 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 793 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(OCSP_ONEREQ *, int)
/* 794 */ _CFFI_OP(_CFFI_OP_NOOP, 554),
/* 795 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 796 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 797 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(OCSP_SINGLERESP *, int)
/* 798 */ _CFFI_OP(_CFFI_OP_POINTER, 3726), // OCSP_SINGLERESP *
/* 799 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 800 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 801 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(X509 *, int)
/* 802 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 803 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 804 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 805 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(X509_CRL *, int)
/* 806 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 807 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 808 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 809 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(X509_EXTENSION * *, ASN1_OBJECT *, int, ASN1_OCTET_STRING *)
/* 810 */ _CFFI_OP(_CFFI_OP_POINTER, 51), // X509_EXTENSION * *
/* 811 */ _CFFI_OP(_CFFI_OP_POINTER, 3640), // ASN1_OBJECT *
/* 812 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 813 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 814 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 815 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(X509_EXTENSION *)
/* 816 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 817 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 818 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(X509_EXTENSIONS *, int)
/* 819 */ _CFFI_OP(_CFFI_OP_POINTER, 3768), // X509_EXTENSIONS *
/* 820 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 821 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 822 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(X509_REVOKED *, int)
/* 823 */ _CFFI_OP(_CFFI_OP_POINTER, 3774), // X509_REVOKED *
/* 824 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 825 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 826 */ _CFFI_OP(_CFFI_OP_FUNCTION, 51), // X509_EXTENSION *()(int, int, void *)
/* 827 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 828 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 829 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 830 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 831 */ _CFFI_OP(_CFFI_OP_FUNCTION, 819), // X509_EXTENSIONS *()(X509_REQ *)
/* 832 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 833 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 834 */ _CFFI_OP(_CFFI_OP_FUNCTION, 819), // X509_EXTENSIONS *()(void)
/* 835 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 836 */ _CFFI_OP(_CFFI_OP_FUNCTION, 847), // X509_NAME *()(Cryptography_STACK_OF_X509_NAME *, int)
/* 837 */ _CFFI_OP(_CFFI_OP_POINTER, 3682), // Cryptography_STACK_OF_X509_NAME *
/* 838 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 839 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 840 */ _CFFI_OP(_CFFI_OP_FUNCTION, 847), // X509_NAME *()(X509 *)
/* 841 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 842 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 843 */ _CFFI_OP(_CFFI_OP_FUNCTION, 847), // X509_NAME *()(X509_CRL *)
/* 844 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 845 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 846 */ _CFFI_OP(_CFFI_OP_FUNCTION, 847), // X509_NAME *()(X509_NAME *)
/* 847 */ _CFFI_OP(_CFFI_OP_POINTER, 3769), // X509_NAME *
/* 848 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 849 */ _CFFI_OP(_CFFI_OP_FUNCTION, 847), // X509_NAME *()(X509_REQ *)
/* 850 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 851 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 852 */ _CFFI_OP(_CFFI_OP_FUNCTION, 847), // X509_NAME *()(void)
/* 853 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 854 */ _CFFI_OP(_CFFI_OP_FUNCTION, 54), // X509_NAME_ENTRY *()(Cryptography_STACK_OF_X509_NAME_ENTRY *, int)
/* 855 */ _CFFI_OP(_CFFI_OP_NOOP, 273),
/* 856 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 857 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 858 */ _CFFI_OP(_CFFI_OP_FUNCTION, 54), // X509_NAME_ENTRY *()(X509_NAME *, int)
/* 859 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 860 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 861 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 862 */ _CFFI_OP(_CFFI_OP_FUNCTION, 54), // X509_NAME_ENTRY *()(X509_NAME_ENTRY * *, ASN1_OBJECT *, int, unsigned char const *, int)
/* 863 */ _CFFI_OP(_CFFI_OP_POINTER, 54), // X509_NAME_ENTRY * *
/* 864 */ _CFFI_OP(_CFFI_OP_NOOP, 811),
/* 865 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 866 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 867 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 868 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 869 */ _CFFI_OP(_CFFI_OP_FUNCTION, 737), // X509_OBJECT *()(Cryptography_STACK_OF_X509_OBJECT *, int)
/* 870 */ _CFFI_OP(_CFFI_OP_POINTER, 3684), // Cryptography_STACK_OF_X509_OBJECT *
/* 871 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 872 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 873 */ _CFFI_OP(_CFFI_OP_FUNCTION, 502), // X509_REQ *()(BIO *, X509_REQ * *)
/* 874 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 875 */ _CFFI_OP(_CFFI_OP_POINTER, 502), // X509_REQ * *
/* 876 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 877 */ _CFFI_OP(_CFFI_OP_FUNCTION, 502), // X509_REQ *()(BIO *, X509_REQ * *, int(*)(char *, int, int, void *), void *)
/* 878 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 879 */ _CFFI_OP(_CFFI_OP_NOOP, 875),
/* 880 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 881 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 882 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 883 */ _CFFI_OP(_CFFI_OP_FUNCTION, 502), // X509_REQ *()(void)
/* 884 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 885 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // X509_REVOKED *()(Cryptography_STACK_OF_X509_REVOKED *, int)
/* 886 */ _CFFI_OP(_CFFI_OP_POINTER, 3685), // Cryptography_STACK_OF_X509_REVOKED *
/* 887 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 888 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 889 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // X509_REVOKED *()(X509_REVOKED *)
/* 890 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 891 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 892 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // X509_REVOKED *()(void)
/* 893 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 894 */ _CFFI_OP(_CFFI_OP_FUNCTION, 278), // X509_STORE *()(SSL_CTX const *)
/* 895 */ _CFFI_OP(_CFFI_OP_POINTER, 3750), // SSL_CTX const *
/* 896 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 897 */ _CFFI_OP(_CFFI_OP_FUNCTION, 278), // X509_STORE *()(void)
/* 898 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 899 */ _CFFI_OP(_CFFI_OP_FUNCTION, 258), // X509_STORE_CTX *()(void)
/* 900 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 901 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2554), // X509_VERIFY_PARAM *()(X509_STORE *)
/* 902 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 903 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 904 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2554), // X509_VERIFY_PARAM *()(X509_STORE_CTX *)
/* 905 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 906 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 907 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2554), // X509_VERIFY_PARAM *()(void)
/* 908 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 909 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(BIGNUM const *)
/* 910 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 911 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 912 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(EC_GROUP const *, EC_POINT const *, point_conversion_form_t, BN_CTX *)
/* 913 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 914 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 915 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 916 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 917 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 918 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(NETSCAPE_SPKI *)
/* 919 */ _CFFI_OP(_CFFI_OP_NOOP, 493),
/* 920 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 921 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(SSL *)
/* 922 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 923 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 924 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(SSL_CIPHER const *, char *, int)
/* 925 */ _CFFI_OP(_CFFI_OP_POINTER, 3749), // SSL_CIPHER const *
/* 926 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 927 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 928 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 929 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(X509_NAME *, char *, int)
/* 930 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 931 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 932 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 933 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 934 */ _CFFI_OP(_CFFI_OP_FUNCTION, 594), // char *()(unsigned long, char *)
/* 935 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10), // unsigned long
/* 936 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 937 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 938 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(COMP_METHOD const *)
/* 939 */ _CFFI_OP(_CFFI_OP_POINTER, 3664), // COMP_METHOD const *
/* 940 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 941 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(ENGINE const *)
/* 942 */ _CFFI_OP(_CFFI_OP_NOOP, 307),
/* 943 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 944 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(SSL const *)
/* 945 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 946 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 947 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(SSL const *, int)
/* 948 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 949 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 950 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 951 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(SSL_CIPHER const *)
/* 952 */ _CFFI_OP(_CFFI_OP_NOOP, 925),
/* 953 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 954 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(char *, size_t)
/* 955 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 956 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
/* 957 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 958 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(int)
/* 959 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 960 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 961 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(long)
/* 962 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 963 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 964 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(unsigned long)
/* 965 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 966 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 967 */ _CFFI_OP(_CFFI_OP_FUNCTION, 57), // char const *()(void)
/* 968 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 969 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3780), // ct_log_entry_type_t()(SCT const *)
/* 970 */ _CFFI_OP(_CFFI_OP_POINTER, 3747), // SCT const *
/* 971 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 972 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(AES_KEY *, unsigned char const *, unsigned char *, unsigned char const *, unsigned int)
/* 973 */ _CFFI_OP(_CFFI_OP_POINTER, 3633), // AES_KEY *
/* 974 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 975 */ _CFFI_OP(_CFFI_OP_POINTER, 3792), // unsigned char *
/* 976 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 977 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 978 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 979 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_ENUMERATED *, long)
/* 980 */ _CFFI_OP(_CFFI_OP_POINTER, 3634), // ASN1_ENUMERATED *
/* 981 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 982 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 983 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_ENUMERATED *, unsigned char * *)
/* 984 */ _CFFI_OP(_CFFI_OP_NOOP, 980),
/* 985 */ _CFFI_OP(_CFFI_OP_POINTER, 975), // unsigned char * *
/* 986 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 987 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_GENERALIZEDTIME *)
/* 988 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 989 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 990 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_GENERALIZEDTIME *, char const *)
/* 991 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 992 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 993 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 994 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_GENERALIZEDTIME *, unsigned char * *)
/* 995 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 996 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 997 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 998 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_INTEGER *, ASN1_INTEGER *)
/* 999 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 1000 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 1001 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1002 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_INTEGER *, long)
/* 1003 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 1004 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 1005 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1006 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_INTEGER *, unsigned char * *)
/* 1007 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 1008 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1009 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1010 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OBJECT *, unsigned char * *)
/* 1011 */ _CFFI_OP(_CFFI_OP_NOOP, 811),
/* 1012 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1013 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1014 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OBJECT const *)
/* 1015 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 1016 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1017 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OBJECT const *, ASN1_OBJECT const *)
/* 1018 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 1019 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 1020 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1021 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *)
/* 1022 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1023 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1024 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, ASN1_OCTET_STRING *)
/* 1025 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1026 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1027 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1028 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, char const *)
/* 1029 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1030 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1031 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1032 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, int)
/* 1033 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1034 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1035 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1036 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, int, int)
/* 1037 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1038 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1039 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1040 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1041 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, unsigned char * *)
/* 1042 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1043 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1044 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1045 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, unsigned char const *, int)
/* 1046 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1047 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1048 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1049 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1050 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_OCTET_STRING *, void const *, int)
/* 1051 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1052 */ _CFFI_OP(_CFFI_OP_POINTER, 3795), // void const *
/* 1053 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1054 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1055 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_TYPE *, unsigned char * *)
/* 1056 */ _CFFI_OP(_CFFI_OP_POINTER, 3643), // ASN1_TYPE *
/* 1057 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1058 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1059 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_UTCTIME *)
/* 1060 */ _CFFI_OP(_CFFI_OP_NOOP, 105),
/* 1061 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1062 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ASN1_UTCTIME const *, time_t)
/* 1063 */ _CFFI_OP(_CFFI_OP_POINTER, 3644), // ASN1_UTCTIME const *
/* 1064 */ _CFFI_OP(_CFFI_OP_NOOP, 10),
/* 1065 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1066 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM * *, char const *)
/* 1067 */ _CFFI_OP(_CFFI_OP_POINTER, 20), // BIGNUM * *
/* 1068 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1069 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1070 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *)
/* 1071 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1072 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1073 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM *)
/* 1074 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1075 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1076 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1077 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 1078 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1079 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1080 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1081 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1082 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1083 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1084 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM *, int)
/* 1085 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1086 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1087 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1088 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1089 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM const *, BIGNUM const *)
/* 1090 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1091 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1092 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1093 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1094 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM const *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 1095 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1096 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1097 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1098 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1099 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1100 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1101 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 1102 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1103 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1104 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1105 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1106 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1107 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM const *, BN_CTX *)
/* 1108 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1109 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1110 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1111 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1112 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BIGNUM const *, int)
/* 1113 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1114 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1115 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1116 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1117 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, BN_ULONG)
/* 1118 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1119 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, _cffi_prim_int(sizeof(BN_ULONG), (
           ((BN_ULONG)-1) | 0 /* check that BN_ULONG is an integer type */
         ) <= 0)), // BN_ULONG
/* 1120 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1121 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM *, int)
/* 1122 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1123 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1124 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1125 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM const *)
/* 1126 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1127 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1128 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM const *, BIGNUM const *)
/* 1129 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1130 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1131 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1132 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM const *, int)
/* 1133 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1134 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1135 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1136 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIGNUM const *, unsigned char *)
/* 1137 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1138 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1139 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1140 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *)
/* 1141 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1142 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1143 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, ASN1_INTEGER *)
/* 1144 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1145 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 1146 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1147 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, ASN1_OCTET_STRING *)
/* 1148 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1149 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 1150 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1151 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, ASN1_UTCTIME *)
/* 1152 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1153 */ _CFFI_OP(_CFFI_OP_NOOP, 105),
/* 1154 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1155 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, CMS_ContentInfo *, BIO *, int)
/* 1156 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1157 */ _CFFI_OP(_CFFI_OP_NOOP, 168),
/* 1158 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1159 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1160 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1161 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, DH *)
/* 1162 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1163 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1164 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1165 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, DH const *)
/* 1166 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1167 */ _CFFI_OP(_CFFI_OP_POINTER, 3686), // DH const *
/* 1168 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1169 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, DSA *)
/* 1170 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1171 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1172 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1173 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, DSA *, EVP_CIPHER const *, unsigned char *, int, int(*)(char *, int, int, void *), void *)
/* 1174 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1175 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1176 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1177 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1178 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1179 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 1180 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1181 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1182 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, EC_KEY *)
/* 1183 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1184 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1185 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1186 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, EC_KEY *, EVP_CIPHER const *, unsigned char *, int, int(*)(char *, int, int, void *), void *)
/* 1187 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1188 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1189 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1190 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1191 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1192 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 1193 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1194 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1195 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, EVP_PKEY *)
/* 1196 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1197 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1198 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1199 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, EVP_PKEY *, EVP_CIPHER const *, char *, int, int(*)(char *, int, int, void *), void *)
/* 1200 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1201 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1202 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1203 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 1204 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1205 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 1206 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1207 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1208 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, EVP_PKEY *, EVP_CIPHER const *, unsigned char *, int, int(*)(char *, int, int, void *), void *)
/* 1209 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1210 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1211 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1212 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1213 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1214 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 1215 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1216 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1217 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, EVP_PKEY *, int, char *, int, int(*)(char *, int, int, void *), void *)
/* 1218 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1219 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1220 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1221 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 1222 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1223 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 1224 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1225 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1226 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, GENERAL_NAME *)
/* 1227 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1228 */ _CFFI_OP(_CFFI_OP_POINTER, 3713), // GENERAL_NAME *
/* 1229 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1230 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, OCSP_REQUEST *)
/* 1231 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1232 */ _CFFI_OP(_CFFI_OP_NOOP, 557),
/* 1233 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1234 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, OCSP_RESPONSE *)
/* 1235 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1236 */ _CFFI_OP(_CFFI_OP_NOOP, 549),
/* 1237 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1238 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, PKCS12 *)
/* 1239 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1240 */ _CFFI_OP(_CFFI_OP_POINTER, 3728), // PKCS12 *
/* 1241 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1242 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, PKCS7 *)
/* 1243 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1244 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 1245 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1246 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, PKCS7 *, BIO *, int)
/* 1247 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1248 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 1249 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1250 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1251 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1252 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, RSA *)
/* 1253 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1254 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 1255 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1256 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, RSA *, EVP_CIPHER const *, unsigned char *, int, int(*)(char *, int, int, void *), void *)
/* 1257 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1258 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 1259 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1260 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1261 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1262 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 1263 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1264 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1265 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, RSA const *)
/* 1266 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1267 */ _CFFI_OP(_CFFI_OP_POINTER, 3745), // RSA const *
/* 1268 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1269 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, RSA const *, int)
/* 1270 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1271 */ _CFFI_OP(_CFFI_OP_NOOP, 1267),
/* 1272 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1273 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1274 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, SSL_SESSION const *)
/* 1275 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1276 */ _CFFI_OP(_CFFI_OP_POINTER, 3753), // SSL_SESSION const *
/* 1277 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1278 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, X509 *)
/* 1279 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1280 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 1281 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1282 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, X509 *, unsigned long, unsigned long)
/* 1283 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1284 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 1285 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 1286 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 1287 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1288 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, X509_CRL *)
/* 1289 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1290 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 1291 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1292 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, X509_EXTENSION *, unsigned long, int)
/* 1293 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1294 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 1295 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 1296 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1297 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1298 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, X509_REQ *)
/* 1299 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1300 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 1301 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1302 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, X509_REQ *, unsigned long, unsigned long)
/* 1303 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1304 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 1305 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 1306 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 1307 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1308 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, char *, int)
/* 1309 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1310 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 1311 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1312 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1313 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, char const *)
/* 1314 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1315 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1316 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1317 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, int)
/* 1318 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1319 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1320 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1321 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, long)
/* 1322 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1323 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 1324 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1325 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, void *, int)
/* 1326 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1327 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1328 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1329 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1330 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, void const *, int)
/* 1331 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1332 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 1333 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1334 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1335 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, void(* *)(BIO *, int, char const *, int, long, long))
/* 1336 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1337 */ _CFFI_OP(_CFFI_OP_POINTER, 1341), // void(* *)(BIO *, int, char const *, int, long, long)
/* 1338 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1339 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO *, void(*)(BIO *, int, char const *, int, long, long))
/* 1340 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1341 */ _CFFI_OP(_CFFI_OP_POINTER, 3166), // void(*)(BIO *, int, char const *, int, long, long)
/* 1342 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1343 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(BIO const *)
/* 1344 */ _CFFI_OP(_CFFI_OP_POINTER, 3650), // BIO const *
/* 1345 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1346 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMAC_CTX *, CMAC_CTX const *)
/* 1347 */ _CFFI_OP(_CFFI_OP_POINTER, 3655), // CMAC_CTX *
/* 1348 */ _CFFI_OP(_CFFI_OP_POINTER, 3655), // CMAC_CTX const *
/* 1349 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1350 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMAC_CTX *, unsigned char *, size_t *)
/* 1351 */ _CFFI_OP(_CFFI_OP_NOOP, 1347),
/* 1352 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1353 */ _CFFI_OP(_CFFI_OP_POINTER, 956), // size_t *
/* 1354 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1355 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMAC_CTX *, void const *, size_t)
/* 1356 */ _CFFI_OP(_CFFI_OP_NOOP, 1347),
/* 1357 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 1358 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1359 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1360 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMAC_CTX *, void const *, size_t, EVP_CIPHER const *, ENGINE *)
/* 1361 */ _CFFI_OP(_CFFI_OP_NOOP, 1347),
/* 1362 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 1363 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1364 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1365 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1366 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1367 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMS_ContentInfo *, BIO *, BIO *, unsigned int)
/* 1368 */ _CFFI_OP(_CFFI_OP_NOOP, 168),
/* 1369 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1370 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1371 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 1372 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1373 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMS_ContentInfo *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *, BIO *, unsigned int)
/* 1374 */ _CFFI_OP(_CFFI_OP_NOOP, 168),
/* 1375 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 1376 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 1377 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1378 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1379 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 1380 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1381 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(CMS_ContentInfo *, EVP_PKEY *, X509 *, BIO *, BIO *, unsigned int)
/* 1382 */ _CFFI_OP(_CFFI_OP_NOOP, 168),
/* 1383 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1384 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 1385 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1386 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 1387 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 1388 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1389 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_ACCESS_DESCRIPTION *)
/* 1390 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 1391 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1392 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_ACCESS_DESCRIPTION *, ACCESS_DESCRIPTION *)
/* 1393 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 1394 */ _CFFI_OP(_CFFI_OP_POINTER, 3632), // ACCESS_DESCRIPTION *
/* 1395 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1396 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_ASN1_INTEGER *)
/* 1397 */ _CFFI_OP(_CFFI_OP_NOOP, 24),
/* 1398 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1399 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_ASN1_INTEGER *, ASN1_INTEGER *)
/* 1400 */ _CFFI_OP(_CFFI_OP_NOOP, 24),
/* 1401 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 1402 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1403 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_ASN1_OBJECT *)
/* 1404 */ _CFFI_OP(_CFFI_OP_NOOP, 47),
/* 1405 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1406 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_ASN1_OBJECT *, ASN1_OBJECT *)
/* 1407 */ _CFFI_OP(_CFFI_OP_NOOP, 47),
/* 1408 */ _CFFI_OP(_CFFI_OP_NOOP, 811),
/* 1409 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1410 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_DIST_POINT *)
/* 1411 */ _CFFI_OP(_CFFI_OP_NOOP, 310),
/* 1412 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1413 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_DIST_POINT *, DIST_POINT *)
/* 1414 */ _CFFI_OP(_CFFI_OP_NOOP, 310),
/* 1415 */ _CFFI_OP(_CFFI_OP_POINTER, 3688), // DIST_POINT *
/* 1416 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1417 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_GENERAL_SUBTREE *)
/* 1418 */ _CFFI_OP(_CFFI_OP_NOOP, 531),
/* 1419 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1420 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_GENERAL_SUBTREE *, GENERAL_SUBTREE *)
/* 1421 */ _CFFI_OP(_CFFI_OP_NOOP, 531),
/* 1422 */ _CFFI_OP(_CFFI_OP_POINTER, 3715), // GENERAL_SUBTREE *
/* 1423 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1424 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_POLICYINFO *)
/* 1425 */ _CFFI_OP(_CFFI_OP_NOOP, 637),
/* 1426 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1427 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_POLICYINFO *, POLICYINFO *)
/* 1428 */ _CFFI_OP(_CFFI_OP_NOOP, 637),
/* 1429 */ _CFFI_OP(_CFFI_OP_POINTER, 3741), // POLICYINFO *
/* 1430 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1431 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_POLICYQUALINFO *)
/* 1432 */ _CFFI_OP(_CFFI_OP_NOOP, 643),
/* 1433 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1434 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_POLICYQUALINFO *, POLICYQUALINFO *)
/* 1435 */ _CFFI_OP(_CFFI_OP_NOOP, 643),
/* 1436 */ _CFFI_OP(_CFFI_OP_POINTER, 3742), // POLICYQUALINFO *
/* 1437 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1438 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_SCT const *)
/* 1439 */ _CFFI_OP(_CFFI_OP_NOOP, 680),
/* 1440 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1441 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_SSL_CIPHER *)
/* 1442 */ _CFFI_OP(_CFFI_OP_NOOP, 687),
/* 1443 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1444 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509 *)
/* 1445 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 1446 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1447 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509 *, X509 *)
/* 1448 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 1449 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 1450 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1451 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_CRL *)
/* 1452 */ _CFFI_OP(_CFFI_OP_NOOP, 772),
/* 1453 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1454 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_CRL *, X509_CRL *)
/* 1455 */ _CFFI_OP(_CFFI_OP_NOOP, 772),
/* 1456 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 1457 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1458 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_NAME *)
/* 1459 */ _CFFI_OP(_CFFI_OP_NOOP, 837),
/* 1460 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1461 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_NAME *, X509_NAME *)
/* 1462 */ _CFFI_OP(_CFFI_OP_NOOP, 837),
/* 1463 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 1464 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1465 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_NAME_ENTRY *)
/* 1466 */ _CFFI_OP(_CFFI_OP_NOOP, 273),
/* 1467 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1468 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_NAME_ENTRY *, X509_NAME_ENTRY *)
/* 1469 */ _CFFI_OP(_CFFI_OP_NOOP, 273),
/* 1470 */ _CFFI_OP(_CFFI_OP_NOOP, 54),
/* 1471 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1472 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_OBJECT *)
/* 1473 */ _CFFI_OP(_CFFI_OP_NOOP, 870),
/* 1474 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1475 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(Cryptography_STACK_OF_X509_REVOKED *)
/* 1476 */ _CFFI_OP(_CFFI_OP_NOOP, 886),
/* 1477 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1478 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH *)
/* 1479 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1480 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1481 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH *, BIGNUM *, BIGNUM *)
/* 1482 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1483 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1484 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1485 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1486 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH *, BIGNUM *, BIGNUM *, BIGNUM *)
/* 1487 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1488 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1489 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1490 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1491 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1492 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH *, int, int, BN_GENCB *)
/* 1493 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1494 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1495 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1496 */ _CFFI_OP(_CFFI_OP_POINTER, 3653), // BN_GENCB *
/* 1497 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1498 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH *, int, void *)
/* 1499 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1500 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1501 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1502 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1503 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH const *)
/* 1504 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 1505 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1506 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH const *, BIGNUM const *, int *)
/* 1507 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 1508 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1509 */ _CFFI_OP(_CFFI_OP_POINTER, 2), // int *
/* 1510 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1511 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH const *, int *)
/* 1512 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 1513 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 1514 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1515 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DH const *, unsigned char * *)
/* 1516 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 1517 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1518 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1519 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DSA *)
/* 1520 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1521 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1522 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DSA *, BIGNUM *, BIGNUM *)
/* 1523 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1524 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1525 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1526 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1527 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DSA *, BIGNUM *, BIGNUM *, BIGNUM *)
/* 1528 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1529 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1530 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1531 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1532 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1533 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DSA *, int, unsigned char *, int, int *, unsigned long *, BN_GENCB *)
/* 1534 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1535 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1536 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1537 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1538 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 1539 */ _CFFI_OP(_CFFI_OP_POINTER, 935), // unsigned long *
/* 1540 */ _CFFI_OP(_CFFI_OP_NOOP, 1496),
/* 1541 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1542 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DSA *, unsigned char * *)
/* 1543 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1544 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1545 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1546 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(DSA const *)
/* 1547 */ _CFFI_OP(_CFFI_OP_POINTER, 3690), // DSA const *
/* 1548 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1549 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ECDSA_SIG const *, unsigned char * *)
/* 1550 */ _CFFI_OP(_CFFI_OP_POINTER, 3692), // ECDSA_SIG const *
/* 1551 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1552 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1553 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP *, BIGNUM const *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 1554 */ _CFFI_OP(_CFFI_OP_POINTER, 3693), // EC_GROUP *
/* 1555 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1556 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1557 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1558 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1559 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1560 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP *, BN_CTX *)
/* 1561 */ _CFFI_OP(_CFFI_OP_NOOP, 1554),
/* 1562 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1563 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1564 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *)
/* 1565 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1566 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1567 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *)
/* 1568 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1569 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1570 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1571 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1572 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1573 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1574 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, BIGNUM *, BN_CTX *)
/* 1575 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1576 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1577 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1578 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1579 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *)
/* 1580 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1581 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1582 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1583 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, BIGNUM const *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 1584 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1585 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1586 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1587 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1588 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1589 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1590 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1591 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, BIGNUM const *, BIGNUM const *, BN_CTX *)
/* 1592 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1593 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1594 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1595 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1596 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1597 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1598 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, BIGNUM const *, EC_POINT const *, BIGNUM const *, BN_CTX *)
/* 1599 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1600 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1601 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1602 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1603 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1604 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1605 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1606 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, BIGNUM const *, int, BN_CTX *)
/* 1607 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1608 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1609 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1610 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1611 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1612 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1613 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, BIGNUM const *, size_t, EC_POINT const * *, BIGNUM const * *, BN_CTX *)
/* 1614 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1615 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1616 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1617 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1618 */ _CFFI_OP(_CFFI_OP_POINTER, 142), // EC_POINT const * *
/* 1619 */ _CFFI_OP(_CFFI_OP_POINTER, 126), // BIGNUM const * *
/* 1620 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1621 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1622 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, BN_CTX *)
/* 1623 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1624 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1625 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1626 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1627 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, EC_POINT const *, BN_CTX *)
/* 1628 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1629 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1630 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1631 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1632 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1633 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, EC_POINT const *, EC_POINT const *, BN_CTX *)
/* 1634 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1635 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1636 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1637 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1638 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1639 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1640 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT *, unsigned char const *, size_t, BN_CTX *)
/* 1641 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1642 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1643 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1644 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1645 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1646 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1647 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT const *)
/* 1648 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1649 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1650 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1651 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT const *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *)
/* 1652 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1653 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1654 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1655 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1656 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1657 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1658 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1659 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT const *, BIGNUM *, BIGNUM *, BN_CTX *)
/* 1660 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1661 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1662 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1663 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1664 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1665 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1666 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT const *, BN_CTX *)
/* 1667 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1668 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1669 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1670 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1671 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, EC_POINT const *, EC_POINT const *, BN_CTX *)
/* 1672 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1673 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1674 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1675 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1676 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1677 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_GROUP const *, size_t, EC_POINT * *, BN_CTX *)
/* 1678 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1679 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1680 */ _CFFI_OP(_CFFI_OP_POINTER, 415), // EC_POINT * *
/* 1681 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1682 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1683 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *)
/* 1684 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1685 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1686 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, BIGNUM *, BIGNUM *)
/* 1687 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1688 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1689 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 1690 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1691 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, BIGNUM const *)
/* 1692 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1693 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 1694 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1695 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, BN_CTX *)
/* 1696 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1697 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1698 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1699 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, BN_CTX *, BIGNUM * *, BIGNUM * *)
/* 1700 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1701 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 1702 */ _CFFI_OP(_CFFI_OP_NOOP, 1067),
/* 1703 */ _CFFI_OP(_CFFI_OP_NOOP, 1067),
/* 1704 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1705 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, EC_GROUP const *)
/* 1706 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1707 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 1708 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1709 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, EC_POINT const *)
/* 1710 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1711 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1712 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1713 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY *, unsigned char * *)
/* 1714 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1715 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1716 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1717 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_KEY const *)
/* 1718 */ _CFFI_OP(_CFFI_OP_NOOP, 155),
/* 1719 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1720 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_METHOD const *)
/* 1721 */ _CFFI_OP(_CFFI_OP_NOOP, 369),
/* 1722 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1723 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EC_POINT *, EC_POINT const *)
/* 1724 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 1725 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 1726 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1727 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *)
/* 1728 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1729 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1730 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, DH_METHOD const *)
/* 1731 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1732 */ _CFFI_OP(_CFFI_OP_POINTER, 3687), // DH_METHOD const *
/* 1733 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1734 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, DSA_METHOD const *)
/* 1735 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1736 */ _CFFI_OP(_CFFI_OP_POINTER, 3691), // DSA_METHOD const *
/* 1737 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1738 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, ENGINE_CIPHERS_PTR)
/* 1739 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1740 */ _CFFI_OP(_CFFI_OP_POINTER, 3784), // ENGINE_CIPHERS_PTR
/* 1741 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1742 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, ENGINE_CMD_DEFN const *)
/* 1743 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1744 */ _CFFI_OP(_CFFI_OP_POINTER, 3701), // ENGINE_CMD_DEFN const *
/* 1745 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1746 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, ENGINE_CTRL_FUNC_PTR)
/* 1747 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1748 */ _CFFI_OP(_CFFI_OP_POINTER, 3785), // ENGINE_CTRL_FUNC_PTR
/* 1749 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1750 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, ENGINE_DIGESTS_PTR)
/* 1751 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1752 */ _CFFI_OP(_CFFI_OP_POINTER, 3786), // ENGINE_DIGESTS_PTR
/* 1753 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1754 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, ENGINE_LOAD_KEY_PTR)
/* 1755 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1756 */ _CFFI_OP(_CFFI_OP_POINTER, 3787), // ENGINE_LOAD_KEY_PTR
/* 1757 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1758 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, RAND_METHOD const *)
/* 1759 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1760 */ _CFFI_OP(_CFFI_OP_POINTER, 3744), // RAND_METHOD const *
/* 1761 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1762 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, RSA_METHOD const *)
/* 1763 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1764 */ _CFFI_OP(_CFFI_OP_POINTER, 3746), // RSA_METHOD const *
/* 1765 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1766 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, char const *)
/* 1767 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1768 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1769 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1770 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, char const *, char const *, int)
/* 1771 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1772 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1773 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1774 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1775 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1776 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, char const *, long, void *, void(*)(void), int)
/* 1777 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1778 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1779 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 1780 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1781 */ _CFFI_OP(_CFFI_OP_POINTER, 3622), // void(*)(void)
/* 1782 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1783 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1784 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, int(*)(ENGINE *))
/* 1785 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1786 */ _CFFI_OP(_CFFI_OP_POINTER, 1727), // int(*)(ENGINE *)
/* 1787 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1788 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, int)
/* 1789 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1790 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1791 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1792 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, int, long, void *, void(*)(void))
/* 1793 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1794 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1795 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 1796 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1797 */ _CFFI_OP(_CFFI_OP_NOOP, 1781),
/* 1798 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1799 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE *, unsigned int)
/* 1800 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1801 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 1802 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1803 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(ENGINE const *)
/* 1804 */ _CFFI_OP(_CFFI_OP_NOOP, 307),
/* 1805 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1806 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER const *)
/* 1807 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1808 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1809 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *)
/* 1810 */ _CFFI_OP(_CFFI_OP_POINTER, 3706), // EVP_CIPHER_CTX *
/* 1811 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1812 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *, EVP_CIPHER const *, ENGINE *, unsigned char const *, unsigned char const *)
/* 1813 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 1814 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1815 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1816 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1817 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1818 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1819 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *, EVP_CIPHER const *, ENGINE *, unsigned char const *, unsigned char const *, int)
/* 1820 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 1821 */ _CFFI_OP(_CFFI_OP_NOOP, 212),
/* 1822 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1823 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1824 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1825 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1826 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1827 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *, int)
/* 1828 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 1829 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1830 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1831 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *, int, int, void *)
/* 1832 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 1833 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1834 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1835 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 1836 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1837 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *, unsigned char *, int *)
/* 1838 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 1839 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1840 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 1841 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1842 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX *, unsigned char *, int *, unsigned char const *, int)
/* 1843 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 1844 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1845 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 1846 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1847 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1848 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1849 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_CIPHER_CTX const *)
/* 1850 */ _CFFI_OP(_CFFI_OP_NOOP, 455),
/* 1851 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1852 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD const *)
/* 1853 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 1854 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1855 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, EVP_MD const *)
/* 1856 */ _CFFI_OP(_CFFI_OP_POINTER, 3708), // EVP_MD_CTX *
/* 1857 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 1858 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1859 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, EVP_MD const *, ENGINE *)
/* 1860 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 1861 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 1862 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 1863 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1864 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, EVP_MD_CTX const *)
/* 1865 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 1866 */ _CFFI_OP(_CFFI_OP_NOOP, 467),
/* 1867 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1868 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, unsigned char *, unsigned int *)
/* 1869 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 1870 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1871 */ _CFFI_OP(_CFFI_OP_POINTER, 213), // unsigned int *
/* 1872 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1873 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, unsigned char *, unsigned int *, EVP_PKEY *)
/* 1874 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 1875 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1876 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 1877 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1878 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1879 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, unsigned char const *, unsigned int, EVP_PKEY *)
/* 1880 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 1881 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1882 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 1883 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1884 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1885 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX *, void const *, size_t)
/* 1886 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 1887 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 1888 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1889 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1890 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_MD_CTX const *)
/* 1891 */ _CFFI_OP(_CFFI_OP_NOOP, 467),
/* 1892 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1893 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *)
/* 1894 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1895 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1896 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, ASN1_OBJECT const *, int, unsigned char const *, int)
/* 1897 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1898 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 1899 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1900 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1901 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1902 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1903 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, DH *)
/* 1904 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1905 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 1906 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1907 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, DSA *)
/* 1908 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1909 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 1910 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1911 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, EC_KEY *)
/* 1912 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1913 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 1914 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1915 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, RSA *)
/* 1916 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1917 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 1918 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1919 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, X509_ATTRIBUTE *)
/* 1920 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1921 */ _CFFI_OP(_CFFI_OP_POINTER, 3763), // X509_ATTRIBUTE *
/* 1922 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1923 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, char const *, int, unsigned char const *, int)
/* 1924 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1925 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 1926 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1927 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1928 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1929 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1930 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY *, int, int, unsigned char const *, int)
/* 1931 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 1932 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1933 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1934 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1935 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1936 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1937 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY const *)
/* 1938 */ _CFFI_OP(_CFFI_OP_NOOP, 758),
/* 1939 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1940 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY const *, EVP_PKEY const *)
/* 1941 */ _CFFI_OP(_CFFI_OP_NOOP, 758),
/* 1942 */ _CFFI_OP(_CFFI_OP_NOOP, 758),
/* 1943 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1944 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY const *, int, int)
/* 1945 */ _CFFI_OP(_CFFI_OP_NOOP, 758),
/* 1946 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1947 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1948 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1949 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY_CTX *)
/* 1950 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 1951 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1952 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY_CTX *, EVP_MD *)
/* 1953 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 1954 */ _CFFI_OP(_CFFI_OP_POINTER, 3707), // EVP_MD *
/* 1955 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1956 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY_CTX *, EVP_MD const *)
/* 1957 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 1958 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 1959 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1960 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY_CTX *, int)
/* 1961 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 1962 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 1963 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1964 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY_CTX *, unsigned char *, size_t *, unsigned char const *, size_t)
/* 1965 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 1966 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 1967 */ _CFFI_OP(_CFFI_OP_NOOP, 1353),
/* 1968 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1969 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1970 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1971 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(EVP_PKEY_CTX *, unsigned char const *, size_t, unsigned char const *, size_t)
/* 1972 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 1973 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1974 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1975 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 1976 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 1977 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1978 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(FILE *, DH const *)
/* 1979 */ _CFFI_OP(_CFFI_OP_NOOP, 178),
/* 1980 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 1981 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1982 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(GENERAL_NAMES *)
/* 1983 */ _CFFI_OP(_CFFI_OP_NOOP, 518),
/* 1984 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1985 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(GENERAL_NAMES *, GENERAL_NAME *)
/* 1986 */ _CFFI_OP(_CFFI_OP_NOOP, 518),
/* 1987 */ _CFFI_OP(_CFFI_OP_NOOP, 1228),
/* 1988 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1989 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(GENERAL_NAMES *, unsigned char * *)
/* 1990 */ _CFFI_OP(_CFFI_OP_NOOP, 518),
/* 1991 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 1992 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1993 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(HMAC_CTX *, HMAC_CTX *)
/* 1994 */ _CFFI_OP(_CFFI_OP_POINTER, 3716), // HMAC_CTX *
/* 1995 */ _CFFI_OP(_CFFI_OP_NOOP, 1994),
/* 1996 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 1997 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(HMAC_CTX *, unsigned char *, unsigned int *)
/* 1998 */ _CFFI_OP(_CFFI_OP_NOOP, 1994),
/* 1999 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2000 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2001 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2002 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(HMAC_CTX *, unsigned char const *, size_t)
/* 2003 */ _CFFI_OP(_CFFI_OP_NOOP, 1994),
/* 2004 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2005 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2006 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2007 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(HMAC_CTX *, void const *, int, EVP_MD const *, ENGINE *)
/* 2008 */ _CFFI_OP(_CFFI_OP_NOOP, 1994),
/* 2009 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 2010 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2011 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2012 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 2013 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2014 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(NETSCAPE_SPKI *, EVP_PKEY *)
/* 2015 */ _CFFI_OP(_CFFI_OP_NOOP, 493),
/* 2016 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2017 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2018 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(NETSCAPE_SPKI *, EVP_PKEY *, EVP_MD const *)
/* 2019 */ _CFFI_OP(_CFFI_OP_NOOP, 493),
/* 2020 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2021 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2022 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2023 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_BASICRESP *)
/* 2024 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 2025 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2026 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_BASICRESP *, X509 *)
/* 2027 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 2028 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2029 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2030 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_BASICRESP *, X509 *, EVP_PKEY *, EVP_MD const *, Cryptography_STACK_OF_X509 *, unsigned long)
/* 2031 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 2032 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2033 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2034 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2035 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 2036 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2037 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2038 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_BASICRESP *, int, void *, int, unsigned long)
/* 2039 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 2040 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2041 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2042 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2043 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2044 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2045 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_BASICRESP *, unsigned char *, int)
/* 2046 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 2047 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2048 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2049 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2050 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_ONEREQ *)
/* 2051 */ _CFFI_OP(_CFFI_OP_NOOP, 554),
/* 2052 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2053 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_REQUEST *)
/* 2054 */ _CFFI_OP(_CFFI_OP_NOOP, 557),
/* 2055 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2056 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_REQUEST *, int, void *, int, unsigned long)
/* 2057 */ _CFFI_OP(_CFFI_OP_NOOP, 557),
/* 2058 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2059 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2060 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2061 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2062 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2063 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_REQUEST *, unsigned char *, int)
/* 2064 */ _CFFI_OP(_CFFI_OP_NOOP, 557),
/* 2065 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2066 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2067 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2068 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_RESPONSE *)
/* 2069 */ _CFFI_OP(_CFFI_OP_NOOP, 549),
/* 2070 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2071 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_SINGLERESP *)
/* 2072 */ _CFFI_OP(_CFFI_OP_NOOP, 798),
/* 2073 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2074 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(OCSP_SINGLERESP *, int *, ASN1_GENERALIZEDTIME * *, ASN1_GENERALIZEDTIME * *, ASN1_GENERALIZEDTIME * *)
/* 2075 */ _CFFI_OP(_CFFI_OP_NOOP, 798),
/* 2076 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 2077 */ _CFFI_OP(_CFFI_OP_NOOP, 14),
/* 2078 */ _CFFI_OP(_CFFI_OP_NOOP, 14),
/* 2079 */ _CFFI_OP(_CFFI_OP_NOOP, 14),
/* 2080 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2081 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(PKCS12 *, char const *, EVP_PKEY * *, X509 * *, Cryptography_STACK_OF_X509 * *)
/* 2082 */ _CFFI_OP(_CFFI_OP_NOOP, 1240),
/* 2083 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2084 */ _CFFI_OP(_CFFI_OP_NOOP, 478),
/* 2085 */ _CFFI_OP(_CFFI_OP_NOOP, 718),
/* 2086 */ _CFFI_OP(_CFFI_OP_POINTER, 210), // Cryptography_STACK_OF_X509 * *
/* 2087 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2088 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(PKCS7 *)
/* 2089 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 2090 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2091 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *, BIO *, int)
/* 2092 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 2093 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 2094 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2095 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2096 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2097 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2098 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2099 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(PKCS7 *, EVP_PKEY *, X509 *, BIO *, int)
/* 2100 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 2101 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2102 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2103 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2104 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2105 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2106 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, BIGNUM *, BIGNUM *)
/* 2107 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2108 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 2109 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 2110 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2111 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, BIGNUM *, BIGNUM *, BIGNUM *)
/* 2112 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2113 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 2114 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 2115 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 2116 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2117 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, BN_CTX *)
/* 2118 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2119 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 2120 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2121 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, int, BIGNUM *, BN_GENCB *)
/* 2122 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2123 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2124 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 2125 */ _CFFI_OP(_CFFI_OP_NOOP, 1496),
/* 2126 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2127 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, unsigned char * *)
/* 2128 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2129 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2130 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2131 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, unsigned char *, unsigned char const *, EVP_MD const *, int)
/* 2132 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2133 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2134 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2135 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2136 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2137 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2138 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA *, unsigned char const *, EVP_MD const *, unsigned char const *, int)
/* 2139 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2140 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2141 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2142 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2143 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2144 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2145 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(RSA const *)
/* 2146 */ _CFFI_OP(_CFFI_OP_NOOP, 1267),
/* 2147 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2148 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SCT *, sct_source_t)
/* 2149 */ _CFFI_OP(_CFFI_OP_POINTER, 3747), // SCT *
/* 2150 */ _CFFI_OP(_CFFI_OP_ENUM, 2), // sct_source_t
/* 2151 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2152 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *)
/* 2153 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2154 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2155 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, EVP_PKEY *)
/* 2156 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2157 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2158 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2159 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, SSL_SESSION *)
/* 2160 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2161 */ _CFFI_OP(_CFFI_OP_POINTER, 3753), // SSL_SESSION *
/* 2162 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2163 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, X509 *)
/* 2164 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2165 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2166 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2167 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, char const *, int)
/* 2168 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2169 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2170 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2171 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2172 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, int)
/* 2173 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2174 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2175 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2176 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, int, void *)
/* 2177 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2178 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2179 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2180 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2181 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *)
/* 2182 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2183 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2184 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2185 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2186 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2187 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2188 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2189 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *)
/* 2190 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2191 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 2192 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2193 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2194 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2195 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2196 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2197 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, unsigned char const * *, unsigned int *, void *)
/* 2198 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2199 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 2200 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2201 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2202 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2203 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, unsigned char const *, int)
/* 2204 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2205 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2206 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2207 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2208 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, unsigned char const *, unsigned int)
/* 2209 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2210 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2211 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2212 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2213 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, void *)
/* 2214 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2215 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2216 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2217 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, void *, int)
/* 2218 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2219 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2220 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2221 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2222 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL *, void const *, int)
/* 2223 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2224 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 2225 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2226 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2227 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL const *)
/* 2228 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 2229 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2230 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL const *, int *, void *)
/* 2231 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 2232 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 2233 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2234 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2235 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL const *, int)
/* 2236 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 2237 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2238 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2239 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CIPHER const *, int *)
/* 2240 */ _CFFI_OP(_CFFI_OP_NOOP, 925),
/* 2241 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 2242 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2243 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *)
/* 2244 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2245 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2246 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, ENGINE *)
/* 2247 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2248 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 2249 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2250 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, EVP_PKEY *)
/* 2251 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2252 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2253 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2254 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, X509 *)
/* 2255 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2256 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2257 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2258 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, char const *)
/* 2259 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2260 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2261 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2262 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, char const *, char const *)
/* 2263 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2264 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2265 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2266 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2267 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, char const *, int)
/* 2268 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2269 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2270 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2271 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2272 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, int)
/* 2273 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2274 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2275 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2276 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, int, unsigned char const *)
/* 2277 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2278 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2279 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2280 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2281 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, int, void *)
/* 2282 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2283 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2284 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2285 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2286 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX *, unsigned char const *, unsigned int)
/* 2287 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2288 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2289 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2290 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2291 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_CTX const *)
/* 2292 */ _CFFI_OP(_CFFI_OP_NOOP, 895),
/* 2293 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2294 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(SSL_SESSION *, unsigned char const *, unsigned int)
/* 2295 */ _CFFI_OP(_CFFI_OP_NOOP, 2161),
/* 2296 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2297 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2298 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2299 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 * *, X509_STORE_CTX *, X509 *)
/* 2300 */ _CFFI_OP(_CFFI_OP_NOOP, 718),
/* 2301 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2302 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2303 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2304 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *)
/* 2305 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2306 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2307 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, ASN1_INTEGER *)
/* 2308 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2309 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 2310 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2311 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, ASN1_OCTET_STRING *)
/* 2312 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2313 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 2314 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2315 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, EVP_PKEY *)
/* 2316 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2317 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2318 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2319 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, EVP_PKEY *, EVP_MD const *)
/* 2320 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2321 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2322 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2323 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2324 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, X509_EXTENSION *, int)
/* 2325 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2326 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 2327 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2328 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2329 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, X509_NAME *)
/* 2330 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2331 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2332 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2333 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, int, int)
/* 2334 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2335 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2336 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2337 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2338 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, int, void *)
/* 2339 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2340 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2341 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2342 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2343 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, long)
/* 2344 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2345 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2346 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2347 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 *, unsigned char * *)
/* 2348 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2349 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2350 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2351 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 const *)
/* 2352 */ _CFFI_OP(_CFFI_OP_NOOP, 751),
/* 2353 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2354 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 const *, EVP_MD const *, unsigned char *, unsigned int *)
/* 2355 */ _CFFI_OP(_CFFI_OP_NOOP, 751),
/* 2356 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2357 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2358 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2359 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2360 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509 const *, X509 const *)
/* 2361 */ _CFFI_OP(_CFFI_OP_NOOP, 751),
/* 2362 */ _CFFI_OP(_CFFI_OP_NOOP, 751),
/* 2363 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2364 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CINF *, unsigned char * *)
/* 2365 */ _CFFI_OP(_CFFI_OP_POINTER, 3764), // X509_CINF *
/* 2366 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2367 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2368 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *)
/* 2369 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2370 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2371 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, ASN1_OCTET_STRING *)
/* 2372 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2373 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 2374 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2375 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, EVP_PKEY *)
/* 2376 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2377 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2378 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2379 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, EVP_PKEY *, EVP_MD const *)
/* 2380 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2381 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2382 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2383 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2384 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, X509_EXTENSION *, int)
/* 2385 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2386 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 2387 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2388 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2389 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, X509_NAME *)
/* 2390 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2391 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2392 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2393 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, X509_REVOKED *)
/* 2394 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2395 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 2396 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2397 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, long)
/* 2398 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2399 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2400 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2401 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL *, unsigned char * *)
/* 2402 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2403 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2404 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2405 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL const *, X509_CRL const *)
/* 2406 */ _CFFI_OP(_CFFI_OP_POINTER, 3765), // X509_CRL const *
/* 2407 */ _CFFI_OP(_CFFI_OP_NOOP, 2406),
/* 2408 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2409 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_CRL_INFO *, unsigned char * *)
/* 2410 */ _CFFI_OP(_CFFI_OP_POINTER, 3766), // X509_CRL_INFO *
/* 2411 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2412 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2413 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_EXTENSION *)
/* 2414 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 2415 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2416 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_EXTENSIONS *)
/* 2417 */ _CFFI_OP(_CFFI_OP_NOOP, 819),
/* 2418 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2419 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_EXTENSIONS *, X509_EXTENSION *)
/* 2420 */ _CFFI_OP(_CFFI_OP_NOOP, 819),
/* 2421 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 2422 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2423 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_EXTENSIONS *, X509_EXTENSION *, int)
/* 2424 */ _CFFI_OP(_CFFI_OP_NOOP, 819),
/* 2425 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 2426 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2427 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2428 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *)
/* 2429 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2430 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2431 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *, ASN1_OBJECT *, int, unsigned char *, int, int, int)
/* 2432 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2433 */ _CFFI_OP(_CFFI_OP_NOOP, 811),
/* 2434 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2435 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2436 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2437 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2438 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2439 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2440 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *, X509_NAME_ENTRY *, int, int)
/* 2441 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2442 */ _CFFI_OP(_CFFI_OP_NOOP, 54),
/* 2443 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2444 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2445 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2446 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *, char const *, int, unsigned char const *, int, int, int)
/* 2447 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2448 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2449 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2450 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2451 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2452 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2453 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2454 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2455 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *, int, int)
/* 2456 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2457 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2458 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2459 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2460 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *, int, int, unsigned char *, int, int, int)
/* 2461 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2462 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2463 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2464 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2465 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2466 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2467 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2468 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2469 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME *, unsigned char * *)
/* 2470 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2471 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2472 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2473 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME const *, X509_NAME const *)
/* 2474 */ _CFFI_OP(_CFFI_OP_POINTER, 3769), // X509_NAME const *
/* 2475 */ _CFFI_OP(_CFFI_OP_NOOP, 2474),
/* 2476 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2477 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_NAME_ENTRY *)
/* 2478 */ _CFFI_OP(_CFFI_OP_NOOP, 54),
/* 2479 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2480 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_OBJECT const *)
/* 2481 */ _CFFI_OP(_CFFI_OP_POINTER, 3771), // X509_OBJECT const *
/* 2482 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2483 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ *, EVP_PKEY *)
/* 2484 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2485 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2486 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2487 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ *, EVP_PKEY *, EVP_MD const *)
/* 2488 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2489 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 2490 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2491 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2492 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ *, X509_EXTENSIONS *)
/* 2493 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2494 */ _CFFI_OP(_CFFI_OP_NOOP, 819),
/* 2495 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2496 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ *, X509_NAME *)
/* 2497 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2498 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 2499 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2500 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ *, long)
/* 2501 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2502 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2503 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2504 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ *, unsigned char * *)
/* 2505 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2506 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2507 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2508 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ const *, EVP_MD const *, unsigned char *, unsigned int *)
/* 2509 */ _CFFI_OP(_CFFI_OP_POINTER, 3772), // X509_REQ const *
/* 2510 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2511 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2512 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2513 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2514 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REQ_INFO *, unsigned char * *)
/* 2515 */ _CFFI_OP(_CFFI_OP_POINTER, 3773), // X509_REQ_INFO *
/* 2516 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2517 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2518 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REVOKED *)
/* 2519 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 2520 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2521 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REVOKED *, ASN1_INTEGER *)
/* 2522 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 2523 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 2524 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2525 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REVOKED *, ASN1_OCTET_STRING *)
/* 2526 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 2527 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 2528 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2529 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REVOKED *, X509_EXTENSION *, int)
/* 2530 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 2531 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 2532 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2533 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2534 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_REVOKED *, int, void *, int, unsigned long)
/* 2535 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 2536 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2537 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2538 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2539 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2540 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2541 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE *)
/* 2542 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2543 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2544 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE *, X509 *)
/* 2545 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2546 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2547 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2548 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE *, X509_CRL *)
/* 2549 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2550 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 2551 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2552 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE *, X509_VERIFY_PARAM *)
/* 2553 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2554 */ _CFFI_OP(_CFFI_OP_POINTER, 3777), // X509_VERIFY_PARAM *
/* 2555 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2556 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE *, char const *, char const *)
/* 2557 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2558 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2559 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2560 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2561 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE *, unsigned long)
/* 2562 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2563 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2564 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2565 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE_CTX *)
/* 2566 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2567 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2568 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE_CTX *, X509_STORE *, X509 *, Cryptography_STACK_OF_X509 *)
/* 2569 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2570 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2571 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2572 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 2573 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2574 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE_CTX *, char const *)
/* 2575 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2576 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2577 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2578 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE_CTX *, int, void *)
/* 2579 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2580 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2581 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2582 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2583 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_STORE_CTX *, void *)
/* 2584 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2585 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2586 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2587 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, ASN1_OBJECT *)
/* 2588 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2589 */ _CFFI_OP(_CFFI_OP_NOOP, 811),
/* 2590 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2591 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, Cryptography_STACK_OF_ASN1_OBJECT *)
/* 2592 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2593 */ _CFFI_OP(_CFFI_OP_NOOP, 47),
/* 2594 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2595 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, char const *)
/* 2596 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2597 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2598 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2599 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, char const *, size_t)
/* 2600 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2601 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2602 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2603 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2604 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, int)
/* 2605 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2606 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2607 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2608 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, unsigned char const *, size_t)
/* 2609 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2610 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2611 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2612 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2613 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM *, unsigned long)
/* 2614 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 2615 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2616 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2617 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(X509_VERIFY_PARAM const *)
/* 2618 */ _CFFI_OP(_CFFI_OP_POINTER, 3777), // X509_VERIFY_PARAM const *
/* 2619 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2620 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char *)
/* 2621 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 2622 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2623 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char *, int, ASN1_OBJECT const *, int)
/* 2624 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 2625 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2626 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 2627 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2628 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2629 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char *, int, int, void *)
/* 2630 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 2631 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2632 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2633 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2634 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2635 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *)
/* 2636 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2637 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2638 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, char const *, char const *)
/* 2639 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2640 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2641 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2642 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2643 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, int)
/* 2644 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2645 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2646 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2647 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, int, unsigned char const *, int, int, EVP_MD const *, int, unsigned char *)
/* 2648 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2649 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2650 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2651 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2652 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2653 */ _CFFI_OP(_CFFI_OP_NOOP, 226),
/* 2654 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2655 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2656 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2657 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, int, unsigned char const *, int, int, int, unsigned char *)
/* 2658 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2659 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2660 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2661 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2662 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2663 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2664 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2665 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2666 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, long)
/* 2667 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2668 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2669 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2670 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, size_t, unsigned char const *, size_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, size_t)
/* 2671 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2672 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2673 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2674 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2675 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24), // uint64_t
/* 2676 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 2677 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 2678 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 2679 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2680 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2681 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2682 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(char const *, unsigned char *, int)
/* 2683 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 2684 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2685 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2686 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2687 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int)
/* 2688 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2689 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2690 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, SSL *, unsigned char const *, long)
/* 2691 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2692 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2693 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2694 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2695 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2696 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, SSL_CTX *, unsigned char const *, long)
/* 2697 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2698 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2699 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2700 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2701 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2702 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, X509_STORE_CTX *)
/* 2703 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2704 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 2705 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2706 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, int)
/* 2707 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2708 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2709 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2710 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, unsigned char const *, int, unsigned char *, unsigned int *, BIGNUM const *, BIGNUM const *, EC_KEY *)
/* 2711 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2712 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2713 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2714 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2715 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2716 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 2717 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 2718 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 2719 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2720 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, unsigned char const *, int, unsigned char *, unsigned int *, DSA *)
/* 2721 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2722 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2723 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2724 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2725 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2726 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 2727 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2728 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, unsigned char const *, int, unsigned char *, unsigned int *, EC_KEY *)
/* 2729 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2730 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2731 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2732 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2733 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 2734 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 2735 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2736 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, unsigned char const *, int, unsigned char const *, int, DSA *)
/* 2737 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2738 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2739 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2740 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2741 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2742 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 2743 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2744 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, unsigned char const *, int, unsigned char const *, int, EC_KEY *)
/* 2745 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2746 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2747 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2748 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2749 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2750 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 2751 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2752 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(int, unsigned char const *, unsigned char *, RSA *, int)
/* 2753 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2754 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2755 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2756 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 2757 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2758 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2759 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(long, void *, CRYPTO_EX_new *, CRYPTO_EX_dup *, CRYPTO_EX_free *)
/* 2760 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2761 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2762 */ _CFFI_OP(_CFFI_OP_POINTER, 3669), // CRYPTO_EX_new *
/* 2763 */ _CFFI_OP(_CFFI_OP_POINTER, 3667), // CRYPTO_EX_dup *
/* 2764 */ _CFFI_OP(_CFFI_OP_POINTER, 3668), // CRYPTO_EX_free *
/* 2765 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2766 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char * *, ASN1_OCTET_STRING *)
/* 2767 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2768 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 2769 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2770 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char * *, unsigned char *, unsigned char const *, unsigned int, unsigned char const *, unsigned int)
/* 2771 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2772 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2773 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2774 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2775 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2776 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 2777 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2778 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char *, BIGNUM const *, DH *)
/* 2779 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2780 */ _CFFI_OP(_CFFI_OP_NOOP, 126),
/* 2781 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 2782 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2783 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char *, int)
/* 2784 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2785 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2786 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2787 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char *, int, unsigned char const *, int, int, unsigned char const *, int)
/* 2788 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2789 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2790 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2791 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2792 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2793 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2794 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2795 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2796 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char *, int, unsigned char const *, int, unsigned char const *, int)
/* 2797 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2798 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2799 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2800 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2801 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2802 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2803 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2804 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char const *, int, AES_KEY *)
/* 2805 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2806 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2807 */ _CFFI_OP(_CFFI_OP_NOOP, 973),
/* 2808 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2809 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned char const *, int, ECDSA_SIG const *, EC_KEY *)
/* 2810 */ _CFFI_OP(_CFFI_OP_NOOP, 148),
/* 2811 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2812 */ _CFFI_OP(_CFFI_OP_NOOP, 1550),
/* 2813 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 2814 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2815 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(unsigned long)
/* 2816 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 2817 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2818 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(void *(*)(size_t, char const *, int), void *(*)(void *, size_t, char const *, int), void(*)(void *, char const *, int))
/* 2819 */ _CFFI_OP(_CFFI_OP_POINTER, 3106), // void *(*)(size_t, char const *, int)
/* 2820 */ _CFFI_OP(_CFFI_OP_POINTER, 3111), // void *(*)(void *, size_t, char const *, int)
/* 2821 */ _CFFI_OP(_CFFI_OP_POINTER, 3605), // void(*)(void *, char const *, int)
/* 2822 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2823 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(void *, size_t, EC_POINT const *, EC_KEY *, void *(*)(void const *, size_t, void *, size_t *))
/* 2824 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2825 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2826 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 2827 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 2828 */ _CFFI_OP(_CFFI_OP_POINTER, 3122), // void *(*)(void const *, size_t, void *, size_t *)
/* 2829 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2830 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int()(void)
/* 2831 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2832 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3396), // int(*()(SSL const *))(int, X509_STORE_CTX *)
/* 2833 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 2834 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2835 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3396), // int(*()(SSL_CTX const *))(int, X509_STORE_CTX *)
/* 2836 */ _CFFI_OP(_CFFI_OP_NOOP, 895),
/* 2837 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2838 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3526), // int(*()(X509_STORE *))(X509 * *, X509_STORE_CTX *, X509 *)
/* 2839 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 2840 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2841 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(ASN1_ENUMERATED *)
/* 2842 */ _CFFI_OP(_CFFI_OP_NOOP, 980),
/* 2843 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2844 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(ASN1_INTEGER *)
/* 2845 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 2846 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2847 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *)
/* 2848 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2849 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2850 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, BUF_MEM * *)
/* 2851 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2852 */ _CFFI_OP(_CFFI_OP_POINTER, 2856), // BUF_MEM * *
/* 2853 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2854 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, BUF_MEM *, int)
/* 2855 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2856 */ _CFFI_OP(_CFFI_OP_POINTER, 3654), // BUF_MEM *
/* 2857 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2858 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2859 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, FILE * *)
/* 2860 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2861 */ _CFFI_OP(_CFFI_OP_POINTER, 178), // FILE * *
/* 2862 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2863 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, FILE *, int)
/* 2864 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2865 */ _CFFI_OP(_CFFI_OP_NOOP, 178),
/* 2866 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2867 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2868 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, char * *)
/* 2869 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2870 */ _CFFI_OP(_CFFI_OP_POINTER, 594), // char * *
/* 2871 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2872 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, char *)
/* 2873 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2874 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 2875 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2876 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, int)
/* 2877 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2878 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2879 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2880 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, int, long, int)
/* 2881 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2882 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2883 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2884 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2885 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2886 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, int, long, void *)
/* 2887 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2888 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2889 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2890 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2891 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2892 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, int, void(*)(BIO *, int, char const *, int, long, long))
/* 2893 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2894 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2895 */ _CFFI_OP(_CFFI_OP_NOOP, 1341),
/* 2896 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2897 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, long)
/* 2898 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2899 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2900 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2901 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, long, int)
/* 2902 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2903 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2904 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2905 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2906 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(BIO *, void *, long)
/* 2907 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2908 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2909 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2910 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2911 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL *)
/* 2912 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2913 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2914 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL *, EVP_PKEY * *)
/* 2915 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2916 */ _CFFI_OP(_CFFI_OP_NOOP, 478),
/* 2917 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2918 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL *, long)
/* 2919 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2920 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2921 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2922 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL *, time_t *, long *)
/* 2923 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2924 */ _CFFI_OP(_CFFI_OP_POINTER, 10), // time_t *
/* 2925 */ _CFFI_OP(_CFFI_OP_POINTER, 41), // long *
/* 2926 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2927 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL *, unsigned char *, int)
/* 2928 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2929 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2930 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 2931 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2932 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL *, unsigned char const * *)
/* 2933 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 2934 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 2935 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2936 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL_CTX *)
/* 2937 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2938 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2939 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL_CTX *, int(*)(SSL *, void *))
/* 2940 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2941 */ _CFFI_OP(_CFFI_OP_POINTER, 2213), // int(*)(SSL *, void *)
/* 2942 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2943 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL_CTX *, long)
/* 2944 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2945 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 2946 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2947 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL_CTX *, void *)
/* 2948 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 2949 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2950 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2951 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(SSL_CTX const *)
/* 2952 */ _CFFI_OP(_CFFI_OP_NOOP, 895),
/* 2953 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2954 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(X509 *)
/* 2955 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 2956 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2957 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // long()(X509_REQ *)
/* 2958 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 2959 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2960 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // point_conversion_form_t()(EC_KEY const *)
/* 2961 */ _CFFI_OP(_CFFI_OP_NOOP, 155),
/* 2962 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2963 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3783), // sct_version_t()(SCT const *)
/* 2964 */ _CFFI_OP(_CFFI_OP_NOOP, 970),
/* 2965 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2966 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(BIO *)
/* 2967 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 2968 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2969 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(EC_GROUP const *, EC_POINT const *, point_conversion_form_t, unsigned char *, size_t, BN_CTX *)
/* 2970 */ _CFFI_OP(_CFFI_OP_NOOP, 141),
/* 2971 */ _CFFI_OP(_CFFI_OP_NOOP, 142),
/* 2972 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 2973 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2974 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2975 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 2976 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2977 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(EC_builtin_curve *, size_t)
/* 2978 */ _CFFI_OP(_CFFI_OP_POINTER, 3697), // EC_builtin_curve *
/* 2979 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2980 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2981 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(SCT const *, unsigned char * *)
/* 2982 */ _CFFI_OP(_CFFI_OP_NOOP, 970),
/* 2983 */ _CFFI_OP(_CFFI_OP_NOOP, 985),
/* 2984 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2985 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(SSL const *, unsigned char *, size_t)
/* 2986 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 2987 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2988 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2989 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2990 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(SSL const *, void *, size_t)
/* 2991 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 2992 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 2993 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2994 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 2995 */ _CFFI_OP(_CFFI_OP_FUNCTION, 956), // size_t()(SSL_SESSION const *, unsigned char *, size_t)
/* 2996 */ _CFFI_OP(_CFFI_OP_NOOP, 1276),
/* 2997 */ _CFFI_OP(_CFFI_OP_NOOP, 975),
/* 2998 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 2999 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3000 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2675), // uint64_t()(SCT const *)
/* 3001 */ _CFFI_OP(_CFFI_OP_NOOP, 970),
/* 3002 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3003 */ _CFFI_OP(_CFFI_OP_FUNCTION, 975), // unsigned char *()(ASN1_OCTET_STRING *)
/* 3004 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 3005 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3006 */ _CFFI_OP(_CFFI_OP_FUNCTION, 975), // unsigned char *()(X509 *, int *)
/* 3007 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3008 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 3009 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3010 */ _CFFI_OP(_CFFI_OP_FUNCTION, 148), // unsigned char const *()(SSL_SESSION const *, unsigned int *)
/* 3011 */ _CFFI_OP(_CFFI_OP_NOOP, 1276),
/* 3012 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 3013 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3014 */ _CFFI_OP(_CFFI_OP_FUNCTION, 213), // unsigned int()(EC_KEY const *)
/* 3015 */ _CFFI_OP(_CFFI_OP_NOOP, 155),
/* 3016 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3017 */ _CFFI_OP(_CFFI_OP_FUNCTION, 213), // unsigned int()(void)
/* 3018 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3019 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL *)
/* 3020 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3021 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3022 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL *, unsigned long)
/* 3023 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3024 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 3025 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3026 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL_CTX *)
/* 3027 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3028 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3029 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL_CTX *, DH *)
/* 3030 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3031 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 3032 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3033 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL_CTX *, EC_KEY *)
/* 3034 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3035 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 3036 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3037 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL_CTX *, X509 *)
/* 3038 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3039 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3040 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3041 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(SSL_CTX *, unsigned long)
/* 3042 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3043 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 3044 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3045 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(X509 *)
/* 3046 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3047 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3048 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(X509_NAME *)
/* 3049 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 3050 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3051 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(X509_VERIFY_PARAM *)
/* 3052 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 3053 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3054 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(char const * *, int *)
/* 3055 */ _CFFI_OP(_CFFI_OP_POINTER, 57), // char const * *
/* 3056 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 3057 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3058 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(char const * *, int *, char const * *, int *)
/* 3059 */ _CFFI_OP(_CFFI_OP_NOOP, 3055),
/* 3060 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 3061 */ _CFFI_OP(_CFFI_OP_NOOP, 3055),
/* 3062 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 3063 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3064 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(int, int, int)
/* 3065 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3066 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3067 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3068 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3069 */ _CFFI_OP(_CFFI_OP_FUNCTION, 935), // unsigned long()(void)
/* 3070 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3071 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(DH *, int)
/* 3072 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 3073 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3074 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3075 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(SSL const *, int)
/* 3076 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 3077 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3078 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3079 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(SSL_CTX const *, int)
/* 3080 */ _CFFI_OP(_CFFI_OP_NOOP, 895),
/* 3081 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3082 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3083 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(X509 *, int)
/* 3084 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3085 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3086 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3087 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(X509 *, int, int *, int *)
/* 3088 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3089 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3090 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 3091 */ _CFFI_OP(_CFFI_OP_NOOP, 1509),
/* 3092 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3093 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(X509V3_CTX *)
/* 3094 */ _CFFI_OP(_CFFI_OP_NOOP, 779),
/* 3095 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3096 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(X509_EXTENSION *)
/* 3097 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 3098 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3099 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(X509_STORE_CTX *, int)
/* 3100 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3101 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3102 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3103 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(size_t)
/* 3104 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 3105 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3106 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(size_t, char const *, int)
/* 3107 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 3108 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3109 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3110 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3111 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(void *, size_t, char const *, int)
/* 3112 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3113 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 3114 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3115 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3116 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3117 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(void *, unsigned char const * *, long)
/* 3118 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3119 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 3120 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 3121 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3122 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(void const *, size_t, void *, size_t *)
/* 3123 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 3124 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 3125 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3126 */ _CFFI_OP(_CFFI_OP_NOOP, 1353),
/* 3127 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3128 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ACCESS_DESCRIPTION *)
/* 3129 */ _CFFI_OP(_CFFI_OP_NOOP, 1394),
/* 3130 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3131 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_ENUMERATED *)
/* 3132 */ _CFFI_OP(_CFFI_OP_NOOP, 980),
/* 3133 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3134 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_GENERALIZEDTIME *)
/* 3135 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 3136 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3137 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_INTEGER *)
/* 3138 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
/* 3139 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3140 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_OBJECT *)
/* 3141 */ _CFFI_OP(_CFFI_OP_NOOP, 811),
/* 3142 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3143 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_OCTET_STRING * *, X509_ALGOR * *, X509 *)
/* 3144 */ _CFFI_OP(_CFFI_OP_POINTER, 13), // ASN1_OCTET_STRING * *
/* 3145 */ _CFFI_OP(_CFFI_OP_POINTER, 3760), // X509_ALGOR * *
/* 3146 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3147 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3148 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_OCTET_STRING *)
/* 3149 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 3150 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3151 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ASN1_UTCTIME *)
/* 3152 */ _CFFI_OP(_CFFI_OP_NOOP, 105),
/* 3153 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3154 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(AUTHORITY_KEYID *)
/* 3155 */ _CFFI_OP(_CFFI_OP_POINTER, 3647), // AUTHORITY_KEYID *
/* 3156 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3157 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(BASIC_CONSTRAINTS *)
/* 3158 */ _CFFI_OP(_CFFI_OP_POINTER, 3648), // BASIC_CONSTRAINTS *
/* 3159 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3160 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(BIGNUM *)
/* 3161 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 3162 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3163 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(BIO *)
/* 3164 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 3165 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3166 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(BIO *, int, char const *, int, long, long)
/* 3167 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 3168 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3169 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3170 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3171 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 3172 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9),
/* 3173 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3174 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(BN_CTX *)
/* 3175 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 3176 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3177 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(CMAC_CTX *)
/* 3178 */ _CFFI_OP(_CFFI_OP_NOOP, 1347),
/* 3179 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3180 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_ACCESS_DESCRIPTION *)
/* 3181 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 3182 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3183 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_ASN1_INTEGER *)
/* 3184 */ _CFFI_OP(_CFFI_OP_NOOP, 24),
/* 3185 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3186 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_ASN1_OBJECT *)
/* 3187 */ _CFFI_OP(_CFFI_OP_NOOP, 47),
/* 3188 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3189 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_DIST_POINT *)
/* 3190 */ _CFFI_OP(_CFFI_OP_NOOP, 310),
/* 3191 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3192 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_DIST_POINT *, void(*)(DIST_POINT *))
/* 3193 */ _CFFI_OP(_CFFI_OP_NOOP, 310),
/* 3194 */ _CFFI_OP(_CFFI_OP_POINTER, 3235), // void(*)(DIST_POINT *)
/* 3195 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3196 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_GENERAL_SUBTREE *)
/* 3197 */ _CFFI_OP(_CFFI_OP_NOOP, 531),
/* 3198 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3199 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_POLICYINFO *)
/* 3200 */ _CFFI_OP(_CFFI_OP_NOOP, 637),
/* 3201 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3202 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_POLICYINFO *, void(*)(POLICYINFO *))
/* 3203 */ _CFFI_OP(_CFFI_OP_NOOP, 637),
/* 3204 */ _CFFI_OP(_CFFI_OP_POINTER, 3349), // void(*)(POLICYINFO *)
/* 3205 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3206 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_POLICYQUALINFO *)
/* 3207 */ _CFFI_OP(_CFFI_OP_NOOP, 643),
/* 3208 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3209 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_SCT *)
/* 3210 */ _CFFI_OP(_CFFI_OP_POINTER, 3678), // Cryptography_STACK_OF_SCT *
/* 3211 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3212 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_X509 *)
/* 3213 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 3214 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3215 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_X509_CRL *)
/* 3216 */ _CFFI_OP(_CFFI_OP_NOOP, 772),
/* 3217 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3218 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(Cryptography_STACK_OF_X509_NAME *)
/* 3219 */ _CFFI_OP(_CFFI_OP_NOOP, 837),
/* 3220 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3221 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DH *)
/* 3222 */ _CFFI_OP(_CFFI_OP_NOOP, 299),
/* 3223 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3224 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DH const *, BIGNUM const * *, BIGNUM const * *)
/* 3225 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 3226 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3227 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3228 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3229 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DH const *, BIGNUM const * *, BIGNUM const * *, BIGNUM const * *)
/* 3230 */ _CFFI_OP(_CFFI_OP_NOOP, 1167),
/* 3231 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3232 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3233 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3234 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3235 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DIST_POINT *)
/* 3236 */ _CFFI_OP(_CFFI_OP_NOOP, 1415),
/* 3237 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3238 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DIST_POINT_NAME *)
/* 3239 */ _CFFI_OP(_CFFI_OP_POINTER, 3689), // DIST_POINT_NAME *
/* 3240 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3241 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DSA *)
/* 3242 */ _CFFI_OP(_CFFI_OP_NOOP, 333),
/* 3243 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3244 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DSA const *, BIGNUM const * *, BIGNUM const * *)
/* 3245 */ _CFFI_OP(_CFFI_OP_NOOP, 1547),
/* 3246 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3247 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3248 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3249 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(DSA const *, BIGNUM const * *, BIGNUM const * *, BIGNUM const * *)
/* 3250 */ _CFFI_OP(_CFFI_OP_NOOP, 1547),
/* 3251 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3252 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3253 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3254 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3255 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ECDSA_SIG *)
/* 3256 */ _CFFI_OP(_CFFI_OP_POINTER, 3692), // ECDSA_SIG *
/* 3257 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3258 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_GROUP *)
/* 3259 */ _CFFI_OP(_CFFI_OP_NOOP, 1554),
/* 3260 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3261 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_GROUP *, int)
/* 3262 */ _CFFI_OP(_CFFI_OP_NOOP, 1554),
/* 3263 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3264 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3265 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_GROUP *, point_conversion_form_t)
/* 3266 */ _CFFI_OP(_CFFI_OP_NOOP, 1554),
/* 3267 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 3268 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3269 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_KEY *)
/* 3270 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 3271 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3272 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_KEY *, int)
/* 3273 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 3274 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3275 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3276 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_KEY *, point_conversion_form_t)
/* 3277 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 3278 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 3279 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3280 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_KEY *, unsigned int)
/* 3281 */ _CFFI_OP(_CFFI_OP_NOOP, 353),
/* 3282 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 3283 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3284 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EC_POINT *)
/* 3285 */ _CFFI_OP(_CFFI_OP_NOOP, 415),
/* 3286 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3287 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(ENGINE *)
/* 3288 */ _CFFI_OP(_CFFI_OP_NOOP, 435),
/* 3289 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3290 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EVP_CIPHER_CTX *)
/* 3291 */ _CFFI_OP(_CFFI_OP_NOOP, 1810),
/* 3292 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3293 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EVP_MD_CTX *)
/* 3294 */ _CFFI_OP(_CFFI_OP_NOOP, 1856),
/* 3295 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3296 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EVP_PKEY *)
/* 3297 */ _CFFI_OP(_CFFI_OP_NOOP, 217),
/* 3298 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3299 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(EVP_PKEY_CTX *)
/* 3300 */ _CFFI_OP(_CFFI_OP_NOOP, 511),
/* 3301 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3302 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(FILE *)
/* 3303 */ _CFFI_OP(_CFFI_OP_NOOP, 178),
/* 3304 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3305 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(GENERAL_NAME *)
/* 3306 */ _CFFI_OP(_CFFI_OP_NOOP, 1228),
/* 3307 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3308 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(GENERAL_NAMES *)
/* 3309 */ _CFFI_OP(_CFFI_OP_NOOP, 518),
/* 3310 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3311 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(GENERAL_NAMES *, void(*)(GENERAL_NAME *))
/* 3312 */ _CFFI_OP(_CFFI_OP_NOOP, 518),
/* 3313 */ _CFFI_OP(_CFFI_OP_POINTER, 3305), // void(*)(GENERAL_NAME *)
/* 3314 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3315 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(HMAC_CTX *)
/* 3316 */ _CFFI_OP(_CFFI_OP_NOOP, 1994),
/* 3317 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3318 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(NAME_CONSTRAINTS *)
/* 3319 */ _CFFI_OP(_CFFI_OP_POINTER, 3717), // NAME_CONSTRAINTS *
/* 3320 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3321 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(NETSCAPE_SPKI *)
/* 3322 */ _CFFI_OP(_CFFI_OP_NOOP, 493),
/* 3323 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3324 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(NOTICEREF *)
/* 3325 */ _CFFI_OP(_CFFI_OP_POINTER, 3719), // NOTICEREF *
/* 3326 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3327 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(OBJ_NAME const *, void *)
/* 3328 */ _CFFI_OP(_CFFI_OP_POINTER, 3720), // OBJ_NAME const *
/* 3329 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3330 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3331 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(OCSP_BASICRESP *)
/* 3332 */ _CFFI_OP(_CFFI_OP_NOOP, 572),
/* 3333 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3334 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(OCSP_REQUEST *)
/* 3335 */ _CFFI_OP(_CFFI_OP_NOOP, 557),
/* 3336 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3337 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(OTHERNAME *)
/* 3338 */ _CFFI_OP(_CFFI_OP_POINTER, 3727), // OTHERNAME *
/* 3339 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3340 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(PKCS12 *)
/* 3341 */ _CFFI_OP(_CFFI_OP_NOOP, 1240),
/* 3342 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3343 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(PKCS7 *)
/* 3344 */ _CFFI_OP(_CFFI_OP_NOOP, 182),
/* 3345 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3346 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(PKCS8_PRIV_KEY_INFO *)
/* 3347 */ _CFFI_OP(_CFFI_OP_NOOP, 496),
/* 3348 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3349 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(POLICYINFO *)
/* 3350 */ _CFFI_OP(_CFFI_OP_NOOP, 1429),
/* 3351 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3352 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(POLICYQUALINFO *)
/* 3353 */ _CFFI_OP(_CFFI_OP_NOOP, 1436),
/* 3354 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3355 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(POLICY_CONSTRAINTS *)
/* 3356 */ _CFFI_OP(_CFFI_OP_POINTER, 3743), // POLICY_CONSTRAINTS *
/* 3357 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3358 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(RSA *)
/* 3359 */ _CFFI_OP(_CFFI_OP_NOOP, 672),
/* 3360 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3361 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(RSA const *, BIGNUM const * *, BIGNUM const * *)
/* 3362 */ _CFFI_OP(_CFFI_OP_NOOP, 1267),
/* 3363 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3364 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3365 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3366 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(RSA const *, BIGNUM const * *, BIGNUM const * *, BIGNUM const * *)
/* 3367 */ _CFFI_OP(_CFFI_OP_NOOP, 1267),
/* 3368 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3369 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3370 */ _CFFI_OP(_CFFI_OP_NOOP, 1619),
/* 3371 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3372 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *)
/* 3373 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3374 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3375 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *, BIO *, BIO *)
/* 3376 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3377 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 3378 */ _CFFI_OP(_CFFI_OP_NOOP, 160),
/* 3379 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3380 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *, char *)
/* 3381 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3382 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 3383 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3384 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *, int(*)(SSL *, void *), void *)
/* 3385 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3386 */ _CFFI_OP(_CFFI_OP_NOOP, 2941),
/* 3387 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3388 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3389 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *, int)
/* 3390 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3391 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3392 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3393 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *, int, int(*)(int, X509_STORE_CTX *))
/* 3394 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3395 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3396 */ _CFFI_OP(_CFFI_OP_POINTER, 2702), // int(*)(int, X509_STORE_CTX *)
/* 3397 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3398 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL *, void(*)(SSL const *, int, int))
/* 3399 */ _CFFI_OP(_CFFI_OP_NOOP, 230),
/* 3400 */ _CFFI_OP(_CFFI_OP_POINTER, 3402), // void(*)(SSL const *, int, int)
/* 3401 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3402 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL const *, int, int)
/* 3403 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 3404 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3405 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3406 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3407 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL const *, unsigned char const * *, unsigned int *)
/* 3408 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 3409 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 3410 */ _CFFI_OP(_CFFI_OP_NOOP, 1871),
/* 3411 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3412 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *)
/* 3413 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3414 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3415 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, Cryptography_STACK_OF_X509_NAME *)
/* 3416 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3417 */ _CFFI_OP(_CFFI_OP_NOOP, 837),
/* 3418 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3419 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, X509_STORE *)
/* 3420 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3421 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 3422 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3423 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *), void *)
/* 3424 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3425 */ _CFFI_OP(_CFFI_OP_POINTER, 2181), // int(*)(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *)
/* 3426 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3427 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3428 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *), void *)
/* 3429 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3430 */ _CFFI_OP(_CFFI_OP_POINTER, 2189), // int(*)(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *)
/* 3431 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3432 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3433 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(SSL *, unsigned char const * *, unsigned int *, void *), void *)
/* 3434 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3435 */ _CFFI_OP(_CFFI_OP_POINTER, 2197), // int(*)(SSL *, unsigned char const * *, unsigned int *, void *)
/* 3436 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3437 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3438 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(SSL *, void *), void *)
/* 3439 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3440 */ _CFFI_OP(_CFFI_OP_NOOP, 2941),
/* 3441 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3442 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3443 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(SSL const *, int *, void *))
/* 3444 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3445 */ _CFFI_OP(_CFFI_OP_POINTER, 2230), // int(*)(SSL const *, int *, void *)
/* 3446 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3447 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(X509_STORE_CTX *, void *), void *)
/* 3448 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3449 */ _CFFI_OP(_CFFI_OP_POINTER, 2583), // int(*)(X509_STORE_CTX *, void *)
/* 3450 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3451 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3452 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int(*)(char *, int, int, void *))
/* 3453 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3454 */ _CFFI_OP(_CFFI_OP_NOOP, 290),
/* 3455 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3456 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int)
/* 3457 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3458 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3459 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3460 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, int, int(*)(int, X509_STORE_CTX *))
/* 3461 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3462 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3463 */ _CFFI_OP(_CFFI_OP_NOOP, 3396),
/* 3464 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3465 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, void *)
/* 3466 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3467 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3468 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3469 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_CTX *, void(*)(SSL const *, int, int))
/* 3470 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3471 */ _CFFI_OP(_CFFI_OP_NOOP, 3400),
/* 3472 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3473 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(SSL_SESSION *)
/* 3474 */ _CFFI_OP(_CFFI_OP_NOOP, 2161),
/* 3475 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3476 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(USERNOTICE *)
/* 3477 */ _CFFI_OP(_CFFI_OP_POINTER, 3755), // USERNOTICE *
/* 3478 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3479 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509 *)
/* 3480 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3481 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3482 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509V3_CTX *, X509 *, X509 *, X509_REQ *, X509_CRL *, int)
/* 3483 */ _CFFI_OP(_CFFI_OP_NOOP, 779),
/* 3484 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3485 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3486 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 3487 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 3488 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3489 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3490 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_CRL *)
/* 3491 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 3492 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3493 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_CRL const *, ASN1_OCTET_STRING const * *, X509_ALGOR const * *)
/* 3494 */ _CFFI_OP(_CFFI_OP_NOOP, 2406),
/* 3495 */ _CFFI_OP(_CFFI_OP_POINTER, 3641), // ASN1_OCTET_STRING const * *
/* 3496 */ _CFFI_OP(_CFFI_OP_POINTER, 3761), // X509_ALGOR const * *
/* 3497 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3498 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_EXTENSION *)
/* 3499 */ _CFFI_OP(_CFFI_OP_NOOP, 51),
/* 3500 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3501 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_EXTENSIONS *)
/* 3502 */ _CFFI_OP(_CFFI_OP_NOOP, 819),
/* 3503 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3504 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_NAME *)
/* 3505 */ _CFFI_OP(_CFFI_OP_NOOP, 847),
/* 3506 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3507 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_NAME_ENTRY *)
/* 3508 */ _CFFI_OP(_CFFI_OP_NOOP, 54),
/* 3509 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3510 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_REQ *)
/* 3511 */ _CFFI_OP(_CFFI_OP_NOOP, 502),
/* 3512 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3513 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_REQ const *, ASN1_OCTET_STRING const * *, X509_ALGOR const * *)
/* 3514 */ _CFFI_OP(_CFFI_OP_NOOP, 2509),
/* 3515 */ _CFFI_OP(_CFFI_OP_NOOP, 3495),
/* 3516 */ _CFFI_OP(_CFFI_OP_NOOP, 3496),
/* 3517 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3518 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_REVOKED *)
/* 3519 */ _CFFI_OP(_CFFI_OP_NOOP, 823),
/* 3520 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3521 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE *)
/* 3522 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 3523 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3524 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE *, int(*)(X509 * *, X509_STORE_CTX *, X509 *))
/* 3525 */ _CFFI_OP(_CFFI_OP_NOOP, 278),
/* 3526 */ _CFFI_OP(_CFFI_OP_POINTER, 2299), // int(*)(X509 * *, X509_STORE_CTX *, X509 *)
/* 3527 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3528 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *)
/* 3529 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3530 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3531 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *, Cryptography_STACK_OF_X509 *)
/* 3532 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3533 */ _CFFI_OP(_CFFI_OP_NOOP, 210),
/* 3534 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3535 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *, Cryptography_STACK_OF_X509_CRL *)
/* 3536 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3537 */ _CFFI_OP(_CFFI_OP_NOOP, 772),
/* 3538 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3539 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *, X509 *)
/* 3540 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3541 */ _CFFI_OP(_CFFI_OP_NOOP, 28),
/* 3542 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3543 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *, X509_VERIFY_PARAM *)
/* 3544 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3545 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 3546 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3547 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *, int(*)(int, X509_STORE_CTX *))
/* 3548 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3549 */ _CFFI_OP(_CFFI_OP_NOOP, 3396),
/* 3550 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3551 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_STORE_CTX *, int)
/* 3552 */ _CFFI_OP(_CFFI_OP_NOOP, 258),
/* 3553 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3554 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3555 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_VERIFY_PARAM *)
/* 3556 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 3557 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3558 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_VERIFY_PARAM *, int)
/* 3559 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 3560 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3561 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3562 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_VERIFY_PARAM *, time_t)
/* 3563 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 3564 */ _CFFI_OP(_CFFI_OP_NOOP, 10),
/* 3565 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3566 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(X509_VERIFY_PARAM *, unsigned int)
/* 3567 */ _CFFI_OP(_CFFI_OP_NOOP, 2554),
/* 3568 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 3569 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3570 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(char const *)
/* 3571 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3572 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3573 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(int, ...)
/* 3574 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3575 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 1),
/* 3576 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(int, int, char const *, int)
/* 3577 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3578 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3579 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3580 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3581 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3582 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(int, int, int, char const *, int)
/* 3583 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3584 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3585 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3586 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3587 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3588 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3589 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(int, void(*)(OBJ_NAME const *, void *), void *)
/* 3590 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3591 */ _CFFI_OP(_CFFI_OP_POINTER, 3327), // void(*)(OBJ_NAME const *, void *)
/* 3592 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3593 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3594 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(unsigned int)
/* 3595 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 3596 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3597 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(unsigned long, char *, size_t)
/* 3598 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 10),
/* 3599 */ _CFFI_OP(_CFFI_OP_NOOP, 594),
/* 3600 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 3601 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3602 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(void *)
/* 3603 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3604 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3605 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(void *, char const *, int)
/* 3606 */ _CFFI_OP(_CFFI_OP_NOOP, 92),
/* 3607 */ _CFFI_OP(_CFFI_OP_NOOP, 57),
/* 3608 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3609 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3610 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(void const *, int)
/* 3611 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 3612 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3613 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3614 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(void const *, int, double)
/* 3615 */ _CFFI_OP(_CFFI_OP_NOOP, 1052),
/* 3616 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 3617 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
/* 3618 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3619 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(void(*)(int, int, char const *, int))
/* 3620 */ _CFFI_OP(_CFFI_OP_POINTER, 3576), // void(*)(int, int, char const *, int)
/* 3621 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3622 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3795), // void()(void)
/* 3623 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3624 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3400), // void(*()(SSL const *))(SSL const *, int, int)
/* 3625 */ _CFFI_OP(_CFFI_OP_NOOP, 186),
/* 3626 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3627 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3400), // void(*()(SSL_CTX *))(SSL const *, int, int)
/* 3628 */ _CFFI_OP(_CFFI_OP_NOOP, 684),
/* 3629 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3630 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3620), // void(*()(void))(int, int, char const *, int)
/* 3631 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 3632 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 8), // ACCESS_DESCRIPTION
/* 3633 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 136), // AES_KEY
/* 3634 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 9), // ASN1_ENUMERATED
/* 3635 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 10), // ASN1_GENERALIZEDTIME
/* 3636 */ _CFFI_OP(_CFFI_OP_POINTER, 3637), // ASN1_INTEGER const *
/* 3637 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 11), // ASN1_INTEGER
/* 3638 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 12), // ASN1_ITEM
/* 3639 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 13), // ASN1_ITEM_EXP
/* 3640 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 14), // ASN1_OBJECT
/* 3641 */ _CFFI_OP(_CFFI_OP_POINTER, 3642), // ASN1_OCTET_STRING const *
/* 3642 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 137), // ASN1_OCTET_STRING
/* 3643 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 15), // ASN1_TYPE
/* 3644 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 16), // ASN1_UTCTIME
/* 3645 */ _CFFI_OP(_CFFI_OP_POINTER, 3646), // ASN1_VALUE *
/* 3646 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 17), // ASN1_VALUE
/* 3647 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 18), // AUTHORITY_KEYID
/* 3648 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 19), // BASIC_CONSTRAINTS
/* 3649 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 20), // BIGNUM
/* 3650 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 138), // BIO
/* 3651 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 21), // BIO_METHOD
/* 3652 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 22), // BN_CTX
/* 3653 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 23), // BN_GENCB
/* 3654 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 24), // BUF_MEM
/* 3655 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 25), // CMAC_CTX
/* 3656 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 26), // CMS_CertificateChoices
/* 3657 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 27), // CMS_ContentInfo
/* 3658 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 28), // CMS_Receipt
/* 3659 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 29), // CMS_ReceiptRequest
/* 3660 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 30), // CMS_RecipientInfo
/* 3661 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 31), // CMS_RevocationInfoChoice
/* 3662 */ _CFFI_OP(_CFFI_OP_POINTER, 3663), // CMS_SignerInfo *
/* 3663 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 32), // CMS_SignerInfo
/* 3664 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 33), // COMP_METHOD
/* 3665 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 34), // CONF
/* 3666 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 35), // CRYPTOGRAPHY_PASSWORD_DATA
/* 3667 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 36), // CRYPTO_EX_dup
/* 3668 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 37), // CRYPTO_EX_free
/* 3669 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 38), // CRYPTO_EX_new
/* 3670 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 39), // Cryptography_LHASH_OF_CONF_VALUE
/* 3671 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 40), // Cryptography_STACK_OF_ACCESS_DESCRIPTION
/* 3672 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 41), // Cryptography_STACK_OF_ASN1_INTEGER
/* 3673 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 42), // Cryptography_STACK_OF_ASN1_OBJECT
/* 3674 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 43), // Cryptography_STACK_OF_DIST_POINT
/* 3675 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 44), // Cryptography_STACK_OF_GENERAL_SUBTREE
/* 3676 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 45), // Cryptography_STACK_OF_POLICYINFO
/* 3677 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 46), // Cryptography_STACK_OF_POLICYQUALINFO
/* 3678 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 47), // Cryptography_STACK_OF_SCT
/* 3679 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 48), // Cryptography_STACK_OF_SSL_CIPHER
/* 3680 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 49), // Cryptography_STACK_OF_X509
/* 3681 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 50), // Cryptography_STACK_OF_X509_CRL
/* 3682 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 51), // Cryptography_STACK_OF_X509_NAME
/* 3683 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 52), // Cryptography_STACK_OF_X509_NAME_ENTRY
/* 3684 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 53), // Cryptography_STACK_OF_X509_OBJECT
/* 3685 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 54), // Cryptography_STACK_OF_X509_REVOKED
/* 3686 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 55), // DH
/* 3687 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 56), // DH_METHOD
/* 3688 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 57), // DIST_POINT
/* 3689 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 58), // DIST_POINT_NAME
/* 3690 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 59), // DSA
/* 3691 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 60), // DSA_METHOD
/* 3692 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 61), // ECDSA_SIG
/* 3693 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 62), // EC_GROUP
/* 3694 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 63), // EC_KEY
/* 3695 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 64), // EC_METHOD
/* 3696 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 65), // EC_POINT
/* 3697 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 66), // EC_builtin_curve
/* 3698 */ _CFFI_OP(_CFFI_OP_POINTER, 3699), // EDIPARTYNAME *
/* 3699 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 67), // EDIPARTYNAME
/* 3700 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 68), // ENGINE
/* 3701 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 69), // ENGINE_CMD_DEFN
/* 3702 */ _CFFI_OP(_CFFI_OP_POINTER, 3703), // ERR_STATE *
/* 3703 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 70), // ERR_STATE
/* 3704 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 134), // ERR_STRING_DATA
/* 3705 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 71), // EVP_CIPHER
/* 3706 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 72), // EVP_CIPHER_CTX
/* 3707 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 73), // EVP_MD
/* 3708 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 74), // EVP_MD_CTX
/* 3709 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 75), // EVP_PKEY
/* 3710 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 76), // EVP_PKEY_CTX
/* 3711 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 77), // EXTENDED_KEY_USAGE
/* 3712 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 135), // FILE
/* 3713 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 78), // GENERAL_NAME
/* 3714 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 139), // GENERAL_NAMES
/* 3715 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 79), // GENERAL_SUBTREE
/* 3716 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 80), // HMAC_CTX
/* 3717 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 81), // NAME_CONSTRAINTS
/* 3718 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 82), // NETSCAPE_SPKI
/* 3719 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 83), // NOTICEREF
/* 3720 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 84), // OBJ_NAME
/* 3721 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 85), // OCSP_BASICRESP
/* 3722 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 86), // OCSP_CERTID
/* 3723 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 87), // OCSP_ONEREQ
/* 3724 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 88), // OCSP_REQUEST
/* 3725 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 89), // OCSP_RESPONSE
/* 3726 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 90), // OCSP_SINGLERESP
/* 3727 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 91), // OTHERNAME
/* 3728 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 92), // PKCS12
/* 3729 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 93), // PKCS7
/* 3730 */ _CFFI_OP(_CFFI_OP_POINTER, 3731), // PKCS7_DIGEST *
/* 3731 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 94), // PKCS7_DIGEST
/* 3732 */ _CFFI_OP(_CFFI_OP_POINTER, 3733), // PKCS7_ENCRYPT *
/* 3733 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 95), // PKCS7_ENCRYPT
/* 3734 */ _CFFI_OP(_CFFI_OP_POINTER, 3735), // PKCS7_ENVELOPE *
/* 3735 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 96), // PKCS7_ENVELOPE
/* 3736 */ _CFFI_OP(_CFFI_OP_POINTER, 3737), // PKCS7_SIGNED *
/* 3737 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 97), // PKCS7_SIGNED
/* 3738 */ _CFFI_OP(_CFFI_OP_POINTER, 3739), // PKCS7_SIGN_ENVELOPE *
/* 3739 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 98), // PKCS7_SIGN_ENVELOPE
/* 3740 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 99), // PKCS8_PRIV_KEY_INFO
/* 3741 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 100), // POLICYINFO
/* 3742 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 101), // POLICYQUALINFO
/* 3743 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 102), // POLICY_CONSTRAINTS
/* 3744 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 103), // RAND_METHOD
/* 3745 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 104), // RSA
/* 3746 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 105), // RSA_METHOD
/* 3747 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 106), // SCT
/* 3748 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 107), // SSL
/* 3749 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 108), // SSL_CIPHER
/* 3750 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 109), // SSL_CTX
/* 3751 */ _CFFI_OP(_CFFI_OP_POINTER, 3752), // SSL_METHOD const *
/* 3752 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 110), // SSL_METHOD
/* 3753 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 111), // SSL_SESSION
/* 3754 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 112), // UI_METHOD
/* 3755 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 113), // USERNOTICE
/* 3756 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 114), // X509
/* 3757 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 115), // X509V3_CTX
/* 3758 */ _CFFI_OP(_CFFI_OP_POINTER, 3759), // X509V3_EXT_METHOD const *
/* 3759 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 116), // X509V3_EXT_METHOD
/* 3760 */ _CFFI_OP(_CFFI_OP_POINTER, 3762), // X509_ALGOR *
/* 3761 */ _CFFI_OP(_CFFI_OP_POINTER, 3762), // X509_ALGOR const *
/* 3762 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 117), // X509_ALGOR
/* 3763 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 118), // X509_ATTRIBUTE
/* 3764 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 119), // X509_CINF
/* 3765 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 120), // X509_CRL
/* 3766 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 121), // X509_CRL_INFO
/* 3767 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 122), // X509_EXTENSION
/* 3768 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 123), // X509_EXTENSIONS
/* 3769 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 124), // X509_NAME
/* 3770 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 125), // X509_NAME_ENTRY
/* 3771 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 126), // X509_OBJECT
/* 3772 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 127), // X509_REQ
/* 3773 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 128), // X509_REQ_INFO
/* 3774 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 129), // X509_REVOKED
/* 3775 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 130), // X509_STORE
/* 3776 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 131), // X509_STORE_CTX
/* 3777 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 132), // X509_VERIFY_PARAM
/* 3778 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 133), // bio_st
/* 3779 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 3780 */ _CFFI_OP(_CFFI_OP_ENUM, 0), // ct_log_entry_type_t
/* 3781 */ _CFFI_OP(_CFFI_OP_POINTER, 2783), // int(*)(unsigned char *, int)
/* 3782 */ _CFFI_OP(_CFFI_OP_POINTER, 2830), // int(*)(void)
/* 3783 */ _CFFI_OP(_CFFI_OP_ENUM, 3), // sct_version_t
/* 3784 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // struct $$ENGINE_CIPHERS_PTR
/* 3785 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // struct $$ENGINE_CTRL_FUNC_PTR
/* 3786 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // struct $$ENGINE_DIGESTS_PTR
/* 3787 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // struct $$ENGINE_LOAD_KEY_PTR
/* 3788 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // union $1
/* 3789 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // union $2
/* 3790 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 6), // union $3
/* 3791 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 7), // union $4
/* 3792 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 4), // unsigned char
/* 3793 */ _CFFI_OP(_CFFI_OP_POINTER, 3117), // void *(*)(void *, unsigned char const * *, long)
/* 3794 */ _CFFI_OP(_CFFI_OP_POINTER, 3573), // void(*)(int, ...)
/* 3795 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_ACCESS_DESCRIPTION(ACCESS_DESCRIPTION *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OBJECT * *tmp = &p->method; (void)tmp; }
  { GENERAL_NAME * *tmp = &p->location; (void)tmp; }
}
struct _cffi_align_typedef_ACCESS_DESCRIPTION { char x; ACCESS_DESCRIPTION y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_AUTHORITY_KEYID(AUTHORITY_KEYID *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OCTET_STRING * *tmp = &p->keyid; (void)tmp; }
  { GENERAL_NAMES * *tmp = &p->issuer; (void)tmp; }
  { ASN1_INTEGER * *tmp = &p->serial; (void)tmp; }
}
struct _cffi_align_typedef_AUTHORITY_KEYID { char x; AUTHORITY_KEYID y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->ca) | 0);  /* check that 'BASIC_CONSTRAINTS.ca' is an integer */
  { ASN1_INTEGER * *tmp = &p->pathlen; (void)tmp; }
}
struct _cffi_align_typedef_BASIC_CONSTRAINTS { char x; BASIC_CONSTRAINTS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CRYPTOGRAPHY_PASSWORD_DATA(CRYPTOGRAPHY_PASSWORD_DATA *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char * *tmp = &p->password; (void)tmp; }
  (void)((p->length) | 0);  /* check that 'CRYPTOGRAPHY_PASSWORD_DATA.length' is an integer */
  (void)((p->called) | 0);  /* check that 'CRYPTOGRAPHY_PASSWORD_DATA.called' is an integer */
  (void)((p->error) | 0);  /* check that 'CRYPTOGRAPHY_PASSWORD_DATA.error' is an integer */
  (void)((p->maxsize) | 0);  /* check that 'CRYPTOGRAPHY_PASSWORD_DATA.maxsize' is an integer */
}
struct _cffi_align_typedef_CRYPTOGRAPHY_PASSWORD_DATA { char x; CRYPTOGRAPHY_PASSWORD_DATA y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_DIST_POINT(DIST_POINT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { DIST_POINT_NAME * *tmp = &p->distpoint; (void)tmp; }
  { ASN1_OCTET_STRING * *tmp = &p->reasons; (void)tmp; }
  { GENERAL_NAMES * *tmp = &p->CRLissuer; (void)tmp; }
}
struct _cffi_align_typedef_DIST_POINT { char x; DIST_POINT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_DIST_POINT_NAME(DIST_POINT_NAME *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->type) | 0);  /* check that 'DIST_POINT_NAME.type' is an integer */
  /* cannot generate 'union $2' in field 'name': unknown type name */
}
struct _cffi_align_typedef_DIST_POINT_NAME { char x; DIST_POINT_NAME y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EC_builtin_curve(EC_builtin_curve *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nid) | 0);  /* check that 'EC_builtin_curve.nid' is an integer */
  { char const * *tmp = &p->comment; (void)tmp; }
}
struct _cffi_align_typedef_EC_builtin_curve { char x; EC_builtin_curve y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EDIPARTYNAME(EDIPARTYNAME *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
}
struct _cffi_align_typedef_EDIPARTYNAME { char x; EDIPARTYNAME y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_GENERAL_NAME(GENERAL_NAME *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->type) | 0);  /* check that 'GENERAL_NAME.type' is an integer */
  /* cannot generate 'union $1' in field 'd': unknown type name */
}
struct _cffi_align_typedef_GENERAL_NAME { char x; GENERAL_NAME y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_GENERAL_SUBTREE(GENERAL_SUBTREE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { GENERAL_NAME * *tmp = &p->base; (void)tmp; }
  { ASN1_INTEGER * *tmp = &p->minimum; (void)tmp; }
  { ASN1_INTEGER * *tmp = &p->maximum; (void)tmp; }
}
struct _cffi_align_typedef_GENERAL_SUBTREE { char x; GENERAL_SUBTREE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_NAME_CONSTRAINTS(NAME_CONSTRAINTS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { Cryptography_STACK_OF_GENERAL_SUBTREE * *tmp = &p->permittedSubtrees; (void)tmp; }
  { Cryptography_STACK_OF_GENERAL_SUBTREE * *tmp = &p->excludedSubtrees; (void)tmp; }
}
struct _cffi_align_typedef_NAME_CONSTRAINTS { char x; NAME_CONSTRAINTS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_NOTICEREF(NOTICEREF *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OCTET_STRING * *tmp = &p->organization; (void)tmp; }
  { Cryptography_STACK_OF_ASN1_INTEGER * *tmp = &p->noticenos; (void)tmp; }
}
struct _cffi_align_typedef_NOTICEREF { char x; NOTICEREF y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_OBJ_NAME(OBJ_NAME *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->type) | 0);  /* check that 'OBJ_NAME.type' is an integer */
  (void)((p->alias) | 0);  /* check that 'OBJ_NAME.alias' is an integer */
  { char const * *tmp = &p->name; (void)tmp; }
  { char const * *tmp = &p->data; (void)tmp; }
}
struct _cffi_align_typedef_OBJ_NAME { char x; OBJ_NAME y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_OTHERNAME(OTHERNAME *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OBJECT * *tmp = &p->type_id; (void)tmp; }
  { ASN1_TYPE * *tmp = &p->value; (void)tmp; }
}
struct _cffi_align_typedef_OTHERNAME { char x; OTHERNAME y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_PKCS7(PKCS7 *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OBJECT * *tmp = &p->type; (void)tmp; }
  /* cannot generate 'union $4' in field 'd': unknown type name */
}
struct _cffi_align_typedef_PKCS7 { char x; PKCS7 y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_PKCS7_SIGNED(PKCS7_SIGNED *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { Cryptography_STACK_OF_X509 * *tmp = &p->cert; (void)tmp; }
  { Cryptography_STACK_OF_X509_CRL * *tmp = &p->crl; (void)tmp; }
}
struct _cffi_align_typedef_PKCS7_SIGNED { char x; PKCS7_SIGNED y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { Cryptography_STACK_OF_X509 * *tmp = &p->cert; (void)tmp; }
  { Cryptography_STACK_OF_X509_CRL * *tmp = &p->crl; (void)tmp; }
}
struct _cffi_align_typedef_PKCS7_SIGN_ENVELOPE { char x; PKCS7_SIGN_ENVELOPE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_POLICYINFO(POLICYINFO *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OBJECT * *tmp = &p->policyid; (void)tmp; }
  { Cryptography_STACK_OF_POLICYQUALINFO * *tmp = &p->qualifiers; (void)tmp; }
}
struct _cffi_align_typedef_POLICYINFO { char x; POLICYINFO y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_POLICYQUALINFO(POLICYQUALINFO *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OBJECT * *tmp = &p->pqualid; (void)tmp; }
  /* cannot generate 'union $3' in field 'd': unknown type name */
}
struct _cffi_align_typedef_POLICYQUALINFO { char x; POLICYQUALINFO y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_POLICY_CONSTRAINTS(POLICY_CONSTRAINTS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_INTEGER * *tmp = &p->requireExplicitPolicy; (void)tmp; }
  { ASN1_INTEGER * *tmp = &p->inhibitPolicyMapping; (void)tmp; }
}
struct _cffi_align_typedef_POLICY_CONSTRAINTS { char x; POLICY_CONSTRAINTS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_RAND_METHOD(RAND_METHOD *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { int(* *tmp)(unsigned char *, int) = &p->bytes; (void)tmp; }
  { int(* *tmp)(unsigned char *, int) = &p->pseudorand; (void)tmp; }
  { int(* *tmp)(void) = &p->status; (void)tmp; }
}
struct _cffi_align_typedef_RAND_METHOD { char x; RAND_METHOD y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_USERNOTICE(USERNOTICE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { NOTICEREF * *tmp = &p->noticeref; (void)tmp; }
  { ASN1_OCTET_STRING * *tmp = &p->exptext; (void)tmp; }
}
struct _cffi_align_typedef_USERNOTICE { char x; USERNOTICE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_X509V3_CTX(X509V3_CTX *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { X509 * *tmp = &p->issuer_cert; (void)tmp; }
  { X509 * *tmp = &p->subject_cert; (void)tmp; }
}
struct _cffi_align_typedef_X509V3_CTX { char x; X509V3_CTX y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_X509V3_EXT_METHOD(X509V3_EXT_METHOD *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_ITEM_EXP * *tmp = &p->it; (void)tmp; }
  { void *(* *tmp)(void *, unsigned char const * *, long) = &p->d2i; (void)tmp; }
}
struct _cffi_align_typedef_X509V3_EXT_METHOD { char x; X509V3_EXT_METHOD y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_X509_ALGOR(X509_ALGOR *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { ASN1_OBJECT * *tmp = &p->algorithm; (void)tmp; }
}
struct _cffi_align_typedef_X509_ALGOR { char x; X509_ALGOR y; };

static int _cffi_const_CT_LOG_ENTRY_TYPE_NOT_SET(unsigned long long *o)
{
  int n = (CT_LOG_ENTRY_TYPE_NOT_SET) <= 0;
  *o = (unsigned long long)((CT_LOG_ENTRY_TYPE_NOT_SET) | 0);  /* check that CT_LOG_ENTRY_TYPE_NOT_SET is an integer */
  return n;
}

static int _cffi_const_CT_LOG_ENTRY_TYPE_X509(unsigned long long *o)
{
  int n = (CT_LOG_ENTRY_TYPE_X509) <= 0;
  *o = (unsigned long long)((CT_LOG_ENTRY_TYPE_X509) | 0);  /* check that CT_LOG_ENTRY_TYPE_X509 is an integer */
  return n;
}

static int _cffi_const_CT_LOG_ENTRY_TYPE_PRECERT(unsigned long long *o)
{
  int n = (CT_LOG_ENTRY_TYPE_PRECERT) <= 0;
  *o = (unsigned long long)((CT_LOG_ENTRY_TYPE_PRECERT) | 0);  /* check that CT_LOG_ENTRY_TYPE_PRECERT is an integer */
  return n;
}

static int _cffi_const_POINT_CONVERSION_COMPRESSED(unsigned long long *o)
{
  int n = (POINT_CONVERSION_COMPRESSED) <= 0;
  *o = (unsigned long long)((POINT_CONVERSION_COMPRESSED) | 0);  /* check that POINT_CONVERSION_COMPRESSED is an integer */
  return n;
}

static int _cffi_const_POINT_CONVERSION_UNCOMPRESSED(unsigned long long *o)
{
  int n = (POINT_CONVERSION_UNCOMPRESSED) <= 0;
  *o = (unsigned long long)((POINT_CONVERSION_UNCOMPRESSED) | 0);  /* check that POINT_CONVERSION_UNCOMPRESSED is an integer */
  return n;
}

static int _cffi_const_POINT_CONVERSION_HYBRID(unsigned long long *o)
{
  int n = (POINT_CONVERSION_HYBRID) <= 0;
  *o = (unsigned long long)((POINT_CONVERSION_HYBRID) | 0);  /* check that POINT_CONVERSION_HYBRID is an integer */
  return n;
}

static int _cffi_const_SCT_SOURCE_UNKNOWN(unsigned long long *o)
{
  int n = (SCT_SOURCE_UNKNOWN) <= 0;
  *o = (unsigned long long)((SCT_SOURCE_UNKNOWN) | 0);  /* check that SCT_SOURCE_UNKNOWN is an integer */
  return n;
}

static int _cffi_const_SCT_SOURCE_TLS_EXTENSION(unsigned long long *o)
{
  int n = (SCT_SOURCE_TLS_EXTENSION) <= 0;
  *o = (unsigned long long)((SCT_SOURCE_TLS_EXTENSION) | 0);  /* check that SCT_SOURCE_TLS_EXTENSION is an integer */
  return n;
}

static int _cffi_const_SCT_SOURCE_X509V3_EXTENSION(unsigned long long *o)
{
  int n = (SCT_SOURCE_X509V3_EXTENSION) <= 0;
  *o = (unsigned long long)((SCT_SOURCE_X509V3_EXTENSION) | 0);  /* check that SCT_SOURCE_X509V3_EXTENSION is an integer */
  return n;
}

static int _cffi_const_SCT_SOURCE_OCSP_STAPLED_RESPONSE(unsigned long long *o)
{
  int n = (SCT_SOURCE_OCSP_STAPLED_RESPONSE) <= 0;
  *o = (unsigned long long)((SCT_SOURCE_OCSP_STAPLED_RESPONSE) | 0);  /* check that SCT_SOURCE_OCSP_STAPLED_RESPONSE is an integer */
  return n;
}

static int _cffi_const_SCT_VERSION_NOT_SET(unsigned long long *o)
{
  int n = (SCT_VERSION_NOT_SET) <= 0;
  *o = (unsigned long long)((SCT_VERSION_NOT_SET) | 0);  /* check that SCT_VERSION_NOT_SET is an integer */
  return n;
}

static int _cffi_const_SCT_VERSION_V1(unsigned long long *o)
{
  int n = (SCT_VERSION_V1) <= 0;
  *o = (unsigned long long)((SCT_VERSION_V1) | 0);  /* check that SCT_VERSION_V1 is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_CHECK_TLEN(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_CHECK_TLEN) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_CHECK_TLEN) | 0);  /* check that ASN1_F_ASN1_CHECK_TLEN is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_EX_C2I(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_EX_C2I) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_EX_C2I) | 0);  /* check that ASN1_F_ASN1_EX_C2I is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_FIND_END(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_FIND_END) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_FIND_END) | 0);  /* check that ASN1_F_ASN1_FIND_END is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_GENERATE_V3(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_GENERATE_V3) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_GENERATE_V3) | 0);  /* check that ASN1_F_ASN1_GENERATE_V3 is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_GET_OBJECT(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_GET_OBJECT) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_GET_OBJECT) | 0);  /* check that ASN1_F_ASN1_GET_OBJECT is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_ITEM_I2D_FP(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_ITEM_I2D_FP) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_ITEM_I2D_FP) | 0);  /* check that ASN1_F_ASN1_ITEM_I2D_FP is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_ITEM_PACK(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_ITEM_PACK) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_ITEM_PACK) | 0);  /* check that ASN1_F_ASN1_ITEM_PACK is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_ITEM_SIGN(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_ITEM_SIGN) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_ITEM_SIGN) | 0);  /* check that ASN1_F_ASN1_ITEM_SIGN is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_ITEM_UNPACK(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_ITEM_UNPACK) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_ITEM_UNPACK) | 0);  /* check that ASN1_F_ASN1_ITEM_UNPACK is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_ITEM_VERIFY(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_ITEM_VERIFY) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_ITEM_VERIFY) | 0);  /* check that ASN1_F_ASN1_ITEM_VERIFY is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_MBSTRING_NCOPY(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_MBSTRING_NCOPY) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_MBSTRING_NCOPY) | 0);  /* check that ASN1_F_ASN1_MBSTRING_NCOPY is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_TEMPLATE_EX_D2I(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_TEMPLATE_EX_D2I) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_TEMPLATE_EX_D2I) | 0);  /* check that ASN1_F_ASN1_TEMPLATE_EX_D2I is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_TEMPLATE_NEW(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_TEMPLATE_NEW) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_TEMPLATE_NEW) | 0);  /* check that ASN1_F_ASN1_TEMPLATE_NEW is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_TEMPLATE_NOEXP_D2I(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_TEMPLATE_NOEXP_D2I) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_TEMPLATE_NOEXP_D2I) | 0);  /* check that ASN1_F_ASN1_TEMPLATE_NOEXP_D2I is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING) | 0);  /* check that ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_TYPE_GET_OCTETSTRING(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_TYPE_GET_OCTETSTRING) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_TYPE_GET_OCTETSTRING) | 0);  /* check that ASN1_F_ASN1_TYPE_GET_OCTETSTRING is an integer */
  return n;
}

static int _cffi_const_ASN1_F_ASN1_VERIFY(unsigned long long *o)
{
  int n = (ASN1_F_ASN1_VERIFY) <= 0;
  *o = (unsigned long long)((ASN1_F_ASN1_VERIFY) | 0);  /* check that ASN1_F_ASN1_VERIFY is an integer */
  return n;
}

static int _cffi_const_ASN1_F_B64_READ_ASN1(unsigned long long *o)
{
  int n = (ASN1_F_B64_READ_ASN1) <= 0;
  *o = (unsigned long long)((ASN1_F_B64_READ_ASN1) | 0);  /* check that ASN1_F_B64_READ_ASN1 is an integer */
  return n;
}

static int _cffi_const_ASN1_F_B64_WRITE_ASN1(unsigned long long *o)
{
  int n = (ASN1_F_B64_WRITE_ASN1) <= 0;
  *o = (unsigned long long)((ASN1_F_B64_WRITE_ASN1) | 0);  /* check that ASN1_F_B64_WRITE_ASN1 is an integer */
  return n;
}

static int _cffi_const_ASN1_F_BITSTR_CB(unsigned long long *o)
{
  int n = (ASN1_F_BITSTR_CB) <= 0;
  *o = (unsigned long long)((ASN1_F_BITSTR_CB) | 0);  /* check that ASN1_F_BITSTR_CB is an integer */
  return n;
}

static int _cffi_const_ASN1_F_D2I_ASN1_UINTEGER(unsigned long long *o)
{
  int n = (ASN1_F_D2I_ASN1_UINTEGER) <= 0;
  *o = (unsigned long long)((ASN1_F_D2I_ASN1_UINTEGER) | 0);  /* check that ASN1_F_D2I_ASN1_UINTEGER is an integer */
  return n;
}

static int _cffi_const_ASN1_F_D2I_PRIVATEKEY(unsigned long long *o)
{
  int n = (ASN1_F_D2I_PRIVATEKEY) <= 0;
  *o = (unsigned long long)((ASN1_F_D2I_PRIVATEKEY) | 0);  /* check that ASN1_F_D2I_PRIVATEKEY is an integer */
  return n;
}

static int _cffi_const_ASN1_F_I2D_DSA_PUBKEY(unsigned long long *o)
{
  int n = (ASN1_F_I2D_DSA_PUBKEY) <= 0;
  *o = (unsigned long long)((ASN1_F_I2D_DSA_PUBKEY) | 0);  /* check that ASN1_F_I2D_DSA_PUBKEY is an integer */
  return n;
}

static int _cffi_const_ASN1_F_LONG_C2I(unsigned long long *o)
{
  int n = (ASN1_F_LONG_C2I) <= 0;
  *o = (unsigned long long)((ASN1_F_LONG_C2I) | 0);  /* check that ASN1_F_LONG_C2I is an integer */
  return n;
}

static int _cffi_const_ASN1_F_OID_MODULE_INIT(unsigned long long *o)
{
  int n = (ASN1_F_OID_MODULE_INIT) <= 0;
  *o = (unsigned long long)((ASN1_F_OID_MODULE_INIT) | 0);  /* check that ASN1_F_OID_MODULE_INIT is an integer */
  return n;
}

static int _cffi_const_ASN1_F_PARSE_TAGGING(unsigned long long *o)
{
  int n = (ASN1_F_PARSE_TAGGING) <= 0;
  *o = (unsigned long long)((ASN1_F_PARSE_TAGGING) | 0);  /* check that ASN1_F_PARSE_TAGGING is an integer */
  return n;
}

static int _cffi_const_ASN1_F_PKCS5_PBE_SET(unsigned long long *o)
{
  int n = (ASN1_F_PKCS5_PBE_SET) <= 0;
  *o = (unsigned long long)((ASN1_F_PKCS5_PBE_SET) | 0);  /* check that ASN1_F_PKCS5_PBE_SET is an integer */
  return n;
}

static int _cffi_const_ASN1_F_SMIME_READ_ASN1(unsigned long long *o)
{
  int n = (ASN1_F_SMIME_READ_ASN1) <= 0;
  *o = (unsigned long long)((ASN1_F_SMIME_READ_ASN1) | 0);  /* check that ASN1_F_SMIME_READ_ASN1 is an integer */
  return n;
}

static int _cffi_const_ASN1_F_SMIME_TEXT(unsigned long long *o)
{
  int n = (ASN1_F_SMIME_TEXT) <= 0;
  *o = (unsigned long long)((ASN1_F_SMIME_TEXT) | 0);  /* check that ASN1_F_SMIME_TEXT is an integer */
  return n;
}

static int _cffi_const_ASN1_R_BOOLEAN_IS_WRONG_LENGTH(unsigned long long *o)
{
  int n = (ASN1_R_BOOLEAN_IS_WRONG_LENGTH) <= 0;
  *o = (unsigned long long)((ASN1_R_BOOLEAN_IS_WRONG_LENGTH) | 0);  /* check that ASN1_R_BOOLEAN_IS_WRONG_LENGTH is an integer */
  return n;
}

static int _cffi_const_ASN1_R_BUFFER_TOO_SMALL(unsigned long long *o)
{
  int n = (ASN1_R_BUFFER_TOO_SMALL) <= 0;
  *o = (unsigned long long)((ASN1_R_BUFFER_TOO_SMALL) | 0);  /* check that ASN1_R_BUFFER_TOO_SMALL is an integer */
  return n;
}

static int _cffi_const_ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER(unsigned long long *o)
{
  int n = (ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER) <= 0;
  *o = (unsigned long long)((ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER) | 0);  /* check that ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER is an integer */
  return n;
}

static int _cffi_const_ASN1_R_DATA_IS_WRONG(unsigned long long *o)
{
  int n = (ASN1_R_DATA_IS_WRONG) <= 0;
  *o = (unsigned long long)((ASN1_R_DATA_IS_WRONG) | 0);  /* check that ASN1_R_DATA_IS_WRONG is an integer */
  return n;
}

static int _cffi_const_ASN1_R_DECODE_ERROR(unsigned long long *o)
{
  int n = (ASN1_R_DECODE_ERROR) <= 0;
  *o = (unsigned long long)((ASN1_R_DECODE_ERROR) | 0);  /* check that ASN1_R_DECODE_ERROR is an integer */
  return n;
}

static int _cffi_const_ASN1_R_DEPTH_EXCEEDED(unsigned long long *o)
{
  int n = (ASN1_R_DEPTH_EXCEEDED) <= 0;
  *o = (unsigned long long)((ASN1_R_DEPTH_EXCEEDED) | 0);  /* check that ASN1_R_DEPTH_EXCEEDED is an integer */
  return n;
}

static int _cffi_const_ASN1_R_ENCODE_ERROR(unsigned long long *o)
{
  int n = (ASN1_R_ENCODE_ERROR) <= 0;
  *o = (unsigned long long)((ASN1_R_ENCODE_ERROR) | 0);  /* check that ASN1_R_ENCODE_ERROR is an integer */
  return n;
}

static int _cffi_const_ASN1_R_ERROR_GETTING_TIME(unsigned long long *o)
{
  int n = (ASN1_R_ERROR_GETTING_TIME) <= 0;
  *o = (unsigned long long)((ASN1_R_ERROR_GETTING_TIME) | 0);  /* check that ASN1_R_ERROR_GETTING_TIME is an integer */
  return n;
}

static int _cffi_const_ASN1_R_ERROR_LOADING_SECTION(unsigned long long *o)
{
  int n = (ASN1_R_ERROR_LOADING_SECTION) <= 0;
  *o = (unsigned long long)((ASN1_R_ERROR_LOADING_SECTION) | 0);  /* check that ASN1_R_ERROR_LOADING_SECTION is an integer */
  return n;
}

static int _cffi_const_ASN1_R_HEADER_TOO_LONG(unsigned long long *o)
{
  int n = (ASN1_R_HEADER_TOO_LONG) <= 0;
  *o = (unsigned long long)((ASN1_R_HEADER_TOO_LONG) | 0);  /* check that ASN1_R_HEADER_TOO_LONG is an integer */
  return n;
}

static int _cffi_const_ASN1_R_MSTRING_WRONG_TAG(unsigned long long *o)
{
  int n = (ASN1_R_MSTRING_WRONG_TAG) <= 0;
  *o = (unsigned long long)((ASN1_R_MSTRING_WRONG_TAG) | 0);  /* check that ASN1_R_MSTRING_WRONG_TAG is an integer */
  return n;
}

static int _cffi_const_ASN1_R_NESTED_ASN1_STRING(unsigned long long *o)
{
  int n = (ASN1_R_NESTED_ASN1_STRING) <= 0;
  *o = (unsigned long long)((ASN1_R_NESTED_ASN1_STRING) | 0);  /* check that ASN1_R_NESTED_ASN1_STRING is an integer */
  return n;
}

static int _cffi_const_ASN1_R_NO_CONTENT_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_NO_CONTENT_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_NO_CONTENT_TYPE) | 0);  /* check that ASN1_R_NO_CONTENT_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_NO_MATCHING_CHOICE_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_NO_MATCHING_CHOICE_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_NO_MATCHING_CHOICE_TYPE) | 0);  /* check that ASN1_R_NO_MATCHING_CHOICE_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_NO_MULTIPART_BODY_FAILURE(unsigned long long *o)
{
  int n = (ASN1_R_NO_MULTIPART_BODY_FAILURE) <= 0;
  *o = (unsigned long long)((ASN1_R_NO_MULTIPART_BODY_FAILURE) | 0);  /* check that ASN1_R_NO_MULTIPART_BODY_FAILURE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_NO_MULTIPART_BOUNDARY(unsigned long long *o)
{
  int n = (ASN1_R_NO_MULTIPART_BOUNDARY) <= 0;
  *o = (unsigned long long)((ASN1_R_NO_MULTIPART_BOUNDARY) | 0);  /* check that ASN1_R_NO_MULTIPART_BOUNDARY is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM(unsigned long long *o)
{
  int n = (ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM) <= 0;
  *o = (unsigned long long)((ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM) | 0);  /* check that ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNKNOWN_OBJECT_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_UNKNOWN_OBJECT_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_UNKNOWN_OBJECT_TYPE) | 0);  /* check that ASN1_R_UNKNOWN_OBJECT_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE) | 0);  /* check that ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNKNOWN_TAG(unsigned long long *o)
{
  int n = (ASN1_R_UNKNOWN_TAG) <= 0;
  *o = (unsigned long long)((ASN1_R_UNKNOWN_TAG) | 0);  /* check that ASN1_R_UNKNOWN_TAG is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE) | 0);  /* check that ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE) | 0);  /* check that ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_UNSUPPORTED_TYPE(unsigned long long *o)
{
  int n = (ASN1_R_UNSUPPORTED_TYPE) <= 0;
  *o = (unsigned long long)((ASN1_R_UNSUPPORTED_TYPE) | 0);  /* check that ASN1_R_UNSUPPORTED_TYPE is an integer */
  return n;
}

static int _cffi_const_ASN1_R_WRONG_TAG(unsigned long long *o)
{
  int n = (ASN1_R_WRONG_TAG) <= 0;
  *o = (unsigned long long)((ASN1_R_WRONG_TAG) | 0);  /* check that ASN1_R_WRONG_TAG is an integer */
  return n;
}

static int _cffi_const_BIO_CLOSE(unsigned long long *o)
{
  int n = (BIO_CLOSE) <= 0;
  *o = (unsigned long long)((BIO_CLOSE) | 0);  /* check that BIO_CLOSE is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_DUP(unsigned long long *o)
{
  int n = (BIO_CTRL_DUP) <= 0;
  *o = (unsigned long long)((BIO_CTRL_DUP) | 0);  /* check that BIO_CTRL_DUP is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_EOF(unsigned long long *o)
{
  int n = (BIO_CTRL_EOF) <= 0;
  *o = (unsigned long long)((BIO_CTRL_EOF) | 0);  /* check that BIO_CTRL_EOF is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_FLUSH(unsigned long long *o)
{
  int n = (BIO_CTRL_FLUSH) <= 0;
  *o = (unsigned long long)((BIO_CTRL_FLUSH) | 0);  /* check that BIO_CTRL_FLUSH is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_GET(unsigned long long *o)
{
  int n = (BIO_CTRL_GET) <= 0;
  *o = (unsigned long long)((BIO_CTRL_GET) | 0);  /* check that BIO_CTRL_GET is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_GET_CLOSE(unsigned long long *o)
{
  int n = (BIO_CTRL_GET_CLOSE) <= 0;
  *o = (unsigned long long)((BIO_CTRL_GET_CLOSE) | 0);  /* check that BIO_CTRL_GET_CLOSE is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_INFO(unsigned long long *o)
{
  int n = (BIO_CTRL_INFO) <= 0;
  *o = (unsigned long long)((BIO_CTRL_INFO) | 0);  /* check that BIO_CTRL_INFO is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_PENDING(unsigned long long *o)
{
  int n = (BIO_CTRL_PENDING) <= 0;
  *o = (unsigned long long)((BIO_CTRL_PENDING) | 0);  /* check that BIO_CTRL_PENDING is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_RESET(unsigned long long *o)
{
  int n = (BIO_CTRL_RESET) <= 0;
  *o = (unsigned long long)((BIO_CTRL_RESET) | 0);  /* check that BIO_CTRL_RESET is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_SET(unsigned long long *o)
{
  int n = (BIO_CTRL_SET) <= 0;
  *o = (unsigned long long)((BIO_CTRL_SET) | 0);  /* check that BIO_CTRL_SET is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_SET_CLOSE(unsigned long long *o)
{
  int n = (BIO_CTRL_SET_CLOSE) <= 0;
  *o = (unsigned long long)((BIO_CTRL_SET_CLOSE) | 0);  /* check that BIO_CTRL_SET_CLOSE is an integer */
  return n;
}

static int _cffi_const_BIO_CTRL_WPENDING(unsigned long long *o)
{
  int n = (BIO_CTRL_WPENDING) <= 0;
  *o = (unsigned long long)((BIO_CTRL_WPENDING) | 0);  /* check that BIO_CTRL_WPENDING is an integer */
  return n;
}

static int _cffi_const_BIO_C_FILE_SEEK(unsigned long long *o)
{
  int n = (BIO_C_FILE_SEEK) <= 0;
  *o = (unsigned long long)((BIO_C_FILE_SEEK) | 0);  /* check that BIO_C_FILE_SEEK is an integer */
  return n;
}

static int _cffi_const_BIO_C_FILE_TELL(unsigned long long *o)
{
  int n = (BIO_C_FILE_TELL) <= 0;
  *o = (unsigned long long)((BIO_C_FILE_TELL) | 0);  /* check that BIO_C_FILE_TELL is an integer */
  return n;
}

static int _cffi_const_BIO_FLAGS_IO_SPECIAL(unsigned long long *o)
{
  int n = (BIO_FLAGS_IO_SPECIAL) <= 0;
  *o = (unsigned long long)((BIO_FLAGS_IO_SPECIAL) | 0);  /* check that BIO_FLAGS_IO_SPECIAL is an integer */
  return n;
}

static int _cffi_const_BIO_FLAGS_READ(unsigned long long *o)
{
  int n = (BIO_FLAGS_READ) <= 0;
  *o = (unsigned long long)((BIO_FLAGS_READ) | 0);  /* check that BIO_FLAGS_READ is an integer */
  return n;
}

static int _cffi_const_BIO_FLAGS_RWS(unsigned long long *o)
{
  int n = (BIO_FLAGS_RWS) <= 0;
  *o = (unsigned long long)((BIO_FLAGS_RWS) | 0);  /* check that BIO_FLAGS_RWS is an integer */
  return n;
}

static int _cffi_const_BIO_FLAGS_SHOULD_RETRY(unsigned long long *o)
{
  int n = (BIO_FLAGS_SHOULD_RETRY) <= 0;
  *o = (unsigned long long)((BIO_FLAGS_SHOULD_RETRY) | 0);  /* check that BIO_FLAGS_SHOULD_RETRY is an integer */
  return n;
}

static int _cffi_const_BIO_FLAGS_WRITE(unsigned long long *o)
{
  int n = (BIO_FLAGS_WRITE) <= 0;
  *o = (unsigned long long)((BIO_FLAGS_WRITE) | 0);  /* check that BIO_FLAGS_WRITE is an integer */
  return n;
}

static int _cffi_const_BIO_NOCLOSE(unsigned long long *o)
{
  int n = (BIO_NOCLOSE) <= 0;
  *o = (unsigned long long)((BIO_NOCLOSE) | 0);  /* check that BIO_NOCLOSE is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_ACCEPT(unsigned long long *o)
{
  int n = (BIO_TYPE_ACCEPT) <= 0;
  *o = (unsigned long long)((BIO_TYPE_ACCEPT) | 0);  /* check that BIO_TYPE_ACCEPT is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_BASE64(unsigned long long *o)
{
  int n = (BIO_TYPE_BASE64) <= 0;
  *o = (unsigned long long)((BIO_TYPE_BASE64) | 0);  /* check that BIO_TYPE_BASE64 is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_BIO(unsigned long long *o)
{
  int n = (BIO_TYPE_BIO) <= 0;
  *o = (unsigned long long)((BIO_TYPE_BIO) | 0);  /* check that BIO_TYPE_BIO is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_BUFFER(unsigned long long *o)
{
  int n = (BIO_TYPE_BUFFER) <= 0;
  *o = (unsigned long long)((BIO_TYPE_BUFFER) | 0);  /* check that BIO_TYPE_BUFFER is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_CIPHER(unsigned long long *o)
{
  int n = (BIO_TYPE_CIPHER) <= 0;
  *o = (unsigned long long)((BIO_TYPE_CIPHER) | 0);  /* check that BIO_TYPE_CIPHER is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_CONNECT(unsigned long long *o)
{
  int n = (BIO_TYPE_CONNECT) <= 0;
  *o = (unsigned long long)((BIO_TYPE_CONNECT) | 0);  /* check that BIO_TYPE_CONNECT is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_DESCRIPTOR(unsigned long long *o)
{
  int n = (BIO_TYPE_DESCRIPTOR) <= 0;
  *o = (unsigned long long)((BIO_TYPE_DESCRIPTOR) | 0);  /* check that BIO_TYPE_DESCRIPTOR is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_FD(unsigned long long *o)
{
  int n = (BIO_TYPE_FD) <= 0;
  *o = (unsigned long long)((BIO_TYPE_FD) | 0);  /* check that BIO_TYPE_FD is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_FILE(unsigned long long *o)
{
  int n = (BIO_TYPE_FILE) <= 0;
  *o = (unsigned long long)((BIO_TYPE_FILE) | 0);  /* check that BIO_TYPE_FILE is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_FILTER(unsigned long long *o)
{
  int n = (BIO_TYPE_FILTER) <= 0;
  *o = (unsigned long long)((BIO_TYPE_FILTER) | 0);  /* check that BIO_TYPE_FILTER is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_MD(unsigned long long *o)
{
  int n = (BIO_TYPE_MD) <= 0;
  *o = (unsigned long long)((BIO_TYPE_MD) | 0);  /* check that BIO_TYPE_MD is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_MEM(unsigned long long *o)
{
  int n = (BIO_TYPE_MEM) <= 0;
  *o = (unsigned long long)((BIO_TYPE_MEM) | 0);  /* check that BIO_TYPE_MEM is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_NBIO_TEST(unsigned long long *o)
{
  int n = (BIO_TYPE_NBIO_TEST) <= 0;
  *o = (unsigned long long)((BIO_TYPE_NBIO_TEST) | 0);  /* check that BIO_TYPE_NBIO_TEST is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_NONE(unsigned long long *o)
{
  int n = (BIO_TYPE_NONE) <= 0;
  *o = (unsigned long long)((BIO_TYPE_NONE) | 0);  /* check that BIO_TYPE_NONE is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_NULL(unsigned long long *o)
{
  int n = (BIO_TYPE_NULL) <= 0;
  *o = (unsigned long long)((BIO_TYPE_NULL) | 0);  /* check that BIO_TYPE_NULL is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_NULL_FILTER(unsigned long long *o)
{
  int n = (BIO_TYPE_NULL_FILTER) <= 0;
  *o = (unsigned long long)((BIO_TYPE_NULL_FILTER) | 0);  /* check that BIO_TYPE_NULL_FILTER is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_SOCKET(unsigned long long *o)
{
  int n = (BIO_TYPE_SOCKET) <= 0;
  *o = (unsigned long long)((BIO_TYPE_SOCKET) | 0);  /* check that BIO_TYPE_SOCKET is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_SOURCE_SINK(unsigned long long *o)
{
  int n = (BIO_TYPE_SOURCE_SINK) <= 0;
  *o = (unsigned long long)((BIO_TYPE_SOURCE_SINK) | 0);  /* check that BIO_TYPE_SOURCE_SINK is an integer */
  return n;
}

static int _cffi_const_BIO_TYPE_SSL(unsigned long long *o)
{
  int n = (BIO_TYPE_SSL) <= 0;
  *o = (unsigned long long)((BIO_TYPE_SSL) | 0);  /* check that BIO_TYPE_SSL is an integer */
  return n;
}

static int _cffi_const_CMS_BINARY(unsigned long long *o)
{
  int n = (CMS_BINARY) <= 0;
  *o = (unsigned long long)((CMS_BINARY) | 0);  /* check that CMS_BINARY is an integer */
  return n;
}

static int _cffi_const_CMS_CRLFEOL(unsigned long long *o)
{
  int n = (CMS_CRLFEOL) <= 0;
  *o = (unsigned long long)((CMS_CRLFEOL) | 0);  /* check that CMS_CRLFEOL is an integer */
  return n;
}

static int _cffi_const_CMS_DEBUG_DECRYPT(unsigned long long *o)
{
  int n = (CMS_DEBUG_DECRYPT) <= 0;
  *o = (unsigned long long)((CMS_DEBUG_DECRYPT) | 0);  /* check that CMS_DEBUG_DECRYPT is an integer */
  return n;
}

static int _cffi_const_CMS_DETACHED(unsigned long long *o)
{
  int n = (CMS_DETACHED) <= 0;
  *o = (unsigned long long)((CMS_DETACHED) | 0);  /* check that CMS_DETACHED is an integer */
  return n;
}

static int _cffi_const_CMS_NOATTR(unsigned long long *o)
{
  int n = (CMS_NOATTR) <= 0;
  *o = (unsigned long long)((CMS_NOATTR) | 0);  /* check that CMS_NOATTR is an integer */
  return n;
}

static int _cffi_const_CMS_NOCERTS(unsigned long long *o)
{
  int n = (CMS_NOCERTS) <= 0;
  *o = (unsigned long long)((CMS_NOCERTS) | 0);  /* check that CMS_NOCERTS is an integer */
  return n;
}

static int _cffi_const_CMS_NOCRL(unsigned long long *o)
{
  int n = (CMS_NOCRL) <= 0;
  *o = (unsigned long long)((CMS_NOCRL) | 0);  /* check that CMS_NOCRL is an integer */
  return n;
}

static int _cffi_const_CMS_NOINTERN(unsigned long long *o)
{
  int n = (CMS_NOINTERN) <= 0;
  *o = (unsigned long long)((CMS_NOINTERN) | 0);  /* check that CMS_NOINTERN is an integer */
  return n;
}

static int _cffi_const_CMS_NOOLDMIMETYPE(unsigned long long *o)
{
  int n = (CMS_NOOLDMIMETYPE) <= 0;
  *o = (unsigned long long)((CMS_NOOLDMIMETYPE) | 0);  /* check that CMS_NOOLDMIMETYPE is an integer */
  return n;
}

static int _cffi_const_CMS_NOSIGS(unsigned long long *o)
{
  int n = (CMS_NOSIGS) <= 0;
  *o = (unsigned long long)((CMS_NOSIGS) | 0);  /* check that CMS_NOSIGS is an integer */
  return n;
}

static int _cffi_const_CMS_NOSMIMECAP(unsigned long long *o)
{
  int n = (CMS_NOSMIMECAP) <= 0;
  *o = (unsigned long long)((CMS_NOSMIMECAP) | 0);  /* check that CMS_NOSMIMECAP is an integer */
  return n;
}

static int _cffi_const_CMS_NOVERIFY(unsigned long long *o)
{
  int n = (CMS_NOVERIFY) <= 0;
  *o = (unsigned long long)((CMS_NOVERIFY) | 0);  /* check that CMS_NOVERIFY is an integer */
  return n;
}

static int _cffi_const_CMS_NO_ATTR_VERIFY(unsigned long long *o)
{
  int n = (CMS_NO_ATTR_VERIFY) <= 0;
  *o = (unsigned long long)((CMS_NO_ATTR_VERIFY) | 0);  /* check that CMS_NO_ATTR_VERIFY is an integer */
  return n;
}

static int _cffi_const_CMS_NO_CONTENT_VERIFY(unsigned long long *o)
{
  int n = (CMS_NO_CONTENT_VERIFY) <= 0;
  *o = (unsigned long long)((CMS_NO_CONTENT_VERIFY) | 0);  /* check that CMS_NO_CONTENT_VERIFY is an integer */
  return n;
}

static int _cffi_const_CMS_NO_SIGNER_CERT_VERIFY(unsigned long long *o)
{
  int n = (CMS_NO_SIGNER_CERT_VERIFY) <= 0;
  *o = (unsigned long long)((CMS_NO_SIGNER_CERT_VERIFY) | 0);  /* check that CMS_NO_SIGNER_CERT_VERIFY is an integer */
  return n;
}

static int _cffi_const_CMS_PARTIAL(unsigned long long *o)
{
  int n = (CMS_PARTIAL) <= 0;
  *o = (unsigned long long)((CMS_PARTIAL) | 0);  /* check that CMS_PARTIAL is an integer */
  return n;
}

static int _cffi_const_CMS_REUSE_DIGEST(unsigned long long *o)
{
  int n = (CMS_REUSE_DIGEST) <= 0;
  *o = (unsigned long long)((CMS_REUSE_DIGEST) | 0);  /* check that CMS_REUSE_DIGEST is an integer */
  return n;
}

static int _cffi_const_CMS_STREAM(unsigned long long *o)
{
  int n = (CMS_STREAM) <= 0;
  *o = (unsigned long long)((CMS_STREAM) | 0);  /* check that CMS_STREAM is an integer */
  return n;
}

static int _cffi_const_CMS_TEXT(unsigned long long *o)
{
  int n = (CMS_TEXT) <= 0;
  *o = (unsigned long long)((CMS_TEXT) | 0);  /* check that CMS_TEXT is an integer */
  return n;
}

static int _cffi_const_CMS_USE_KEYID(unsigned long long *o)
{
  int n = (CMS_USE_KEYID) <= 0;
  *o = (unsigned long long)((CMS_USE_KEYID) | 0);  /* check that CMS_USE_KEYID is an integer */
  return n;
}

static int _cffi_const_CRYPTOGRAPHY_IS_LIBRESSL(unsigned long long *o)
{
  int n = (CRYPTOGRAPHY_IS_LIBRESSL) <= 0;
  *o = (unsigned long long)((CRYPTOGRAPHY_IS_LIBRESSL) | 0);  /* check that CRYPTOGRAPHY_IS_LIBRESSL is an integer */
  return n;
}

static int _cffi_const_CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER(unsigned long long *o)
{
  int n = (CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER) <= 0;
  *o = (unsigned long long)((CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER) | 0);  /* check that CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER is an integer */
  return n;
}

static int _cffi_const_CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER(unsigned long long *o)
{
  int n = (CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER) <= 0;
  *o = (unsigned long long)((CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER) | 0);  /* check that CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER is an integer */
  return n;
}

static int _cffi_const_CRYPTOGRAPHY_OPENSSL_110_OR_GREATER(unsigned long long *o)
{
  int n = (CRYPTOGRAPHY_OPENSSL_110_OR_GREATER) <= 0;
  *o = (unsigned long long)((CRYPTOGRAPHY_OPENSSL_110_OR_GREATER) | 0);  /* check that CRYPTOGRAPHY_OPENSSL_110_OR_GREATER is an integer */
  return n;
}

static int _cffi_const_CRYPTOGRAPHY_OPENSSL_LESS_THAN_102(unsigned long long *o)
{
  int n = (CRYPTOGRAPHY_OPENSSL_LESS_THAN_102) <= 0;
  *o = (unsigned long long)((CRYPTOGRAPHY_OPENSSL_LESS_THAN_102) | 0);  /* check that CRYPTOGRAPHY_OPENSSL_LESS_THAN_102 is an integer */
  return n;
}

static int _cffi_const_CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I(unsigned long long *o)
{
  int n = (CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I) <= 0;
  *o = (unsigned long long)((CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I) | 0);  /* check that CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I is an integer */
  return n;
}

static int _cffi_const_CRYPTO_LOCK(unsigned long long *o)
{
  int n = (CRYPTO_LOCK) <= 0;
  *o = (unsigned long long)((CRYPTO_LOCK) | 0);  /* check that CRYPTO_LOCK is an integer */
  return n;
}

static int _cffi_const_CRYPTO_LOCK_SSL(unsigned long long *o)
{
  int n = (CRYPTO_LOCK_SSL) <= 0;
  *o = (unsigned long long)((CRYPTO_LOCK_SSL) | 0);  /* check that CRYPTO_LOCK_SSL is an integer */
  return n;
}

static int _cffi_const_CRYPTO_MEM_CHECK_DISABLE(unsigned long long *o)
{
  int n = (CRYPTO_MEM_CHECK_DISABLE) <= 0;
  *o = (unsigned long long)((CRYPTO_MEM_CHECK_DISABLE) | 0);  /* check that CRYPTO_MEM_CHECK_DISABLE is an integer */
  return n;
}

static int _cffi_const_CRYPTO_MEM_CHECK_ENABLE(unsigned long long *o)
{
  int n = (CRYPTO_MEM_CHECK_ENABLE) <= 0;
  *o = (unsigned long long)((CRYPTO_MEM_CHECK_ENABLE) | 0);  /* check that CRYPTO_MEM_CHECK_ENABLE is an integer */
  return n;
}

static int _cffi_const_CRYPTO_MEM_CHECK_OFF(unsigned long long *o)
{
  int n = (CRYPTO_MEM_CHECK_OFF) <= 0;
  *o = (unsigned long long)((CRYPTO_MEM_CHECK_OFF) | 0);  /* check that CRYPTO_MEM_CHECK_OFF is an integer */
  return n;
}

static int _cffi_const_CRYPTO_MEM_CHECK_ON(unsigned long long *o)
{
  int n = (CRYPTO_MEM_CHECK_ON) <= 0;
  *o = (unsigned long long)((CRYPTO_MEM_CHECK_ON) | 0);  /* check that CRYPTO_MEM_CHECK_ON is an integer */
  return n;
}

static int _cffi_const_CRYPTO_READ(unsigned long long *o)
{
  int n = (CRYPTO_READ) <= 0;
  *o = (unsigned long long)((CRYPTO_READ) | 0);  /* check that CRYPTO_READ is an integer */
  return n;
}

static int _cffi_const_CRYPTO_UNLOCK(unsigned long long *o)
{
  int n = (CRYPTO_UNLOCK) <= 0;
  *o = (unsigned long long)((CRYPTO_UNLOCK) | 0);  /* check that CRYPTO_UNLOCK is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_102_VERIFICATION_ERROR_CODES(unsigned long long *o)
{
  int n = (Cryptography_HAS_102_VERIFICATION_ERROR_CODES) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_102_VERIFICATION_ERROR_CODES) | 0);  /* check that Cryptography_HAS_102_VERIFICATION_ERROR_CODES is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_102_VERIFICATION_PARAMS(unsigned long long *o)
{
  int n = (Cryptography_HAS_102_VERIFICATION_PARAMS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_102_VERIFICATION_PARAMS) | 0);  /* check that Cryptography_HAS_102_VERIFICATION_PARAMS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_AES_WRAP(unsigned long long *o)
{
  int n = (Cryptography_HAS_AES_WRAP) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_AES_WRAP) | 0);  /* check that Cryptography_HAS_AES_WRAP is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_ALPN(unsigned long long *o)
{
  int n = (Cryptography_HAS_ALPN) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_ALPN) | 0);  /* check that Cryptography_HAS_ALPN is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_CMAC(unsigned long long *o)
{
  int n = (Cryptography_HAS_CMAC) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_CMAC) | 0);  /* check that Cryptography_HAS_CMAC is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_CMS(unsigned long long *o)
{
  int n = (Cryptography_HAS_CMS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_CMS) | 0);  /* check that Cryptography_HAS_CMS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_CMS_BIO_FUNCTIONS(unsigned long long *o)
{
  int n = (Cryptography_HAS_CMS_BIO_FUNCTIONS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_CMS_BIO_FUNCTIONS) | 0);  /* check that Cryptography_HAS_CMS_BIO_FUNCTIONS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_COMPRESSION(unsigned long long *o)
{
  int n = (Cryptography_HAS_COMPRESSION) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_COMPRESSION) | 0);  /* check that Cryptography_HAS_COMPRESSION is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_DTLS(unsigned long long *o)
{
  int n = (Cryptography_HAS_DTLS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_DTLS) | 0);  /* check that Cryptography_HAS_DTLS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_EC(unsigned long long *o)
{
  int n = (Cryptography_HAS_EC) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_EC) | 0);  /* check that Cryptography_HAS_EC is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_EC2M(unsigned long long *o)
{
  int n = (Cryptography_HAS_EC2M) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_EC2M) | 0);  /* check that Cryptography_HAS_EC2M is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_ECDH(unsigned long long *o)
{
  int n = (Cryptography_HAS_ECDH) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_ECDH) | 0);  /* check that Cryptography_HAS_ECDH is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_ECDSA(unsigned long long *o)
{
  int n = (Cryptography_HAS_ECDSA) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_ECDSA) | 0);  /* check that Cryptography_HAS_ECDSA is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_EC_1_0_2(unsigned long long *o)
{
  int n = (Cryptography_HAS_EC_1_0_2) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_EC_1_0_2) | 0);  /* check that Cryptography_HAS_EC_1_0_2 is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_EC_CODES(unsigned long long *o)
{
  int n = (Cryptography_HAS_EC_CODES) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_EC_CODES) | 0);  /* check that Cryptography_HAS_EC_CODES is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_EGD(unsigned long long *o)
{
  int n = (Cryptography_HAS_EGD) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_EGD) | 0);  /* check that Cryptography_HAS_EGD is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_ENGINE_CRYPTODEV(unsigned long long *o)
{
  int n = (Cryptography_HAS_ENGINE_CRYPTODEV) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_ENGINE_CRYPTODEV) | 0);  /* check that Cryptography_HAS_ENGINE_CRYPTODEV is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_EVP_PKEY_DHX(unsigned long long *o)
{
  int n = (Cryptography_HAS_EVP_PKEY_DHX) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_EVP_PKEY_DHX) | 0);  /* check that Cryptography_HAS_EVP_PKEY_DHX is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_GCM(unsigned long long *o)
{
  int n = (Cryptography_HAS_GCM) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_GCM) | 0);  /* check that Cryptography_HAS_GCM is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_GET_SERVER_TMP_KEY(unsigned long long *o)
{
  int n = (Cryptography_HAS_GET_SERVER_TMP_KEY) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_GET_SERVER_TMP_KEY) | 0);  /* check that Cryptography_HAS_GET_SERVER_TMP_KEY is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_LOCKING_CALLBACKS(unsigned long long *o)
{
  int n = (Cryptography_HAS_LOCKING_CALLBACKS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_LOCKING_CALLBACKS) | 0);  /* check that Cryptography_HAS_LOCKING_CALLBACKS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_MEM_FUNCTIONS(unsigned long long *o)
{
  int n = (Cryptography_HAS_MEM_FUNCTIONS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_MEM_FUNCTIONS) | 0);  /* check that Cryptography_HAS_MEM_FUNCTIONS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_NEXTPROTONEG(unsigned long long *o)
{
  int n = (Cryptography_HAS_NEXTPROTONEG) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_NEXTPROTONEG) | 0);  /* check that Cryptography_HAS_NEXTPROTONEG is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_OP_NO_COMPRESSION(unsigned long long *o)
{
  int n = (Cryptography_HAS_OP_NO_COMPRESSION) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_OP_NO_COMPRESSION) | 0);  /* check that Cryptography_HAS_OP_NO_COMPRESSION is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_PBKDF2_HMAC(unsigned long long *o)
{
  int n = (Cryptography_HAS_PBKDF2_HMAC) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_PBKDF2_HMAC) | 0);  /* check that Cryptography_HAS_PBKDF2_HMAC is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_PKEY_CTX(unsigned long long *o)
{
  int n = (Cryptography_HAS_PKEY_CTX) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_PKEY_CTX) | 0);  /* check that Cryptography_HAS_PKEY_CTX is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_PSS_PADDING(unsigned long long *o)
{
  int n = (Cryptography_HAS_PSS_PADDING) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_PSS_PADDING) | 0);  /* check that Cryptography_HAS_PSS_PADDING is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_RELEASE_BUFFERS(unsigned long long *o)
{
  int n = (Cryptography_HAS_RELEASE_BUFFERS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_RELEASE_BUFFERS) | 0);  /* check that Cryptography_HAS_RELEASE_BUFFERS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_RSA_OAEP_MD(unsigned long long *o)
{
  int n = (Cryptography_HAS_RSA_OAEP_MD) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_RSA_OAEP_MD) | 0);  /* check that Cryptography_HAS_RSA_OAEP_MD is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR(unsigned long long *o)
{
  int n = (Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR) | 0);  /* check that Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SCRYPT(unsigned long long *o)
{
  int n = (Cryptography_HAS_SCRYPT) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SCRYPT) | 0);  /* check that Cryptography_HAS_SCRYPT is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SCT(unsigned long long *o)
{
  int n = (Cryptography_HAS_SCT) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SCT) | 0);  /* check that Cryptography_HAS_SCT is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SECURE_RENEGOTIATION(unsigned long long *o)
{
  int n = (Cryptography_HAS_SECURE_RENEGOTIATION) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SECURE_RENEGOTIATION) | 0);  /* check that Cryptography_HAS_SECURE_RENEGOTIATION is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SET_CERT_CB(unsigned long long *o)
{
  int n = (Cryptography_HAS_SET_CERT_CB) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SET_CERT_CB) | 0);  /* check that Cryptography_HAS_SET_CERT_CB is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SET_ECDH_AUTO(unsigned long long *o)
{
  int n = (Cryptography_HAS_SET_ECDH_AUTO) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SET_ECDH_AUTO) | 0);  /* check that Cryptography_HAS_SET_ECDH_AUTO is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL2(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL2) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL2) | 0);  /* check that Cryptography_HAS_SSL2 is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL3_METHOD(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL3_METHOD) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL3_METHOD) | 0);  /* check that Cryptography_HAS_SSL3_METHOD is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS) | 0);  /* check that Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE) | 0);  /* check that Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING) | 0);  /* check that Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL_OP_NO_TICKET(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL_OP_NO_TICKET) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL_OP_NO_TICKET) | 0);  /* check that Cryptography_HAS_SSL_OP_NO_TICKET is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL_SET_SSL_CTX(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL_SET_SSL_CTX) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL_SET_SSL_CTX) | 0);  /* check that Cryptography_HAS_SSL_SET_SSL_CTX is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_SSL_ST(unsigned long long *o)
{
  int n = (Cryptography_HAS_SSL_ST) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_SSL_ST) | 0);  /* check that Cryptography_HAS_SSL_ST is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_STATUS_REQ_OCSP_RESP(unsigned long long *o)
{
  int n = (Cryptography_HAS_STATUS_REQ_OCSP_RESP) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_STATUS_REQ_OCSP_RESP) | 0);  /* check that Cryptography_HAS_STATUS_REQ_OCSP_RESP is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_TLSEXT_HOSTNAME(unsigned long long *o)
{
  int n = (Cryptography_HAS_TLSEXT_HOSTNAME) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_TLSEXT_HOSTNAME) | 0);  /* check that Cryptography_HAS_TLSEXT_HOSTNAME is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_TLSEXT_STATUS_REQ_CB(unsigned long long *o)
{
  int n = (Cryptography_HAS_TLSEXT_STATUS_REQ_CB) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_TLSEXT_STATUS_REQ_CB) | 0);  /* check that Cryptography_HAS_TLSEXT_STATUS_REQ_CB is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE(unsigned long long *o)
{
  int n = (Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE) | 0);  /* check that Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_TLS_ST(unsigned long long *o)
{
  int n = (Cryptography_HAS_TLS_ST) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_TLS_ST) | 0);  /* check that Cryptography_HAS_TLS_ST is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_TLSv1_1(unsigned long long *o)
{
  int n = (Cryptography_HAS_TLSv1_1) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_TLSv1_1) | 0);  /* check that Cryptography_HAS_TLSv1_1 is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_TLSv1_2(unsigned long long *o)
{
  int n = (Cryptography_HAS_TLSv1_2) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_TLSv1_2) | 0);  /* check that Cryptography_HAS_TLSv1_2 is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_X25519(unsigned long long *o)
{
  int n = (Cryptography_HAS_X25519) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_X25519) | 0);  /* check that Cryptography_HAS_X25519 is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_X509_STORE_CTX_GET_ISSUER(unsigned long long *o)
{
  int n = (Cryptography_HAS_X509_STORE_CTX_GET_ISSUER) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_X509_STORE_CTX_GET_ISSUER) | 0);  /* check that Cryptography_HAS_X509_STORE_CTX_GET_ISSUER is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN(unsigned long long *o)
{
  int n = (Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN) | 0);  /* check that Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN is an integer */
  return n;
}

static int _cffi_const_Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST(unsigned long long *o)
{
  int n = (Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST) <= 0;
  *o = (unsigned long long)((Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST) | 0);  /* check that Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST is an integer */
  return n;
}

static void _cffi_const_Cryptography_osrandom_engine_id(char *o)
{
  *(char const * *)o = Cryptography_osrandom_engine_id;
}

static void _cffi_const_Cryptography_osrandom_engine_name(char *o)
{
  *(char const * *)o = Cryptography_osrandom_engine_name;
}

static int _cffi_const_DH_F_COMPUTE_KEY(unsigned long long *o)
{
  int n = (DH_F_COMPUTE_KEY) <= 0;
  *o = (unsigned long long)((DH_F_COMPUTE_KEY) | 0);  /* check that DH_F_COMPUTE_KEY is an integer */
  return n;
}

static int _cffi_const_DH_R_INVALID_PUBKEY(unsigned long long *o)
{
  int n = (DH_R_INVALID_PUBKEY) <= 0;
  *o = (unsigned long long)((DH_R_INVALID_PUBKEY) | 0);  /* check that DH_R_INVALID_PUBKEY is an integer */
  return n;
}

static int _cffi_const_EC_F_EC_GROUP_NEW_BY_CURVE_NAME(unsigned long long *o)
{
  int n = (EC_F_EC_GROUP_NEW_BY_CURVE_NAME) <= 0;
  *o = (unsigned long long)((EC_F_EC_GROUP_NEW_BY_CURVE_NAME) | 0);  /* check that EC_F_EC_GROUP_NEW_BY_CURVE_NAME is an integer */
  return n;
}

static int _cffi_const_EC_R_UNKNOWN_GROUP(unsigned long long *o)
{
  int n = (EC_R_UNKNOWN_GROUP) <= 0;
  *o = (unsigned long long)((EC_R_UNKNOWN_GROUP) | 0);  /* check that EC_R_UNKNOWN_GROUP is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_ALL(unsigned long long *o)
{
  int n = (ENGINE_METHOD_ALL) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_ALL) | 0);  /* check that ENGINE_METHOD_ALL is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_CIPHERS(unsigned long long *o)
{
  int n = (ENGINE_METHOD_CIPHERS) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_CIPHERS) | 0);  /* check that ENGINE_METHOD_CIPHERS is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_DIGESTS(unsigned long long *o)
{
  int n = (ENGINE_METHOD_DIGESTS) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_DIGESTS) | 0);  /* check that ENGINE_METHOD_DIGESTS is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_DSA(unsigned long long *o)
{
  int n = (ENGINE_METHOD_DSA) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_DSA) | 0);  /* check that ENGINE_METHOD_DSA is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_NONE(unsigned long long *o)
{
  int n = (ENGINE_METHOD_NONE) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_NONE) | 0);  /* check that ENGINE_METHOD_NONE is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_RAND(unsigned long long *o)
{
  int n = (ENGINE_METHOD_RAND) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_RAND) | 0);  /* check that ENGINE_METHOD_RAND is an integer */
  return n;
}

static int _cffi_const_ENGINE_METHOD_RSA(unsigned long long *o)
{
  int n = (ENGINE_METHOD_RSA) <= 0;
  *o = (unsigned long long)((ENGINE_METHOD_RSA) | 0);  /* check that ENGINE_METHOD_RSA is an integer */
  return n;
}

static int _cffi_const_ENGINE_R_CONFLICTING_ENGINE_ID(unsigned long long *o)
{
  int n = (ENGINE_R_CONFLICTING_ENGINE_ID) <= 0;
  *o = (unsigned long long)((ENGINE_R_CONFLICTING_ENGINE_ID) | 0);  /* check that ENGINE_R_CONFLICTING_ENGINE_ID is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_ASN1(unsigned long long *o)
{
  int n = (ERR_LIB_ASN1) <= 0;
  *o = (unsigned long long)((ERR_LIB_ASN1) | 0);  /* check that ERR_LIB_ASN1 is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_DH(unsigned long long *o)
{
  int n = (ERR_LIB_DH) <= 0;
  *o = (unsigned long long)((ERR_LIB_DH) | 0);  /* check that ERR_LIB_DH is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_EC(unsigned long long *o)
{
  int n = (ERR_LIB_EC) <= 0;
  *o = (unsigned long long)((ERR_LIB_EC) | 0);  /* check that ERR_LIB_EC is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_EVP(unsigned long long *o)
{
  int n = (ERR_LIB_EVP) <= 0;
  *o = (unsigned long long)((ERR_LIB_EVP) | 0);  /* check that ERR_LIB_EVP is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_PEM(unsigned long long *o)
{
  int n = (ERR_LIB_PEM) <= 0;
  *o = (unsigned long long)((ERR_LIB_PEM) | 0);  /* check that ERR_LIB_PEM is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_PKCS12(unsigned long long *o)
{
  int n = (ERR_LIB_PKCS12) <= 0;
  *o = (unsigned long long)((ERR_LIB_PKCS12) | 0);  /* check that ERR_LIB_PKCS12 is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_RSA(unsigned long long *o)
{
  int n = (ERR_LIB_RSA) <= 0;
  *o = (unsigned long long)((ERR_LIB_RSA) | 0);  /* check that ERR_LIB_RSA is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_SSL(unsigned long long *o)
{
  int n = (ERR_LIB_SSL) <= 0;
  *o = (unsigned long long)((ERR_LIB_SSL) | 0);  /* check that ERR_LIB_SSL is an integer */
  return n;
}

static int _cffi_const_ERR_LIB_X509(unsigned long long *o)
{
  int n = (ERR_LIB_X509) <= 0;
  *o = (unsigned long long)((ERR_LIB_X509) | 0);  /* check that ERR_LIB_X509 is an integer */
  return n;
}

static int _cffi_const_EVP_CTRL_GCM_GET_TAG(unsigned long long *o)
{
  int n = (EVP_CTRL_GCM_GET_TAG) <= 0;
  *o = (unsigned long long)((EVP_CTRL_GCM_GET_TAG) | 0);  /* check that EVP_CTRL_GCM_GET_TAG is an integer */
  return n;
}

static int _cffi_const_EVP_CTRL_GCM_SET_IVLEN(unsigned long long *o)
{
  int n = (EVP_CTRL_GCM_SET_IVLEN) <= 0;
  *o = (unsigned long long)((EVP_CTRL_GCM_SET_IVLEN) | 0);  /* check that EVP_CTRL_GCM_SET_IVLEN is an integer */
  return n;
}

static int _cffi_const_EVP_CTRL_GCM_SET_TAG(unsigned long long *o)
{
  int n = (EVP_CTRL_GCM_SET_TAG) <= 0;
  *o = (unsigned long long)((EVP_CTRL_GCM_SET_TAG) | 0);  /* check that EVP_CTRL_GCM_SET_TAG is an integer */
  return n;
}

static int _cffi_const_EVP_F_AES_INIT_KEY(unsigned long long *o)
{
  int n = (EVP_F_AES_INIT_KEY) <= 0;
  *o = (unsigned long long)((EVP_F_AES_INIT_KEY) | 0);  /* check that EVP_F_AES_INIT_KEY is an integer */
  return n;
}

static int _cffi_const_EVP_F_CAMELLIA_INIT_KEY(unsigned long long *o)
{
  int n = (EVP_F_CAMELLIA_INIT_KEY) <= 0;
  *o = (unsigned long long)((EVP_F_CAMELLIA_INIT_KEY) | 0);  /* check that EVP_F_CAMELLIA_INIT_KEY is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_CIPHERINIT_EX(unsigned long long *o)
{
  int n = (EVP_F_EVP_CIPHERINIT_EX) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_CIPHERINIT_EX) | 0);  /* check that EVP_F_EVP_CIPHERINIT_EX is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_CIPHER_CTX_CTRL(unsigned long long *o)
{
  int n = (EVP_F_EVP_CIPHER_CTX_CTRL) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_CIPHER_CTX_CTRL) | 0);  /* check that EVP_F_EVP_CIPHER_CTX_CTRL is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH(unsigned long long *o)
{
  int n = (EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH) | 0);  /* check that EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_DECRYPTFINAL_EX(unsigned long long *o)
{
  int n = (EVP_F_EVP_DECRYPTFINAL_EX) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_DECRYPTFINAL_EX) | 0);  /* check that EVP_F_EVP_DECRYPTFINAL_EX is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_DIGESTINIT_EX(unsigned long long *o)
{
  int n = (EVP_F_EVP_DIGESTINIT_EX) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_DIGESTINIT_EX) | 0);  /* check that EVP_F_EVP_DIGESTINIT_EX is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_ENCRYPTFINAL_EX(unsigned long long *o)
{
  int n = (EVP_F_EVP_ENCRYPTFINAL_EX) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_ENCRYPTFINAL_EX) | 0);  /* check that EVP_F_EVP_ENCRYPTFINAL_EX is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_MD_CTX_COPY_EX(unsigned long long *o)
{
  int n = (EVP_F_EVP_MD_CTX_COPY_EX) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_MD_CTX_COPY_EX) | 0);  /* check that EVP_F_EVP_MD_CTX_COPY_EX is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_OPENINIT(unsigned long long *o)
{
  int n = (EVP_F_EVP_OPENINIT) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_OPENINIT) | 0);  /* check that EVP_F_EVP_OPENINIT is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PBE_ALG_ADD(unsigned long long *o)
{
  int n = (EVP_F_EVP_PBE_ALG_ADD) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PBE_ALG_ADD) | 0);  /* check that EVP_F_EVP_PBE_ALG_ADD is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PBE_CIPHERINIT(unsigned long long *o)
{
  int n = (EVP_F_EVP_PBE_CIPHERINIT) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PBE_CIPHERINIT) | 0);  /* check that EVP_F_EVP_PBE_CIPHERINIT is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PKCS82PKEY(unsigned long long *o)
{
  int n = (EVP_F_EVP_PKCS82PKEY) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PKCS82PKEY) | 0);  /* check that EVP_F_EVP_PKCS82PKEY is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PKEY_COPY_PARAMETERS(unsigned long long *o)
{
  int n = (EVP_F_EVP_PKEY_COPY_PARAMETERS) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PKEY_COPY_PARAMETERS) | 0);  /* check that EVP_F_EVP_PKEY_COPY_PARAMETERS is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PKEY_DECRYPT(unsigned long long *o)
{
  int n = (EVP_F_EVP_PKEY_DECRYPT) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PKEY_DECRYPT) | 0);  /* check that EVP_F_EVP_PKEY_DECRYPT is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PKEY_ENCRYPT(unsigned long long *o)
{
  int n = (EVP_F_EVP_PKEY_ENCRYPT) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PKEY_ENCRYPT) | 0);  /* check that EVP_F_EVP_PKEY_ENCRYPT is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_PKEY_NEW(unsigned long long *o)
{
  int n = (EVP_F_EVP_PKEY_NEW) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_PKEY_NEW) | 0);  /* check that EVP_F_EVP_PKEY_NEW is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_SIGNFINAL(unsigned long long *o)
{
  int n = (EVP_F_EVP_SIGNFINAL) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_SIGNFINAL) | 0);  /* check that EVP_F_EVP_SIGNFINAL is an integer */
  return n;
}

static int _cffi_const_EVP_F_EVP_VERIFYFINAL(unsigned long long *o)
{
  int n = (EVP_F_EVP_VERIFYFINAL) <= 0;
  *o = (unsigned long long)((EVP_F_EVP_VERIFYFINAL) | 0);  /* check that EVP_F_EVP_VERIFYFINAL is an integer */
  return n;
}

static int _cffi_const_EVP_F_PKCS5_PBE_KEYIVGEN(unsigned long long *o)
{
  int n = (EVP_F_PKCS5_PBE_KEYIVGEN) <= 0;
  *o = (unsigned long long)((EVP_F_PKCS5_PBE_KEYIVGEN) | 0);  /* check that EVP_F_PKCS5_PBE_KEYIVGEN is an integer */
  return n;
}

static int _cffi_const_EVP_F_PKCS5_V2_PBE_KEYIVGEN(unsigned long long *o)
{
  int n = (EVP_F_PKCS5_V2_PBE_KEYIVGEN) <= 0;
  *o = (unsigned long long)((EVP_F_PKCS5_V2_PBE_KEYIVGEN) | 0);  /* check that EVP_F_PKCS5_V2_PBE_KEYIVGEN is an integer */
  return n;
}

static int _cffi_const_EVP_F_RC2_MAGIC_TO_METH(unsigned long long *o)
{
  int n = (EVP_F_RC2_MAGIC_TO_METH) <= 0;
  *o = (unsigned long long)((EVP_F_RC2_MAGIC_TO_METH) | 0);  /* check that EVP_F_RC2_MAGIC_TO_METH is an integer */
  return n;
}

static int _cffi_const_EVP_F_RC5_CTRL(unsigned long long *o)
{
  int n = (EVP_F_RC5_CTRL) <= 0;
  *o = (unsigned long long)((EVP_F_RC5_CTRL) | 0);  /* check that EVP_F_RC5_CTRL is an integer */
  return n;
}

static int _cffi_const_EVP_MAX_MD_SIZE(unsigned long long *o)
{
  int n = (EVP_MAX_MD_SIZE) <= 0;
  *o = (unsigned long long)((EVP_MAX_MD_SIZE) | 0);  /* check that EVP_MAX_MD_SIZE is an integer */
  return n;
}

static int _cffi_const_EVP_PKEY_DH(unsigned long long *o)
{
  int n = (EVP_PKEY_DH) <= 0;
  *o = (unsigned long long)((EVP_PKEY_DH) | 0);  /* check that EVP_PKEY_DH is an integer */
  return n;
}

static int _cffi_const_EVP_PKEY_DHX(unsigned long long *o)
{
  int n = (EVP_PKEY_DHX) <= 0;
  *o = (unsigned long long)((EVP_PKEY_DHX) | 0);  /* check that EVP_PKEY_DHX is an integer */
  return n;
}

static int _cffi_const_EVP_PKEY_DSA(unsigned long long *o)
{
  int n = (EVP_PKEY_DSA) <= 0;
  *o = (unsigned long long)((EVP_PKEY_DSA) | 0);  /* check that EVP_PKEY_DSA is an integer */
  return n;
}

static int _cffi_const_EVP_PKEY_EC(unsigned long long *o)
{
  int n = (EVP_PKEY_EC) <= 0;
  *o = (unsigned long long)((EVP_PKEY_EC) | 0);  /* check that EVP_PKEY_EC is an integer */
  return n;
}

static int _cffi_const_EVP_PKEY_RSA(unsigned long long *o)
{
  int n = (EVP_PKEY_RSA) <= 0;
  *o = (unsigned long long)((EVP_PKEY_RSA) | 0);  /* check that EVP_PKEY_RSA is an integer */
  return n;
}

static int _cffi_const_EVP_R_AES_KEY_SETUP_FAILED(unsigned long long *o)
{
  int n = (EVP_R_AES_KEY_SETUP_FAILED) <= 0;
  *o = (unsigned long long)((EVP_R_AES_KEY_SETUP_FAILED) | 0);  /* check that EVP_R_AES_KEY_SETUP_FAILED is an integer */
  return n;
}

static int _cffi_const_EVP_R_BAD_DECRYPT(unsigned long long *o)
{
  int n = (EVP_R_BAD_DECRYPT) <= 0;
  *o = (unsigned long long)((EVP_R_BAD_DECRYPT) | 0);  /* check that EVP_R_BAD_DECRYPT is an integer */
  return n;
}

static int _cffi_const_EVP_R_CAMELLIA_KEY_SETUP_FAILED(unsigned long long *o)
{
  int n = (EVP_R_CAMELLIA_KEY_SETUP_FAILED) <= 0;
  *o = (unsigned long long)((EVP_R_CAMELLIA_KEY_SETUP_FAILED) | 0);  /* check that EVP_R_CAMELLIA_KEY_SETUP_FAILED is an integer */
  return n;
}

static int _cffi_const_EVP_R_CIPHER_PARAMETER_ERROR(unsigned long long *o)
{
  int n = (EVP_R_CIPHER_PARAMETER_ERROR) <= 0;
  *o = (unsigned long long)((EVP_R_CIPHER_PARAMETER_ERROR) | 0);  /* check that EVP_R_CIPHER_PARAMETER_ERROR is an integer */
  return n;
}

static int _cffi_const_EVP_R_CTRL_NOT_IMPLEMENTED(unsigned long long *o)
{
  int n = (EVP_R_CTRL_NOT_IMPLEMENTED) <= 0;
  *o = (unsigned long long)((EVP_R_CTRL_NOT_IMPLEMENTED) | 0);  /* check that EVP_R_CTRL_NOT_IMPLEMENTED is an integer */
  return n;
}

static int _cffi_const_EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED(unsigned long long *o)
{
  int n = (EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED) <= 0;
  *o = (unsigned long long)((EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED) | 0);  /* check that EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED is an integer */
  return n;
}

static int _cffi_const_EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH(unsigned long long *o)
{
  int n = (EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH) <= 0;
  *o = (unsigned long long)((EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH) | 0);  /* check that EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH is an integer */
  return n;
}

static int _cffi_const_EVP_R_DECODE_ERROR(unsigned long long *o)
{
  int n = (EVP_R_DECODE_ERROR) <= 0;
  *o = (unsigned long long)((EVP_R_DECODE_ERROR) | 0);  /* check that EVP_R_DECODE_ERROR is an integer */
  return n;
}

static int _cffi_const_EVP_R_DIFFERENT_KEY_TYPES(unsigned long long *o)
{
  int n = (EVP_R_DIFFERENT_KEY_TYPES) <= 0;
  *o = (unsigned long long)((EVP_R_DIFFERENT_KEY_TYPES) | 0);  /* check that EVP_R_DIFFERENT_KEY_TYPES is an integer */
  return n;
}

static int _cffi_const_EVP_R_INITIALIZATION_ERROR(unsigned long long *o)
{
  int n = (EVP_R_INITIALIZATION_ERROR) <= 0;
  *o = (unsigned long long)((EVP_R_INITIALIZATION_ERROR) | 0);  /* check that EVP_R_INITIALIZATION_ERROR is an integer */
  return n;
}

static int _cffi_const_EVP_R_INPUT_NOT_INITIALIZED(unsigned long long *o)
{
  int n = (EVP_R_INPUT_NOT_INITIALIZED) <= 0;
  *o = (unsigned long long)((EVP_R_INPUT_NOT_INITIALIZED) | 0);  /* check that EVP_R_INPUT_NOT_INITIALIZED is an integer */
  return n;
}

static int _cffi_const_EVP_R_INVALID_KEY_LENGTH(unsigned long long *o)
{
  int n = (EVP_R_INVALID_KEY_LENGTH) <= 0;
  *o = (unsigned long long)((EVP_R_INVALID_KEY_LENGTH) | 0);  /* check that EVP_R_INVALID_KEY_LENGTH is an integer */
  return n;
}

static int _cffi_const_EVP_R_KEYGEN_FAILURE(unsigned long long *o)
{
  int n = (EVP_R_KEYGEN_FAILURE) <= 0;
  *o = (unsigned long long)((EVP_R_KEYGEN_FAILURE) | 0);  /* check that EVP_R_KEYGEN_FAILURE is an integer */
  return n;
}

static int _cffi_const_EVP_R_MISSING_PARAMETERS(unsigned long long *o)
{
  int n = (EVP_R_MISSING_PARAMETERS) <= 0;
  *o = (unsigned long long)((EVP_R_MISSING_PARAMETERS) | 0);  /* check that EVP_R_MISSING_PARAMETERS is an integer */
  return n;
}

static int _cffi_const_EVP_R_NO_CIPHER_SET(unsigned long long *o)
{
  int n = (EVP_R_NO_CIPHER_SET) <= 0;
  *o = (unsigned long long)((EVP_R_NO_CIPHER_SET) | 0);  /* check that EVP_R_NO_CIPHER_SET is an integer */
  return n;
}

static int _cffi_const_EVP_R_NO_DIGEST_SET(unsigned long long *o)
{
  int n = (EVP_R_NO_DIGEST_SET) <= 0;
  *o = (unsigned long long)((EVP_R_NO_DIGEST_SET) | 0);  /* check that EVP_R_NO_DIGEST_SET is an integer */
  return n;
}

static int _cffi_const_EVP_R_PUBLIC_KEY_NOT_RSA(unsigned long long *o)
{
  int n = (EVP_R_PUBLIC_KEY_NOT_RSA) <= 0;
  *o = (unsigned long long)((EVP_R_PUBLIC_KEY_NOT_RSA) | 0);  /* check that EVP_R_PUBLIC_KEY_NOT_RSA is an integer */
  return n;
}

static int _cffi_const_EVP_R_UNKNOWN_PBE_ALGORITHM(unsigned long long *o)
{
  int n = (EVP_R_UNKNOWN_PBE_ALGORITHM) <= 0;
  *o = (unsigned long long)((EVP_R_UNKNOWN_PBE_ALGORITHM) | 0);  /* check that EVP_R_UNKNOWN_PBE_ALGORITHM is an integer */
  return n;
}

static int _cffi_const_EVP_R_UNSUPPORTED_CIPHER(unsigned long long *o)
{
  int n = (EVP_R_UNSUPPORTED_CIPHER) <= 0;
  *o = (unsigned long long)((EVP_R_UNSUPPORTED_CIPHER) | 0);  /* check that EVP_R_UNSUPPORTED_CIPHER is an integer */
  return n;
}

static int _cffi_const_EVP_R_UNSUPPORTED_KEYLENGTH(unsigned long long *o)
{
  int n = (EVP_R_UNSUPPORTED_KEYLENGTH) <= 0;
  *o = (unsigned long long)((EVP_R_UNSUPPORTED_KEYLENGTH) | 0);  /* check that EVP_R_UNSUPPORTED_KEYLENGTH is an integer */
  return n;
}

static int _cffi_const_EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION(unsigned long long *o)
{
  int n = (EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION) <= 0;
  *o = (unsigned long long)((EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION) | 0);  /* check that EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION is an integer */
  return n;
}

static int _cffi_const_EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM(unsigned long long *o)
{
  int n = (EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM) <= 0;
  *o = (unsigned long long)((EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM) | 0);  /* check that EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM is an integer */
  return n;
}

static int _cffi_const_EVP_R_UNSUPPORTED_SALT_TYPE(unsigned long long *o)
{
  int n = (EVP_R_UNSUPPORTED_SALT_TYPE) <= 0;
  *o = (unsigned long long)((EVP_R_UNSUPPORTED_SALT_TYPE) | 0);  /* check that EVP_R_UNSUPPORTED_SALT_TYPE is an integer */
  return n;
}

static int _cffi_const_EVP_R_WRONG_FINAL_BLOCK_LENGTH(unsigned long long *o)
{
  int n = (EVP_R_WRONG_FINAL_BLOCK_LENGTH) <= 0;
  *o = (unsigned long long)((EVP_R_WRONG_FINAL_BLOCK_LENGTH) | 0);  /* check that EVP_R_WRONG_FINAL_BLOCK_LENGTH is an integer */
  return n;
}

static int _cffi_const_GEN_DIRNAME(unsigned long long *o)
{
  int n = (GEN_DIRNAME) <= 0;
  *o = (unsigned long long)((GEN_DIRNAME) | 0);  /* check that GEN_DIRNAME is an integer */
  return n;
}

static int _cffi_const_GEN_DNS(unsigned long long *o)
{
  int n = (GEN_DNS) <= 0;
  *o = (unsigned long long)((GEN_DNS) | 0);  /* check that GEN_DNS is an integer */
  return n;
}

static int _cffi_const_GEN_EDIPARTY(unsigned long long *o)
{
  int n = (GEN_EDIPARTY) <= 0;
  *o = (unsigned long long)((GEN_EDIPARTY) | 0);  /* check that GEN_EDIPARTY is an integer */
  return n;
}

static int _cffi_const_GEN_EMAIL(unsigned long long *o)
{
  int n = (GEN_EMAIL) <= 0;
  *o = (unsigned long long)((GEN_EMAIL) | 0);  /* check that GEN_EMAIL is an integer */
  return n;
}

static int _cffi_const_GEN_IPADD(unsigned long long *o)
{
  int n = (GEN_IPADD) <= 0;
  *o = (unsigned long long)((GEN_IPADD) | 0);  /* check that GEN_IPADD is an integer */
  return n;
}

static int _cffi_const_GEN_OTHERNAME(unsigned long long *o)
{
  int n = (GEN_OTHERNAME) <= 0;
  *o = (unsigned long long)((GEN_OTHERNAME) | 0);  /* check that GEN_OTHERNAME is an integer */
  return n;
}

static int _cffi_const_GEN_RID(unsigned long long *o)
{
  int n = (GEN_RID) <= 0;
  *o = (unsigned long long)((GEN_RID) | 0);  /* check that GEN_RID is an integer */
  return n;
}

static int _cffi_const_GEN_URI(unsigned long long *o)
{
  int n = (GEN_URI) <= 0;
  *o = (unsigned long long)((GEN_URI) | 0);  /* check that GEN_URI is an integer */
  return n;
}

static int _cffi_const_GEN_X400(unsigned long long *o)
{
  int n = (GEN_X400) <= 0;
  *o = (unsigned long long)((GEN_X400) | 0);  /* check that GEN_X400 is an integer */
  return n;
}

static int _cffi_const_MBSTRING_ASC(unsigned long long *o)
{
  int n = (MBSTRING_ASC) <= 0;
  *o = (unsigned long long)((MBSTRING_ASC) | 0);  /* check that MBSTRING_ASC is an integer */
  return n;
}

static int _cffi_const_MBSTRING_BMP(unsigned long long *o)
{
  int n = (MBSTRING_BMP) <= 0;
  *o = (unsigned long long)((MBSTRING_BMP) | 0);  /* check that MBSTRING_BMP is an integer */
  return n;
}

static int _cffi_const_MBSTRING_FLAG(unsigned long long *o)
{
  int n = (MBSTRING_FLAG) <= 0;
  *o = (unsigned long long)((MBSTRING_FLAG) | 0);  /* check that MBSTRING_FLAG is an integer */
  return n;
}

static int _cffi_const_MBSTRING_UNIV(unsigned long long *o)
{
  int n = (MBSTRING_UNIV) <= 0;
  *o = (unsigned long long)((MBSTRING_UNIV) | 0);  /* check that MBSTRING_UNIV is an integer */
  return n;
}

static int _cffi_const_MBSTRING_UTF8(unsigned long long *o)
{
  int n = (MBSTRING_UTF8) <= 0;
  *o = (unsigned long long)((MBSTRING_UTF8) | 0);  /* check that MBSTRING_UTF8 is an integer */
  return n;
}

static int _cffi_const_NID_X25519(unsigned long long *o)
{
  int n = (NID_X25519) <= 0;
  *o = (unsigned long long)((NID_X25519) | 0);  /* check that NID_X25519 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2onb191v4(unsigned long long *o)
{
  int n = (NID_X9_62_c2onb191v4) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2onb191v4) | 0);  /* check that NID_X9_62_c2onb191v4 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2onb191v5(unsigned long long *o)
{
  int n = (NID_X9_62_c2onb191v5) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2onb191v5) | 0);  /* check that NID_X9_62_c2onb191v5 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2onb239v4(unsigned long long *o)
{
  int n = (NID_X9_62_c2onb239v4) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2onb239v4) | 0);  /* check that NID_X9_62_c2onb239v4 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2onb239v5(unsigned long long *o)
{
  int n = (NID_X9_62_c2onb239v5) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2onb239v5) | 0);  /* check that NID_X9_62_c2onb239v5 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb163v1(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb163v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb163v1) | 0);  /* check that NID_X9_62_c2pnb163v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb163v2(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb163v2) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb163v2) | 0);  /* check that NID_X9_62_c2pnb163v2 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb163v3(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb163v3) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb163v3) | 0);  /* check that NID_X9_62_c2pnb163v3 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb176v1(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb176v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb176v1) | 0);  /* check that NID_X9_62_c2pnb176v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb208w1(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb208w1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb208w1) | 0);  /* check that NID_X9_62_c2pnb208w1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb272w1(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb272w1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb272w1) | 0);  /* check that NID_X9_62_c2pnb272w1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb304w1(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb304w1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb304w1) | 0);  /* check that NID_X9_62_c2pnb304w1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2pnb368w1(unsigned long long *o)
{
  int n = (NID_X9_62_c2pnb368w1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2pnb368w1) | 0);  /* check that NID_X9_62_c2pnb368w1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb191v1(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb191v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb191v1) | 0);  /* check that NID_X9_62_c2tnb191v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb191v2(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb191v2) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb191v2) | 0);  /* check that NID_X9_62_c2tnb191v2 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb191v3(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb191v3) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb191v3) | 0);  /* check that NID_X9_62_c2tnb191v3 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb239v1(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb239v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb239v1) | 0);  /* check that NID_X9_62_c2tnb239v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb239v2(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb239v2) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb239v2) | 0);  /* check that NID_X9_62_c2tnb239v2 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb239v3(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb239v3) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb239v3) | 0);  /* check that NID_X9_62_c2tnb239v3 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb359v1(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb359v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb359v1) | 0);  /* check that NID_X9_62_c2tnb359v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_c2tnb431r1(unsigned long long *o)
{
  int n = (NID_X9_62_c2tnb431r1) <= 0;
  *o = (unsigned long long)((NID_X9_62_c2tnb431r1) | 0);  /* check that NID_X9_62_c2tnb431r1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime192v1(unsigned long long *o)
{
  int n = (NID_X9_62_prime192v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime192v1) | 0);  /* check that NID_X9_62_prime192v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime192v2(unsigned long long *o)
{
  int n = (NID_X9_62_prime192v2) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime192v2) | 0);  /* check that NID_X9_62_prime192v2 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime192v3(unsigned long long *o)
{
  int n = (NID_X9_62_prime192v3) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime192v3) | 0);  /* check that NID_X9_62_prime192v3 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime239v1(unsigned long long *o)
{
  int n = (NID_X9_62_prime239v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime239v1) | 0);  /* check that NID_X9_62_prime239v1 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime239v2(unsigned long long *o)
{
  int n = (NID_X9_62_prime239v2) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime239v2) | 0);  /* check that NID_X9_62_prime239v2 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime239v3(unsigned long long *o)
{
  int n = (NID_X9_62_prime239v3) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime239v3) | 0);  /* check that NID_X9_62_prime239v3 is an integer */
  return n;
}

static int _cffi_const_NID_X9_62_prime256v1(unsigned long long *o)
{
  int n = (NID_X9_62_prime256v1) <= 0;
  *o = (unsigned long long)((NID_X9_62_prime256v1) | 0);  /* check that NID_X9_62_prime256v1 is an integer */
  return n;
}

static int _cffi_const_NID_ad_OCSP(unsigned long long *o)
{
  int n = (NID_ad_OCSP) <= 0;
  *o = (unsigned long long)((NID_ad_OCSP) | 0);  /* check that NID_ad_OCSP is an integer */
  return n;
}

static int _cffi_const_NID_ad_ca_issuers(unsigned long long *o)
{
  int n = (NID_ad_ca_issuers) <= 0;
  *o = (unsigned long long)((NID_ad_ca_issuers) | 0);  /* check that NID_ad_ca_issuers is an integer */
  return n;
}

static int _cffi_const_NID_any_policy(unsigned long long *o)
{
  int n = (NID_any_policy) <= 0;
  *o = (unsigned long long)((NID_any_policy) | 0);  /* check that NID_any_policy is an integer */
  return n;
}

static int _cffi_const_NID_authority_key_identifier(unsigned long long *o)
{
  int n = (NID_authority_key_identifier) <= 0;
  *o = (unsigned long long)((NID_authority_key_identifier) | 0);  /* check that NID_authority_key_identifier is an integer */
  return n;
}

static int _cffi_const_NID_basic_constraints(unsigned long long *o)
{
  int n = (NID_basic_constraints) <= 0;
  *o = (unsigned long long)((NID_basic_constraints) | 0);  /* check that NID_basic_constraints is an integer */
  return n;
}

static int _cffi_const_NID_certificate_issuer(unsigned long long *o)
{
  int n = (NID_certificate_issuer) <= 0;
  *o = (unsigned long long)((NID_certificate_issuer) | 0);  /* check that NID_certificate_issuer is an integer */
  return n;
}

static int _cffi_const_NID_certificate_policies(unsigned long long *o)
{
  int n = (NID_certificate_policies) <= 0;
  *o = (unsigned long long)((NID_certificate_policies) | 0);  /* check that NID_certificate_policies is an integer */
  return n;
}

static int _cffi_const_NID_commonName(unsigned long long *o)
{
  int n = (NID_commonName) <= 0;
  *o = (unsigned long long)((NID_commonName) | 0);  /* check that NID_commonName is an integer */
  return n;
}

static int _cffi_const_NID_countryName(unsigned long long *o)
{
  int n = (NID_countryName) <= 0;
  *o = (unsigned long long)((NID_countryName) | 0);  /* check that NID_countryName is an integer */
  return n;
}

static int _cffi_const_NID_crl_distribution_points(unsigned long long *o)
{
  int n = (NID_crl_distribution_points) <= 0;
  *o = (unsigned long long)((NID_crl_distribution_points) | 0);  /* check that NID_crl_distribution_points is an integer */
  return n;
}

static int _cffi_const_NID_crl_number(unsigned long long *o)
{
  int n = (NID_crl_number) <= 0;
  *o = (unsigned long long)((NID_crl_number) | 0);  /* check that NID_crl_number is an integer */
  return n;
}

static int _cffi_const_NID_crl_reason(unsigned long long *o)
{
  int n = (NID_crl_reason) <= 0;
  *o = (unsigned long long)((NID_crl_reason) | 0);  /* check that NID_crl_reason is an integer */
  return n;
}

static int _cffi_const_NID_delta_crl(unsigned long long *o)
{
  int n = (NID_delta_crl) <= 0;
  *o = (unsigned long long)((NID_delta_crl) | 0);  /* check that NID_delta_crl is an integer */
  return n;
}

static int _cffi_const_NID_dnQualifier(unsigned long long *o)
{
  int n = (NID_dnQualifier) <= 0;
  *o = (unsigned long long)((NID_dnQualifier) | 0);  /* check that NID_dnQualifier is an integer */
  return n;
}

static int _cffi_const_NID_domainComponent(unsigned long long *o)
{
  int n = (NID_domainComponent) <= 0;
  *o = (unsigned long long)((NID_domainComponent) | 0);  /* check that NID_domainComponent is an integer */
  return n;
}

static int _cffi_const_NID_dsa(unsigned long long *o)
{
  int n = (NID_dsa) <= 0;
  *o = (unsigned long long)((NID_dsa) | 0);  /* check that NID_dsa is an integer */
  return n;
}

static int _cffi_const_NID_dsaWithSHA(unsigned long long *o)
{
  int n = (NID_dsaWithSHA) <= 0;
  *o = (unsigned long long)((NID_dsaWithSHA) | 0);  /* check that NID_dsaWithSHA is an integer */
  return n;
}

static int _cffi_const_NID_dsaWithSHA1(unsigned long long *o)
{
  int n = (NID_dsaWithSHA1) <= 0;
  *o = (unsigned long long)((NID_dsaWithSHA1) | 0);  /* check that NID_dsaWithSHA1 is an integer */
  return n;
}

static int _cffi_const_NID_ecdsa_with_SHA1(unsigned long long *o)
{
  int n = (NID_ecdsa_with_SHA1) <= 0;
  *o = (unsigned long long)((NID_ecdsa_with_SHA1) | 0);  /* check that NID_ecdsa_with_SHA1 is an integer */
  return n;
}

static int _cffi_const_NID_ecdsa_with_SHA224(unsigned long long *o)
{
  int n = (NID_ecdsa_with_SHA224) <= 0;
  *o = (unsigned long long)((NID_ecdsa_with_SHA224) | 0);  /* check that NID_ecdsa_with_SHA224 is an integer */
  return n;
}

static int _cffi_const_NID_ecdsa_with_SHA256(unsigned long long *o)
{
  int n = (NID_ecdsa_with_SHA256) <= 0;
  *o = (unsigned long long)((NID_ecdsa_with_SHA256) | 0);  /* check that NID_ecdsa_with_SHA256 is an integer */
  return n;
}

static int _cffi_const_NID_ecdsa_with_SHA384(unsigned long long *o)
{
  int n = (NID_ecdsa_with_SHA384) <= 0;
  *o = (unsigned long long)((NID_ecdsa_with_SHA384) | 0);  /* check that NID_ecdsa_with_SHA384 is an integer */
  return n;
}

static int _cffi_const_NID_ecdsa_with_SHA512(unsigned long long *o)
{
  int n = (NID_ecdsa_with_SHA512) <= 0;
  *o = (unsigned long long)((NID_ecdsa_with_SHA512) | 0);  /* check that NID_ecdsa_with_SHA512 is an integer */
  return n;
}

static int _cffi_const_NID_ext_key_usage(unsigned long long *o)
{
  int n = (NID_ext_key_usage) <= 0;
  *o = (unsigned long long)((NID_ext_key_usage) | 0);  /* check that NID_ext_key_usage is an integer */
  return n;
}

static int _cffi_const_NID_generationQualifier(unsigned long long *o)
{
  int n = (NID_generationQualifier) <= 0;
  *o = (unsigned long long)((NID_generationQualifier) | 0);  /* check that NID_generationQualifier is an integer */
  return n;
}

static int _cffi_const_NID_givenName(unsigned long long *o)
{
  int n = (NID_givenName) <= 0;
  *o = (unsigned long long)((NID_givenName) | 0);  /* check that NID_givenName is an integer */
  return n;
}

static int _cffi_const_NID_info_access(unsigned long long *o)
{
  int n = (NID_info_access) <= 0;
  *o = (unsigned long long)((NID_info_access) | 0);  /* check that NID_info_access is an integer */
  return n;
}

static int _cffi_const_NID_inhibit_any_policy(unsigned long long *o)
{
  int n = (NID_inhibit_any_policy) <= 0;
  *o = (unsigned long long)((NID_inhibit_any_policy) | 0);  /* check that NID_inhibit_any_policy is an integer */
  return n;
}

static int _cffi_const_NID_invalidity_date(unsigned long long *o)
{
  int n = (NID_invalidity_date) <= 0;
  *o = (unsigned long long)((NID_invalidity_date) | 0);  /* check that NID_invalidity_date is an integer */
  return n;
}

static int _cffi_const_NID_ipsec3(unsigned long long *o)
{
  int n = (NID_ipsec3) <= 0;
  *o = (unsigned long long)((NID_ipsec3) | 0);  /* check that NID_ipsec3 is an integer */
  return n;
}

static int _cffi_const_NID_ipsec4(unsigned long long *o)
{
  int n = (NID_ipsec4) <= 0;
  *o = (unsigned long long)((NID_ipsec4) | 0);  /* check that NID_ipsec4 is an integer */
  return n;
}

static int _cffi_const_NID_issuer_alt_name(unsigned long long *o)
{
  int n = (NID_issuer_alt_name) <= 0;
  *o = (unsigned long long)((NID_issuer_alt_name) | 0);  /* check that NID_issuer_alt_name is an integer */
  return n;
}

static int _cffi_const_NID_issuing_distribution_point(unsigned long long *o)
{
  int n = (NID_issuing_distribution_point) <= 0;
  *o = (unsigned long long)((NID_issuing_distribution_point) | 0);  /* check that NID_issuing_distribution_point is an integer */
  return n;
}

static int _cffi_const_NID_key_usage(unsigned long long *o)
{
  int n = (NID_key_usage) <= 0;
  *o = (unsigned long long)((NID_key_usage) | 0);  /* check that NID_key_usage is an integer */
  return n;
}

static int _cffi_const_NID_localityName(unsigned long long *o)
{
  int n = (NID_localityName) <= 0;
  *o = (unsigned long long)((NID_localityName) | 0);  /* check that NID_localityName is an integer */
  return n;
}

static int _cffi_const_NID_md2(unsigned long long *o)
{
  int n = (NID_md2) <= 0;
  *o = (unsigned long long)((NID_md2) | 0);  /* check that NID_md2 is an integer */
  return n;
}

static int _cffi_const_NID_md4(unsigned long long *o)
{
  int n = (NID_md4) <= 0;
  *o = (unsigned long long)((NID_md4) | 0);  /* check that NID_md4 is an integer */
  return n;
}

static int _cffi_const_NID_md5(unsigned long long *o)
{
  int n = (NID_md5) <= 0;
  *o = (unsigned long long)((NID_md5) | 0);  /* check that NID_md5 is an integer */
  return n;
}

static int _cffi_const_NID_mdc2(unsigned long long *o)
{
  int n = (NID_mdc2) <= 0;
  *o = (unsigned long long)((NID_mdc2) | 0);  /* check that NID_mdc2 is an integer */
  return n;
}

static int _cffi_const_NID_name_constraints(unsigned long long *o)
{
  int n = (NID_name_constraints) <= 0;
  *o = (unsigned long long)((NID_name_constraints) | 0);  /* check that NID_name_constraints is an integer */
  return n;
}

static int _cffi_const_NID_no_rev_avail(unsigned long long *o)
{
  int n = (NID_no_rev_avail) <= 0;
  *o = (unsigned long long)((NID_no_rev_avail) | 0);  /* check that NID_no_rev_avail is an integer */
  return n;
}

static int _cffi_const_NID_organizationName(unsigned long long *o)
{
  int n = (NID_organizationName) <= 0;
  *o = (unsigned long long)((NID_organizationName) | 0);  /* check that NID_organizationName is an integer */
  return n;
}

static int _cffi_const_NID_organizationalUnitName(unsigned long long *o)
{
  int n = (NID_organizationalUnitName) <= 0;
  *o = (unsigned long long)((NID_organizationalUnitName) | 0);  /* check that NID_organizationalUnitName is an integer */
  return n;
}

static int _cffi_const_NID_pbe_WithSHA1And3_Key_TripleDES_CBC(unsigned long long *o)
{
  int n = (NID_pbe_WithSHA1And3_Key_TripleDES_CBC) <= 0;
  *o = (unsigned long long)((NID_pbe_WithSHA1And3_Key_TripleDES_CBC) | 0);  /* check that NID_pbe_WithSHA1And3_Key_TripleDES_CBC is an integer */
  return n;
}

static int _cffi_const_NID_pkcs9_emailAddress(unsigned long long *o)
{
  int n = (NID_pkcs9_emailAddress) <= 0;
  *o = (unsigned long long)((NID_pkcs9_emailAddress) | 0);  /* check that NID_pkcs9_emailAddress is an integer */
  return n;
}

static int _cffi_const_NID_policy_constraints(unsigned long long *o)
{
  int n = (NID_policy_constraints) <= 0;
  *o = (unsigned long long)((NID_policy_constraints) | 0);  /* check that NID_policy_constraints is an integer */
  return n;
}

static int _cffi_const_NID_policy_mappings(unsigned long long *o)
{
  int n = (NID_policy_mappings) <= 0;
  *o = (unsigned long long)((NID_policy_mappings) | 0);  /* check that NID_policy_mappings is an integer */
  return n;
}

static int _cffi_const_NID_private_key_usage_period(unsigned long long *o)
{
  int n = (NID_private_key_usage_period) <= 0;
  *o = (unsigned long long)((NID_private_key_usage_period) | 0);  /* check that NID_private_key_usage_period is an integer */
  return n;
}

static int _cffi_const_NID_pseudonym(unsigned long long *o)
{
  int n = (NID_pseudonym) <= 0;
  *o = (unsigned long long)((NID_pseudonym) | 0);  /* check that NID_pseudonym is an integer */
  return n;
}

static int _cffi_const_NID_ripemd160(unsigned long long *o)
{
  int n = (NID_ripemd160) <= 0;
  *o = (unsigned long long)((NID_ripemd160) | 0);  /* check that NID_ripemd160 is an integer */
  return n;
}

static int _cffi_const_NID_secp112r1(unsigned long long *o)
{
  int n = (NID_secp112r1) <= 0;
  *o = (unsigned long long)((NID_secp112r1) | 0);  /* check that NID_secp112r1 is an integer */
  return n;
}

static int _cffi_const_NID_secp112r2(unsigned long long *o)
{
  int n = (NID_secp112r2) <= 0;
  *o = (unsigned long long)((NID_secp112r2) | 0);  /* check that NID_secp112r2 is an integer */
  return n;
}

static int _cffi_const_NID_secp128r1(unsigned long long *o)
{
  int n = (NID_secp128r1) <= 0;
  *o = (unsigned long long)((NID_secp128r1) | 0);  /* check that NID_secp128r1 is an integer */
  return n;
}

static int _cffi_const_NID_secp128r2(unsigned long long *o)
{
  int n = (NID_secp128r2) <= 0;
  *o = (unsigned long long)((NID_secp128r2) | 0);  /* check that NID_secp128r2 is an integer */
  return n;
}

static int _cffi_const_NID_secp160k1(unsigned long long *o)
{
  int n = (NID_secp160k1) <= 0;
  *o = (unsigned long long)((NID_secp160k1) | 0);  /* check that NID_secp160k1 is an integer */
  return n;
}

static int _cffi_const_NID_secp160r1(unsigned long long *o)
{
  int n = (NID_secp160r1) <= 0;
  *o = (unsigned long long)((NID_secp160r1) | 0);  /* check that NID_secp160r1 is an integer */
  return n;
}

static int _cffi_const_NID_secp160r2(unsigned long long *o)
{
  int n = (NID_secp160r2) <= 0;
  *o = (unsigned long long)((NID_secp160r2) | 0);  /* check that NID_secp160r2 is an integer */
  return n;
}

static int _cffi_const_NID_secp192k1(unsigned long long *o)
{
  int n = (NID_secp192k1) <= 0;
  *o = (unsigned long long)((NID_secp192k1) | 0);  /* check that NID_secp192k1 is an integer */
  return n;
}

static int _cffi_const_NID_secp224k1(unsigned long long *o)
{
  int n = (NID_secp224k1) <= 0;
  *o = (unsigned long long)((NID_secp224k1) | 0);  /* check that NID_secp224k1 is an integer */
  return n;
}

static int _cffi_const_NID_secp224r1(unsigned long long *o)
{
  int n = (NID_secp224r1) <= 0;
  *o = (unsigned long long)((NID_secp224r1) | 0);  /* check that NID_secp224r1 is an integer */
  return n;
}

static int _cffi_const_NID_secp256k1(unsigned long long *o)
{
  int n = (NID_secp256k1) <= 0;
  *o = (unsigned long long)((NID_secp256k1) | 0);  /* check that NID_secp256k1 is an integer */
  return n;
}

static int _cffi_const_NID_secp384r1(unsigned long long *o)
{
  int n = (NID_secp384r1) <= 0;
  *o = (unsigned long long)((NID_secp384r1) | 0);  /* check that NID_secp384r1 is an integer */
  return n;
}

static int _cffi_const_NID_secp521r1(unsigned long long *o)
{
  int n = (NID_secp521r1) <= 0;
  *o = (unsigned long long)((NID_secp521r1) | 0);  /* check that NID_secp521r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect113r1(unsigned long long *o)
{
  int n = (NID_sect113r1) <= 0;
  *o = (unsigned long long)((NID_sect113r1) | 0);  /* check that NID_sect113r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect113r2(unsigned long long *o)
{
  int n = (NID_sect113r2) <= 0;
  *o = (unsigned long long)((NID_sect113r2) | 0);  /* check that NID_sect113r2 is an integer */
  return n;
}

static int _cffi_const_NID_sect131r1(unsigned long long *o)
{
  int n = (NID_sect131r1) <= 0;
  *o = (unsigned long long)((NID_sect131r1) | 0);  /* check that NID_sect131r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect131r2(unsigned long long *o)
{
  int n = (NID_sect131r2) <= 0;
  *o = (unsigned long long)((NID_sect131r2) | 0);  /* check that NID_sect131r2 is an integer */
  return n;
}

static int _cffi_const_NID_sect163k1(unsigned long long *o)
{
  int n = (NID_sect163k1) <= 0;
  *o = (unsigned long long)((NID_sect163k1) | 0);  /* check that NID_sect163k1 is an integer */
  return n;
}

static int _cffi_const_NID_sect163r1(unsigned long long *o)
{
  int n = (NID_sect163r1) <= 0;
  *o = (unsigned long long)((NID_sect163r1) | 0);  /* check that NID_sect163r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect163r2(unsigned long long *o)
{
  int n = (NID_sect163r2) <= 0;
  *o = (unsigned long long)((NID_sect163r2) | 0);  /* check that NID_sect163r2 is an integer */
  return n;
}

static int _cffi_const_NID_sect193r1(unsigned long long *o)
{
  int n = (NID_sect193r1) <= 0;
  *o = (unsigned long long)((NID_sect193r1) | 0);  /* check that NID_sect193r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect193r2(unsigned long long *o)
{
  int n = (NID_sect193r2) <= 0;
  *o = (unsigned long long)((NID_sect193r2) | 0);  /* check that NID_sect193r2 is an integer */
  return n;
}

static int _cffi_const_NID_sect233k1(unsigned long long *o)
{
  int n = (NID_sect233k1) <= 0;
  *o = (unsigned long long)((NID_sect233k1) | 0);  /* check that NID_sect233k1 is an integer */
  return n;
}

static int _cffi_const_NID_sect233r1(unsigned long long *o)
{
  int n = (NID_sect233r1) <= 0;
  *o = (unsigned long long)((NID_sect233r1) | 0);  /* check that NID_sect233r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect239k1(unsigned long long *o)
{
  int n = (NID_sect239k1) <= 0;
  *o = (unsigned long long)((NID_sect239k1) | 0);  /* check that NID_sect239k1 is an integer */
  return n;
}

static int _cffi_const_NID_sect283k1(unsigned long long *o)
{
  int n = (NID_sect283k1) <= 0;
  *o = (unsigned long long)((NID_sect283k1) | 0);  /* check that NID_sect283k1 is an integer */
  return n;
}

static int _cffi_const_NID_sect283r1(unsigned long long *o)
{
  int n = (NID_sect283r1) <= 0;
  *o = (unsigned long long)((NID_sect283r1) | 0);  /* check that NID_sect283r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect409k1(unsigned long long *o)
{
  int n = (NID_sect409k1) <= 0;
  *o = (unsigned long long)((NID_sect409k1) | 0);  /* check that NID_sect409k1 is an integer */
  return n;
}

static int _cffi_const_NID_sect409r1(unsigned long long *o)
{
  int n = (NID_sect409r1) <= 0;
  *o = (unsigned long long)((NID_sect409r1) | 0);  /* check that NID_sect409r1 is an integer */
  return n;
}

static int _cffi_const_NID_sect571k1(unsigned long long *o)
{
  int n = (NID_sect571k1) <= 0;
  *o = (unsigned long long)((NID_sect571k1) | 0);  /* check that NID_sect571k1 is an integer */
  return n;
}

static int _cffi_const_NID_sect571r1(unsigned long long *o)
{
  int n = (NID_sect571r1) <= 0;
  *o = (unsigned long long)((NID_sect571r1) | 0);  /* check that NID_sect571r1 is an integer */
  return n;
}

static int _cffi_const_NID_serialNumber(unsigned long long *o)
{
  int n = (NID_serialNumber) <= 0;
  *o = (unsigned long long)((NID_serialNumber) | 0);  /* check that NID_serialNumber is an integer */
  return n;
}

static int _cffi_const_NID_sha(unsigned long long *o)
{
  int n = (NID_sha) <= 0;
  *o = (unsigned long long)((NID_sha) | 0);  /* check that NID_sha is an integer */
  return n;
}

static int _cffi_const_NID_sha1(unsigned long long *o)
{
  int n = (NID_sha1) <= 0;
  *o = (unsigned long long)((NID_sha1) | 0);  /* check that NID_sha1 is an integer */
  return n;
}

static int _cffi_const_NID_sha224(unsigned long long *o)
{
  int n = (NID_sha224) <= 0;
  *o = (unsigned long long)((NID_sha224) | 0);  /* check that NID_sha224 is an integer */
  return n;
}

static int _cffi_const_NID_sha256(unsigned long long *o)
{
  int n = (NID_sha256) <= 0;
  *o = (unsigned long long)((NID_sha256) | 0);  /* check that NID_sha256 is an integer */
  return n;
}

static int _cffi_const_NID_sha384(unsigned long long *o)
{
  int n = (NID_sha384) <= 0;
  *o = (unsigned long long)((NID_sha384) | 0);  /* check that NID_sha384 is an integer */
  return n;
}

static int _cffi_const_NID_sha512(unsigned long long *o)
{
  int n = (NID_sha512) <= 0;
  *o = (unsigned long long)((NID_sha512) | 0);  /* check that NID_sha512 is an integer */
  return n;
}

static int _cffi_const_NID_stateOrProvinceName(unsigned long long *o)
{
  int n = (NID_stateOrProvinceName) <= 0;
  *o = (unsigned long long)((NID_stateOrProvinceName) | 0);  /* check that NID_stateOrProvinceName is an integer */
  return n;
}

static int _cffi_const_NID_subject_alt_name(unsigned long long *o)
{
  int n = (NID_subject_alt_name) <= 0;
  *o = (unsigned long long)((NID_subject_alt_name) | 0);  /* check that NID_subject_alt_name is an integer */
  return n;
}

static int _cffi_const_NID_subject_key_identifier(unsigned long long *o)
{
  int n = (NID_subject_key_identifier) <= 0;
  *o = (unsigned long long)((NID_subject_key_identifier) | 0);  /* check that NID_subject_key_identifier is an integer */
  return n;
}

static int _cffi_const_NID_surname(unsigned long long *o)
{
  int n = (NID_surname) <= 0;
  *o = (unsigned long long)((NID_surname) | 0);  /* check that NID_surname is an integer */
  return n;
}

static int _cffi_const_NID_target_information(unsigned long long *o)
{
  int n = (NID_target_information) <= 0;
  *o = (unsigned long long)((NID_target_information) | 0);  /* check that NID_target_information is an integer */
  return n;
}

static int _cffi_const_NID_title(unsigned long long *o)
{
  int n = (NID_title) <= 0;
  *o = (unsigned long long)((NID_title) | 0);  /* check that NID_title is an integer */
  return n;
}

static int _cffi_const_NID_undef(unsigned long long *o)
{
  int n = (NID_undef) <= 0;
  *o = (unsigned long long)((NID_undef) | 0);  /* check that NID_undef is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls1(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls1) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls1) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls1 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls10(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls10) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls10) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls10 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls11(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls11) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls11) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls11 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls12(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls12) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls12) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls12 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls3(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls3) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls3) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls3 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls4(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls4) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls4) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls4 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls5(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls5) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls5) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls5 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls6(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls6) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls6) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls6 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls7(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls7) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls7) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls7 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls8(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls8) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls8) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls8 is an integer */
  return n;
}

static int _cffi_const_NID_wap_wsg_idm_ecid_wtls9(unsigned long long *o)
{
  int n = (NID_wap_wsg_idm_ecid_wtls9) <= 0;
  *o = (unsigned long long)((NID_wap_wsg_idm_ecid_wtls9) | 0);  /* check that NID_wap_wsg_idm_ecid_wtls9 is an integer */
  return n;
}

static int _cffi_const_OBJ_NAME_TYPE_MD_METH(unsigned long long *o)
{
  int n = (OBJ_NAME_TYPE_MD_METH) <= 0;
  *o = (unsigned long long)((OBJ_NAME_TYPE_MD_METH) | 0);  /* check that OBJ_NAME_TYPE_MD_METH is an integer */
  return n;
}

static int _cffi_const_OPENSSL_BUILT_ON(unsigned long long *o)
{
  int n = (OPENSSL_BUILT_ON) <= 0;
  *o = (unsigned long long)((OPENSSL_BUILT_ON) | 0);  /* check that OPENSSL_BUILT_ON is an integer */
  return n;
}

static int _cffi_const_OPENSSL_CFLAGS(unsigned long long *o)
{
  int n = (OPENSSL_CFLAGS) <= 0;
  *o = (unsigned long long)((OPENSSL_CFLAGS) | 0);  /* check that OPENSSL_CFLAGS is an integer */
  return n;
}

static int _cffi_const_OPENSSL_DIR(unsigned long long *o)
{
  int n = (OPENSSL_DIR) <= 0;
  *o = (unsigned long long)((OPENSSL_DIR) | 0);  /* check that OPENSSL_DIR is an integer */
  return n;
}

static int _cffi_const_OPENSSL_EC_NAMED_CURVE(unsigned long long *o)
{
  int n = (OPENSSL_EC_NAMED_CURVE) <= 0;
  *o = (unsigned long long)((OPENSSL_EC_NAMED_CURVE) | 0);  /* check that OPENSSL_EC_NAMED_CURVE is an integer */
  return n;
}

static int _cffi_const_OPENSSL_NPN_NEGOTIATED(unsigned long long *o)
{
  int n = (OPENSSL_NPN_NEGOTIATED) <= 0;
  *o = (unsigned long long)((OPENSSL_NPN_NEGOTIATED) | 0);  /* check that OPENSSL_NPN_NEGOTIATED is an integer */
  return n;
}

static int _cffi_const_OPENSSL_PLATFORM(unsigned long long *o)
{
  int n = (OPENSSL_PLATFORM) <= 0;
  *o = (unsigned long long)((OPENSSL_PLATFORM) | 0);  /* check that OPENSSL_PLATFORM is an integer */
  return n;
}

static int _cffi_const_OPENSSL_VERSION(unsigned long long *o)
{
  int n = (OPENSSL_VERSION) <= 0;
  *o = (unsigned long long)((OPENSSL_VERSION) | 0);  /* check that OPENSSL_VERSION is an integer */
  return n;
}

static int _cffi_const_OPENSSL_VERSION_NUMBER(unsigned long long *o)
{
  int n = (OPENSSL_VERSION_NUMBER) <= 0;
  *o = (unsigned long long)((OPENSSL_VERSION_NUMBER) | 0);  /* check that OPENSSL_VERSION_NUMBER is an integer */
  return n;
}

static void _cffi_const_OPENSSL_VERSION_TEXT(char *o)
{
  *(char const * *)o = OPENSSL_VERSION_TEXT;
}

static int _cffi_const_PEM_F_D2I_PKCS8PRIVATEKEY_BIO(unsigned long long *o)
{
  int n = (PEM_F_D2I_PKCS8PRIVATEKEY_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_D2I_PKCS8PRIVATEKEY_BIO) | 0);  /* check that PEM_F_D2I_PKCS8PRIVATEKEY_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_F_D2I_PKCS8PRIVATEKEY_FP(unsigned long long *o)
{
  int n = (PEM_F_D2I_PKCS8PRIVATEKEY_FP) <= 0;
  *o = (unsigned long long)((PEM_F_D2I_PKCS8PRIVATEKEY_FP) | 0);  /* check that PEM_F_D2I_PKCS8PRIVATEKEY_FP is an integer */
  return n;
}

static int _cffi_const_PEM_F_DO_PK8PKEY(unsigned long long *o)
{
  int n = (PEM_F_DO_PK8PKEY) <= 0;
  *o = (unsigned long long)((PEM_F_DO_PK8PKEY) | 0);  /* check that PEM_F_DO_PK8PKEY is an integer */
  return n;
}

static int _cffi_const_PEM_F_DO_PK8PKEY_FP(unsigned long long *o)
{
  int n = (PEM_F_DO_PK8PKEY_FP) <= 0;
  *o = (unsigned long long)((PEM_F_DO_PK8PKEY_FP) | 0);  /* check that PEM_F_DO_PK8PKEY_FP is an integer */
  return n;
}

static int _cffi_const_PEM_F_LOAD_IV(unsigned long long *o)
{
  int n = (PEM_F_LOAD_IV) <= 0;
  *o = (unsigned long long)((PEM_F_LOAD_IV) | 0);  /* check that PEM_F_LOAD_IV is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_ASN1_READ(unsigned long long *o)
{
  int n = (PEM_F_PEM_ASN1_READ) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_ASN1_READ) | 0);  /* check that PEM_F_PEM_ASN1_READ is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_ASN1_READ_BIO(unsigned long long *o)
{
  int n = (PEM_F_PEM_ASN1_READ_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_ASN1_READ_BIO) | 0);  /* check that PEM_F_PEM_ASN1_READ_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_ASN1_WRITE(unsigned long long *o)
{
  int n = (PEM_F_PEM_ASN1_WRITE) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_ASN1_WRITE) | 0);  /* check that PEM_F_PEM_ASN1_WRITE is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_ASN1_WRITE_BIO(unsigned long long *o)
{
  int n = (PEM_F_PEM_ASN1_WRITE_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_ASN1_WRITE_BIO) | 0);  /* check that PEM_F_PEM_ASN1_WRITE_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_DEF_CALLBACK(unsigned long long *o)
{
  int n = (PEM_F_PEM_DEF_CALLBACK) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_DEF_CALLBACK) | 0);  /* check that PEM_F_PEM_DEF_CALLBACK is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_DO_HEADER(unsigned long long *o)
{
  int n = (PEM_F_PEM_DO_HEADER) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_DO_HEADER) | 0);  /* check that PEM_F_PEM_DO_HEADER is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_GET_EVP_CIPHER_INFO(unsigned long long *o)
{
  int n = (PEM_F_PEM_GET_EVP_CIPHER_INFO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_GET_EVP_CIPHER_INFO) | 0);  /* check that PEM_F_PEM_GET_EVP_CIPHER_INFO is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_READ(unsigned long long *o)
{
  int n = (PEM_F_PEM_READ) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_READ) | 0);  /* check that PEM_F_PEM_READ is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_READ_BIO(unsigned long long *o)
{
  int n = (PEM_F_PEM_READ_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_READ_BIO) | 0);  /* check that PEM_F_PEM_READ_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_READ_BIO_PRIVATEKEY(unsigned long long *o)
{
  int n = (PEM_F_PEM_READ_BIO_PRIVATEKEY) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_READ_BIO_PRIVATEKEY) | 0);  /* check that PEM_F_PEM_READ_BIO_PRIVATEKEY is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_READ_PRIVATEKEY(unsigned long long *o)
{
  int n = (PEM_F_PEM_READ_PRIVATEKEY) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_READ_PRIVATEKEY) | 0);  /* check that PEM_F_PEM_READ_PRIVATEKEY is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_SIGNFINAL(unsigned long long *o)
{
  int n = (PEM_F_PEM_SIGNFINAL) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_SIGNFINAL) | 0);  /* check that PEM_F_PEM_SIGNFINAL is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_WRITE(unsigned long long *o)
{
  int n = (PEM_F_PEM_WRITE) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_WRITE) | 0);  /* check that PEM_F_PEM_WRITE is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_WRITE_BIO(unsigned long long *o)
{
  int n = (PEM_F_PEM_WRITE_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_WRITE_BIO) | 0);  /* check that PEM_F_PEM_WRITE_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_X509_INFO_READ(unsigned long long *o)
{
  int n = (PEM_F_PEM_X509_INFO_READ) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_X509_INFO_READ) | 0);  /* check that PEM_F_PEM_X509_INFO_READ is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_X509_INFO_READ_BIO(unsigned long long *o)
{
  int n = (PEM_F_PEM_X509_INFO_READ_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_X509_INFO_READ_BIO) | 0);  /* check that PEM_F_PEM_X509_INFO_READ_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_F_PEM_X509_INFO_WRITE_BIO(unsigned long long *o)
{
  int n = (PEM_F_PEM_X509_INFO_WRITE_BIO) <= 0;
  *o = (unsigned long long)((PEM_F_PEM_X509_INFO_WRITE_BIO) | 0);  /* check that PEM_F_PEM_X509_INFO_WRITE_BIO is an integer */
  return n;
}

static int _cffi_const_PEM_R_BAD_BASE64_DECODE(unsigned long long *o)
{
  int n = (PEM_R_BAD_BASE64_DECODE) <= 0;
  *o = (unsigned long long)((PEM_R_BAD_BASE64_DECODE) | 0);  /* check that PEM_R_BAD_BASE64_DECODE is an integer */
  return n;
}

static int _cffi_const_PEM_R_BAD_DECRYPT(unsigned long long *o)
{
  int n = (PEM_R_BAD_DECRYPT) <= 0;
  *o = (unsigned long long)((PEM_R_BAD_DECRYPT) | 0);  /* check that PEM_R_BAD_DECRYPT is an integer */
  return n;
}

static int _cffi_const_PEM_R_BAD_END_LINE(unsigned long long *o)
{
  int n = (PEM_R_BAD_END_LINE) <= 0;
  *o = (unsigned long long)((PEM_R_BAD_END_LINE) | 0);  /* check that PEM_R_BAD_END_LINE is an integer */
  return n;
}

static int _cffi_const_PEM_R_BAD_IV_CHARS(unsigned long long *o)
{
  int n = (PEM_R_BAD_IV_CHARS) <= 0;
  *o = (unsigned long long)((PEM_R_BAD_IV_CHARS) | 0);  /* check that PEM_R_BAD_IV_CHARS is an integer */
  return n;
}

static int _cffi_const_PEM_R_BAD_PASSWORD_READ(unsigned long long *o)
{
  int n = (PEM_R_BAD_PASSWORD_READ) <= 0;
  *o = (unsigned long long)((PEM_R_BAD_PASSWORD_READ) | 0);  /* check that PEM_R_BAD_PASSWORD_READ is an integer */
  return n;
}

static int _cffi_const_PEM_R_ERROR_CONVERTING_PRIVATE_KEY(unsigned long long *o)
{
  int n = (PEM_R_ERROR_CONVERTING_PRIVATE_KEY) <= 0;
  *o = (unsigned long long)((PEM_R_ERROR_CONVERTING_PRIVATE_KEY) | 0);  /* check that PEM_R_ERROR_CONVERTING_PRIVATE_KEY is an integer */
  return n;
}

static int _cffi_const_PEM_R_NOT_DEK_INFO(unsigned long long *o)
{
  int n = (PEM_R_NOT_DEK_INFO) <= 0;
  *o = (unsigned long long)((PEM_R_NOT_DEK_INFO) | 0);  /* check that PEM_R_NOT_DEK_INFO is an integer */
  return n;
}

static int _cffi_const_PEM_R_NOT_ENCRYPTED(unsigned long long *o)
{
  int n = (PEM_R_NOT_ENCRYPTED) <= 0;
  *o = (unsigned long long)((PEM_R_NOT_ENCRYPTED) | 0);  /* check that PEM_R_NOT_ENCRYPTED is an integer */
  return n;
}

static int _cffi_const_PEM_R_NOT_PROC_TYPE(unsigned long long *o)
{
  int n = (PEM_R_NOT_PROC_TYPE) <= 0;
  *o = (unsigned long long)((PEM_R_NOT_PROC_TYPE) | 0);  /* check that PEM_R_NOT_PROC_TYPE is an integer */
  return n;
}

static int _cffi_const_PEM_R_NO_START_LINE(unsigned long long *o)
{
  int n = (PEM_R_NO_START_LINE) <= 0;
  *o = (unsigned long long)((PEM_R_NO_START_LINE) | 0);  /* check that PEM_R_NO_START_LINE is an integer */
  return n;
}

static int _cffi_const_PEM_R_PROBLEMS_GETTING_PASSWORD(unsigned long long *o)
{
  int n = (PEM_R_PROBLEMS_GETTING_PASSWORD) <= 0;
  *o = (unsigned long long)((PEM_R_PROBLEMS_GETTING_PASSWORD) | 0);  /* check that PEM_R_PROBLEMS_GETTING_PASSWORD is an integer */
  return n;
}

static int _cffi_const_PEM_R_READ_KEY(unsigned long long *o)
{
  int n = (PEM_R_READ_KEY) <= 0;
  *o = (unsigned long long)((PEM_R_READ_KEY) | 0);  /* check that PEM_R_READ_KEY is an integer */
  return n;
}

static int _cffi_const_PEM_R_SHORT_HEADER(unsigned long long *o)
{
  int n = (PEM_R_SHORT_HEADER) <= 0;
  *o = (unsigned long long)((PEM_R_SHORT_HEADER) | 0);  /* check that PEM_R_SHORT_HEADER is an integer */
  return n;
}

static int _cffi_const_PEM_R_UNSUPPORTED_CIPHER(unsigned long long *o)
{
  int n = (PEM_R_UNSUPPORTED_CIPHER) <= 0;
  *o = (unsigned long long)((PEM_R_UNSUPPORTED_CIPHER) | 0);  /* check that PEM_R_UNSUPPORTED_CIPHER is an integer */
  return n;
}

static int _cffi_const_PEM_R_UNSUPPORTED_ENCRYPTION(unsigned long long *o)
{
  int n = (PEM_R_UNSUPPORTED_ENCRYPTION) <= 0;
  *o = (unsigned long long)((PEM_R_UNSUPPORTED_ENCRYPTION) | 0);  /* check that PEM_R_UNSUPPORTED_ENCRYPTION is an integer */
  return n;
}

static int _cffi_const_PKCS12_F_PKCS12_PBE_CRYPT(unsigned long long *o)
{
  int n = (PKCS12_F_PKCS12_PBE_CRYPT) <= 0;
  *o = (unsigned long long)((PKCS12_F_PKCS12_PBE_CRYPT) | 0);  /* check that PKCS12_F_PKCS12_PBE_CRYPT is an integer */
  return n;
}

static int _cffi_const_PKCS12_R_PKCS12_CIPHERFINAL_ERROR(unsigned long long *o)
{
  int n = (PKCS12_R_PKCS12_CIPHERFINAL_ERROR) <= 0;
  *o = (unsigned long long)((PKCS12_R_PKCS12_CIPHERFINAL_ERROR) | 0);  /* check that PKCS12_R_PKCS12_CIPHERFINAL_ERROR is an integer */
  return n;
}

static int _cffi_const_PKCS7_BINARY(unsigned long long *o)
{
  int n = (PKCS7_BINARY) <= 0;
  *o = (unsigned long long)((PKCS7_BINARY) | 0);  /* check that PKCS7_BINARY is an integer */
  return n;
}

static int _cffi_const_PKCS7_DETACHED(unsigned long long *o)
{
  int n = (PKCS7_DETACHED) <= 0;
  *o = (unsigned long long)((PKCS7_DETACHED) | 0);  /* check that PKCS7_DETACHED is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOATTR(unsigned long long *o)
{
  int n = (PKCS7_NOATTR) <= 0;
  *o = (unsigned long long)((PKCS7_NOATTR) | 0);  /* check that PKCS7_NOATTR is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOCERTS(unsigned long long *o)
{
  int n = (PKCS7_NOCERTS) <= 0;
  *o = (unsigned long long)((PKCS7_NOCERTS) | 0);  /* check that PKCS7_NOCERTS is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOCHAIN(unsigned long long *o)
{
  int n = (PKCS7_NOCHAIN) <= 0;
  *o = (unsigned long long)((PKCS7_NOCHAIN) | 0);  /* check that PKCS7_NOCHAIN is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOINTERN(unsigned long long *o)
{
  int n = (PKCS7_NOINTERN) <= 0;
  *o = (unsigned long long)((PKCS7_NOINTERN) | 0);  /* check that PKCS7_NOINTERN is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOSIGS(unsigned long long *o)
{
  int n = (PKCS7_NOSIGS) <= 0;
  *o = (unsigned long long)((PKCS7_NOSIGS) | 0);  /* check that PKCS7_NOSIGS is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOSMIMECAP(unsigned long long *o)
{
  int n = (PKCS7_NOSMIMECAP) <= 0;
  *o = (unsigned long long)((PKCS7_NOSMIMECAP) | 0);  /* check that PKCS7_NOSMIMECAP is an integer */
  return n;
}

static int _cffi_const_PKCS7_NOVERIFY(unsigned long long *o)
{
  int n = (PKCS7_NOVERIFY) <= 0;
  *o = (unsigned long long)((PKCS7_NOVERIFY) | 0);  /* check that PKCS7_NOVERIFY is an integer */
  return n;
}

static int _cffi_const_PKCS7_STREAM(unsigned long long *o)
{
  int n = (PKCS7_STREAM) <= 0;
  *o = (unsigned long long)((PKCS7_STREAM) | 0);  /* check that PKCS7_STREAM is an integer */
  return n;
}

static int _cffi_const_PKCS7_TEXT(unsigned long long *o)
{
  int n = (PKCS7_TEXT) <= 0;
  *o = (unsigned long long)((PKCS7_TEXT) | 0);  /* check that PKCS7_TEXT is an integer */
  return n;
}

static int _cffi_const_RSA_F4(unsigned long long *o)
{
  int n = (RSA_F4) <= 0;
  *o = (unsigned long long)((RSA_F4) | 0);  /* check that RSA_F4 is an integer */
  return n;
}

static int _cffi_const_RSA_F_RSA_SIGN(unsigned long long *o)
{
  int n = (RSA_F_RSA_SIGN) <= 0;
  *o = (unsigned long long)((RSA_F_RSA_SIGN) | 0);  /* check that RSA_F_RSA_SIGN is an integer */
  return n;
}

static int _cffi_const_RSA_NO_PADDING(unsigned long long *o)
{
  int n = (RSA_NO_PADDING) <= 0;
  *o = (unsigned long long)((RSA_NO_PADDING) | 0);  /* check that RSA_NO_PADDING is an integer */
  return n;
}

static int _cffi_const_RSA_PKCS1_OAEP_PADDING(unsigned long long *o)
{
  int n = (RSA_PKCS1_OAEP_PADDING) <= 0;
  *o = (unsigned long long)((RSA_PKCS1_OAEP_PADDING) | 0);  /* check that RSA_PKCS1_OAEP_PADDING is an integer */
  return n;
}

static int _cffi_const_RSA_PKCS1_PADDING(unsigned long long *o)
{
  int n = (RSA_PKCS1_PADDING) <= 0;
  *o = (unsigned long long)((RSA_PKCS1_PADDING) | 0);  /* check that RSA_PKCS1_PADDING is an integer */
  return n;
}

static int _cffi_const_RSA_PKCS1_PSS_PADDING(unsigned long long *o)
{
  int n = (RSA_PKCS1_PSS_PADDING) <= 0;
  *o = (unsigned long long)((RSA_PKCS1_PSS_PADDING) | 0);  /* check that RSA_PKCS1_PSS_PADDING is an integer */
  return n;
}

static int _cffi_const_RSA_R_BLOCK_TYPE_IS_NOT_01(unsigned long long *o)
{
  int n = (RSA_R_BLOCK_TYPE_IS_NOT_01) <= 0;
  *o = (unsigned long long)((RSA_R_BLOCK_TYPE_IS_NOT_01) | 0);  /* check that RSA_R_BLOCK_TYPE_IS_NOT_01 is an integer */
  return n;
}

static int _cffi_const_RSA_R_BLOCK_TYPE_IS_NOT_02(unsigned long long *o)
{
  int n = (RSA_R_BLOCK_TYPE_IS_NOT_02) <= 0;
  *o = (unsigned long long)((RSA_R_BLOCK_TYPE_IS_NOT_02) | 0);  /* check that RSA_R_BLOCK_TYPE_IS_NOT_02 is an integer */
  return n;
}

static int _cffi_const_RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE(unsigned long long *o)
{
  int n = (RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE) <= 0;
  *o = (unsigned long long)((RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE) | 0);  /* check that RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE is an integer */
  return n;
}

static int _cffi_const_RSA_R_DATA_TOO_LARGE_FOR_MODULUS(unsigned long long *o)
{
  int n = (RSA_R_DATA_TOO_LARGE_FOR_MODULUS) <= 0;
  *o = (unsigned long long)((RSA_R_DATA_TOO_LARGE_FOR_MODULUS) | 0);  /* check that RSA_R_DATA_TOO_LARGE_FOR_MODULUS is an integer */
  return n;
}

static int _cffi_const_RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY(unsigned long long *o)
{
  int n = (RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY) <= 0;
  *o = (unsigned long long)((RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY) | 0);  /* check that RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY is an integer */
  return n;
}

static int _cffi_const_RSA_R_OAEP_DECODING_ERROR(unsigned long long *o)
{
  int n = (RSA_R_OAEP_DECODING_ERROR) <= 0;
  *o = (unsigned long long)((RSA_R_OAEP_DECODING_ERROR) | 0);  /* check that RSA_R_OAEP_DECODING_ERROR is an integer */
  return n;
}

static int _cffi_const_RSA_R_PKCS_DECODING_ERROR(unsigned long long *o)
{
  int n = (RSA_R_PKCS_DECODING_ERROR) <= 0;
  *o = (unsigned long long)((RSA_R_PKCS_DECODING_ERROR) | 0);  /* check that RSA_R_PKCS_DECODING_ERROR is an integer */
  return n;
}

static int _cffi_const_RSA_SSLV23_PADDING(unsigned long long *o)
{
  int n = (RSA_SSLV23_PADDING) <= 0;
  *o = (unsigned long long)((RSA_SSLV23_PADDING) | 0);  /* check that RSA_SSLV23_PADDING is an integer */
  return n;
}

static int _cffi_const_RSA_X931_PADDING(unsigned long long *o)
{
  int n = (RSA_X931_PADDING) <= 0;
  *o = (unsigned long long)((RSA_X931_PADDING) | 0);  /* check that RSA_X931_PADDING is an integer */
  return n;
}

static void _cffi_const_SN_X9_62_c2onb191v4(char *o)
{
  *(char const * *)o = SN_X9_62_c2onb191v4;
}

static void _cffi_const_SN_X9_62_c2onb191v5(char *o)
{
  *(char const * *)o = SN_X9_62_c2onb191v5;
}

static void _cffi_const_SN_X9_62_c2onb239v4(char *o)
{
  *(char const * *)o = SN_X9_62_c2onb239v4;
}

static void _cffi_const_SN_X9_62_c2onb239v5(char *o)
{
  *(char const * *)o = SN_X9_62_c2onb239v5;
}

static void _cffi_const_SN_X9_62_c2pnb163v1(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb163v1;
}

static void _cffi_const_SN_X9_62_c2pnb163v2(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb163v2;
}

static void _cffi_const_SN_X9_62_c2pnb163v3(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb163v3;
}

static void _cffi_const_SN_X9_62_c2pnb176v1(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb176v1;
}

static void _cffi_const_SN_X9_62_c2pnb208w1(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb208w1;
}

static void _cffi_const_SN_X9_62_c2pnb272w1(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb272w1;
}

static void _cffi_const_SN_X9_62_c2pnb304w1(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb304w1;
}

static void _cffi_const_SN_X9_62_c2pnb368w1(char *o)
{
  *(char const * *)o = SN_X9_62_c2pnb368w1;
}

static void _cffi_const_SN_X9_62_c2tnb191v1(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb191v1;
}

static void _cffi_const_SN_X9_62_c2tnb191v2(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb191v2;
}

static void _cffi_const_SN_X9_62_c2tnb191v3(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb191v3;
}

static void _cffi_const_SN_X9_62_c2tnb239v1(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb239v1;
}

static void _cffi_const_SN_X9_62_c2tnb239v2(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb239v2;
}

static void _cffi_const_SN_X9_62_c2tnb239v3(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb239v3;
}

static void _cffi_const_SN_X9_62_c2tnb359v1(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb359v1;
}

static void _cffi_const_SN_X9_62_c2tnb431r1(char *o)
{
  *(char const * *)o = SN_X9_62_c2tnb431r1;
}

static void _cffi_const_SN_X9_62_prime192v1(char *o)
{
  *(char const * *)o = SN_X9_62_prime192v1;
}

static void _cffi_const_SN_X9_62_prime192v2(char *o)
{
  *(char const * *)o = SN_X9_62_prime192v2;
}

static void _cffi_const_SN_X9_62_prime192v3(char *o)
{
  *(char const * *)o = SN_X9_62_prime192v3;
}

static void _cffi_const_SN_X9_62_prime239v1(char *o)
{
  *(char const * *)o = SN_X9_62_prime239v1;
}

static void _cffi_const_SN_X9_62_prime239v2(char *o)
{
  *(char const * *)o = SN_X9_62_prime239v2;
}

static void _cffi_const_SN_X9_62_prime239v3(char *o)
{
  *(char const * *)o = SN_X9_62_prime239v3;
}

static void _cffi_const_SN_X9_62_prime256v1(char *o)
{
  *(char const * *)o = SN_X9_62_prime256v1;
}

static void _cffi_const_SN_ipsec3(char *o)
{
  *(char const * *)o = SN_ipsec3;
}

static void _cffi_const_SN_ipsec4(char *o)
{
  *(char const * *)o = SN_ipsec4;
}

static void _cffi_const_SN_secp112r1(char *o)
{
  *(char const * *)o = SN_secp112r1;
}

static void _cffi_const_SN_secp112r2(char *o)
{
  *(char const * *)o = SN_secp112r2;
}

static void _cffi_const_SN_secp128r1(char *o)
{
  *(char const * *)o = SN_secp128r1;
}

static void _cffi_const_SN_secp128r2(char *o)
{
  *(char const * *)o = SN_secp128r2;
}

static void _cffi_const_SN_secp160k1(char *o)
{
  *(char const * *)o = SN_secp160k1;
}

static void _cffi_const_SN_secp160r1(char *o)
{
  *(char const * *)o = SN_secp160r1;
}

static void _cffi_const_SN_secp160r2(char *o)
{
  *(char const * *)o = SN_secp160r2;
}

static void _cffi_const_SN_secp192k1(char *o)
{
  *(char const * *)o = SN_secp192k1;
}

static void _cffi_const_SN_secp224k1(char *o)
{
  *(char const * *)o = SN_secp224k1;
}

static void _cffi_const_SN_secp224r1(char *o)
{
  *(char const * *)o = SN_secp224r1;
}

static void _cffi_const_SN_secp256k1(char *o)
{
  *(char const * *)o = SN_secp256k1;
}

static void _cffi_const_SN_secp384r1(char *o)
{
  *(char const * *)o = SN_secp384r1;
}

static void _cffi_const_SN_secp521r1(char *o)
{
  *(char const * *)o = SN_secp521r1;
}

static void _cffi_const_SN_sect113r1(char *o)
{
  *(char const * *)o = SN_sect113r1;
}

static void _cffi_const_SN_sect113r2(char *o)
{
  *(char const * *)o = SN_sect113r2;
}

static void _cffi_const_SN_sect131r1(char *o)
{
  *(char const * *)o = SN_sect131r1;
}

static void _cffi_const_SN_sect131r2(char *o)
{
  *(char const * *)o = SN_sect131r2;
}

static void _cffi_const_SN_sect163k1(char *o)
{
  *(char const * *)o = SN_sect163k1;
}

static void _cffi_const_SN_sect163r1(char *o)
{
  *(char const * *)o = SN_sect163r1;
}

static void _cffi_const_SN_sect163r2(char *o)
{
  *(char const * *)o = SN_sect163r2;
}

static void _cffi_const_SN_sect193r1(char *o)
{
  *(char const * *)o = SN_sect193r1;
}

static void _cffi_const_SN_sect193r2(char *o)
{
  *(char const * *)o = SN_sect193r2;
}

static void _cffi_const_SN_sect233k1(char *o)
{
  *(char const * *)o = SN_sect233k1;
}

static void _cffi_const_SN_sect233r1(char *o)
{
  *(char const * *)o = SN_sect233r1;
}

static void _cffi_const_SN_sect239k1(char *o)
{
  *(char const * *)o = SN_sect239k1;
}

static void _cffi_const_SN_sect283k1(char *o)
{
  *(char const * *)o = SN_sect283k1;
}

static void _cffi_const_SN_sect283r1(char *o)
{
  *(char const * *)o = SN_sect283r1;
}

static void _cffi_const_SN_sect409k1(char *o)
{
  *(char const * *)o = SN_sect409k1;
}

static void _cffi_const_SN_sect409r1(char *o)
{
  *(char const * *)o = SN_sect409r1;
}

static void _cffi_const_SN_sect571k1(char *o)
{
  *(char const * *)o = SN_sect571k1;
}

static void _cffi_const_SN_sect571r1(char *o)
{
  *(char const * *)o = SN_sect571r1;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls1(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls1;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls10(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls10;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls11(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls11;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls12(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls12;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls3(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls3;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls4(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls4;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls5(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls5;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls6(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls6;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls7(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls7;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls8(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls8;
}

static void _cffi_const_SN_wap_wsg_idm_ecid_wtls9(char *o)
{
  *(char const * *)o = SN_wap_wsg_idm_ecid_wtls9;
}

static int _cffi_const_SSL3_RANDOM_SIZE(unsigned long long *o)
{
  int n = (SSL3_RANDOM_SIZE) <= 0;
  *o = (unsigned long long)((SSL3_RANDOM_SIZE) | 0);  /* check that SSL3_RANDOM_SIZE is an integer */
  return n;
}

static int _cffi_const_SSLEAY_BUILT_ON(unsigned long long *o)
{
  int n = (SSLEAY_BUILT_ON) <= 0;
  *o = (unsigned long long)((SSLEAY_BUILT_ON) | 0);  /* check that SSLEAY_BUILT_ON is an integer */
  return n;
}

static int _cffi_const_SSLEAY_CFLAGS(unsigned long long *o)
{
  int n = (SSLEAY_CFLAGS) <= 0;
  *o = (unsigned long long)((SSLEAY_CFLAGS) | 0);  /* check that SSLEAY_CFLAGS is an integer */
  return n;
}

static int _cffi_const_SSLEAY_DIR(unsigned long long *o)
{
  int n = (SSLEAY_DIR) <= 0;
  *o = (unsigned long long)((SSLEAY_DIR) | 0);  /* check that SSLEAY_DIR is an integer */
  return n;
}

static int _cffi_const_SSLEAY_PLATFORM(unsigned long long *o)
{
  int n = (SSLEAY_PLATFORM) <= 0;
  *o = (unsigned long long)((SSLEAY_PLATFORM) | 0);  /* check that SSLEAY_PLATFORM is an integer */
  return n;
}

static int _cffi_const_SSLEAY_VERSION(unsigned long long *o)
{
  int n = (SSLEAY_VERSION) <= 0;
  *o = (unsigned long long)((SSLEAY_VERSION) | 0);  /* check that SSLEAY_VERSION is an integer */
  return n;
}

static int _cffi_const_SSL_AD_ACCESS_DENIED(unsigned long long *o)
{
  int n = (SSL_AD_ACCESS_DENIED) <= 0;
  *o = (unsigned long long)((SSL_AD_ACCESS_DENIED) | 0);  /* check that SSL_AD_ACCESS_DENIED is an integer */
  return n;
}

static int _cffi_const_SSL_AD_BAD_CERTIFICATE(unsigned long long *o)
{
  int n = (SSL_AD_BAD_CERTIFICATE) <= 0;
  *o = (unsigned long long)((SSL_AD_BAD_CERTIFICATE) | 0);  /* check that SSL_AD_BAD_CERTIFICATE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_BAD_CERTIFICATE_HASH_VALUE(unsigned long long *o)
{
  int n = (SSL_AD_BAD_CERTIFICATE_HASH_VALUE) <= 0;
  *o = (unsigned long long)((SSL_AD_BAD_CERTIFICATE_HASH_VALUE) | 0);  /* check that SSL_AD_BAD_CERTIFICATE_HASH_VALUE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE(unsigned long long *o)
{
  int n = (SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE) <= 0;
  *o = (unsigned long long)((SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE) | 0);  /* check that SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_BAD_RECORD_MAC(unsigned long long *o)
{
  int n = (SSL_AD_BAD_RECORD_MAC) <= 0;
  *o = (unsigned long long)((SSL_AD_BAD_RECORD_MAC) | 0);  /* check that SSL_AD_BAD_RECORD_MAC is an integer */
  return n;
}

static int _cffi_const_SSL_AD_CERTIFICATE_EXPIRED(unsigned long long *o)
{
  int n = (SSL_AD_CERTIFICATE_EXPIRED) <= 0;
  *o = (unsigned long long)((SSL_AD_CERTIFICATE_EXPIRED) | 0);  /* check that SSL_AD_CERTIFICATE_EXPIRED is an integer */
  return n;
}

static int _cffi_const_SSL_AD_CERTIFICATE_REVOKED(unsigned long long *o)
{
  int n = (SSL_AD_CERTIFICATE_REVOKED) <= 0;
  *o = (unsigned long long)((SSL_AD_CERTIFICATE_REVOKED) | 0);  /* check that SSL_AD_CERTIFICATE_REVOKED is an integer */
  return n;
}

static int _cffi_const_SSL_AD_CERTIFICATE_UNKNOWN(unsigned long long *o)
{
  int n = (SSL_AD_CERTIFICATE_UNKNOWN) <= 0;
  *o = (unsigned long long)((SSL_AD_CERTIFICATE_UNKNOWN) | 0);  /* check that SSL_AD_CERTIFICATE_UNKNOWN is an integer */
  return n;
}

static int _cffi_const_SSL_AD_CERTIFICATE_UNOBTAINABLE(unsigned long long *o)
{
  int n = (SSL_AD_CERTIFICATE_UNOBTAINABLE) <= 0;
  *o = (unsigned long long)((SSL_AD_CERTIFICATE_UNOBTAINABLE) | 0);  /* check that SSL_AD_CERTIFICATE_UNOBTAINABLE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_CLOSE_NOTIFY(unsigned long long *o)
{
  int n = (SSL_AD_CLOSE_NOTIFY) <= 0;
  *o = (unsigned long long)((SSL_AD_CLOSE_NOTIFY) | 0);  /* check that SSL_AD_CLOSE_NOTIFY is an integer */
  return n;
}

static int _cffi_const_SSL_AD_DECODE_ERROR(unsigned long long *o)
{
  int n = (SSL_AD_DECODE_ERROR) <= 0;
  *o = (unsigned long long)((SSL_AD_DECODE_ERROR) | 0);  /* check that SSL_AD_DECODE_ERROR is an integer */
  return n;
}

static int _cffi_const_SSL_AD_DECOMPRESSION_FAILURE(unsigned long long *o)
{
  int n = (SSL_AD_DECOMPRESSION_FAILURE) <= 0;
  *o = (unsigned long long)((SSL_AD_DECOMPRESSION_FAILURE) | 0);  /* check that SSL_AD_DECOMPRESSION_FAILURE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_DECRYPT_ERROR(unsigned long long *o)
{
  int n = (SSL_AD_DECRYPT_ERROR) <= 0;
  *o = (unsigned long long)((SSL_AD_DECRYPT_ERROR) | 0);  /* check that SSL_AD_DECRYPT_ERROR is an integer */
  return n;
}

static int _cffi_const_SSL_AD_HANDSHAKE_FAILURE(unsigned long long *o)
{
  int n = (SSL_AD_HANDSHAKE_FAILURE) <= 0;
  *o = (unsigned long long)((SSL_AD_HANDSHAKE_FAILURE) | 0);  /* check that SSL_AD_HANDSHAKE_FAILURE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_ILLEGAL_PARAMETER(unsigned long long *o)
{
  int n = (SSL_AD_ILLEGAL_PARAMETER) <= 0;
  *o = (unsigned long long)((SSL_AD_ILLEGAL_PARAMETER) | 0);  /* check that SSL_AD_ILLEGAL_PARAMETER is an integer */
  return n;
}

static int _cffi_const_SSL_AD_INSUFFICIENT_SECURITY(unsigned long long *o)
{
  int n = (SSL_AD_INSUFFICIENT_SECURITY) <= 0;
  *o = (unsigned long long)((SSL_AD_INSUFFICIENT_SECURITY) | 0);  /* check that SSL_AD_INSUFFICIENT_SECURITY is an integer */
  return n;
}

static int _cffi_const_SSL_AD_INTERNAL_ERROR(unsigned long long *o)
{
  int n = (SSL_AD_INTERNAL_ERROR) <= 0;
  *o = (unsigned long long)((SSL_AD_INTERNAL_ERROR) | 0);  /* check that SSL_AD_INTERNAL_ERROR is an integer */
  return n;
}

static int _cffi_const_SSL_AD_NO_RENEGOTIATION(unsigned long long *o)
{
  int n = (SSL_AD_NO_RENEGOTIATION) <= 0;
  *o = (unsigned long long)((SSL_AD_NO_RENEGOTIATION) | 0);  /* check that SSL_AD_NO_RENEGOTIATION is an integer */
  return n;
}

static int _cffi_const_SSL_AD_PROTOCOL_VERSION(unsigned long long *o)
{
  int n = (SSL_AD_PROTOCOL_VERSION) <= 0;
  *o = (unsigned long long)((SSL_AD_PROTOCOL_VERSION) | 0);  /* check that SSL_AD_PROTOCOL_VERSION is an integer */
  return n;
}

static int _cffi_const_SSL_AD_RECORD_OVERFLOW(unsigned long long *o)
{
  int n = (SSL_AD_RECORD_OVERFLOW) <= 0;
  *o = (unsigned long long)((SSL_AD_RECORD_OVERFLOW) | 0);  /* check that SSL_AD_RECORD_OVERFLOW is an integer */
  return n;
}

static int _cffi_const_SSL_AD_UNEXPECTED_MESSAGE(unsigned long long *o)
{
  int n = (SSL_AD_UNEXPECTED_MESSAGE) <= 0;
  *o = (unsigned long long)((SSL_AD_UNEXPECTED_MESSAGE) | 0);  /* check that SSL_AD_UNEXPECTED_MESSAGE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_UNKNOWN_CA(unsigned long long *o)
{
  int n = (SSL_AD_UNKNOWN_CA) <= 0;
  *o = (unsigned long long)((SSL_AD_UNKNOWN_CA) | 0);  /* check that SSL_AD_UNKNOWN_CA is an integer */
  return n;
}

static int _cffi_const_SSL_AD_UNKNOWN_PSK_IDENTITY(unsigned long long *o)
{
  int n = (SSL_AD_UNKNOWN_PSK_IDENTITY) <= 0;
  *o = (unsigned long long)((SSL_AD_UNKNOWN_PSK_IDENTITY) | 0);  /* check that SSL_AD_UNKNOWN_PSK_IDENTITY is an integer */
  return n;
}

static int _cffi_const_SSL_AD_UNRECOGNIZED_NAME(unsigned long long *o)
{
  int n = (SSL_AD_UNRECOGNIZED_NAME) <= 0;
  *o = (unsigned long long)((SSL_AD_UNRECOGNIZED_NAME) | 0);  /* check that SSL_AD_UNRECOGNIZED_NAME is an integer */
  return n;
}

static int _cffi_const_SSL_AD_UNSUPPORTED_CERTIFICATE(unsigned long long *o)
{
  int n = (SSL_AD_UNSUPPORTED_CERTIFICATE) <= 0;
  *o = (unsigned long long)((SSL_AD_UNSUPPORTED_CERTIFICATE) | 0);  /* check that SSL_AD_UNSUPPORTED_CERTIFICATE is an integer */
  return n;
}

static int _cffi_const_SSL_AD_UNSUPPORTED_EXTENSION(unsigned long long *o)
{
  int n = (SSL_AD_UNSUPPORTED_EXTENSION) <= 0;
  *o = (unsigned long long)((SSL_AD_UNSUPPORTED_EXTENSION) | 0);  /* check that SSL_AD_UNSUPPORTED_EXTENSION is an integer */
  return n;
}

static int _cffi_const_SSL_AD_USER_CANCELLED(unsigned long long *o)
{
  int n = (SSL_AD_USER_CANCELLED) <= 0;
  *o = (unsigned long long)((SSL_AD_USER_CANCELLED) | 0);  /* check that SSL_AD_USER_CANCELLED is an integer */
  return n;
}

static int _cffi_const_SSL_CB_ACCEPT_EXIT(unsigned long long *o)
{
  int n = (SSL_CB_ACCEPT_EXIT) <= 0;
  *o = (unsigned long long)((SSL_CB_ACCEPT_EXIT) | 0);  /* check that SSL_CB_ACCEPT_EXIT is an integer */
  return n;
}

static int _cffi_const_SSL_CB_ACCEPT_LOOP(unsigned long long *o)
{
  int n = (SSL_CB_ACCEPT_LOOP) <= 0;
  *o = (unsigned long long)((SSL_CB_ACCEPT_LOOP) | 0);  /* check that SSL_CB_ACCEPT_LOOP is an integer */
  return n;
}

static int _cffi_const_SSL_CB_ALERT(unsigned long long *o)
{
  int n = (SSL_CB_ALERT) <= 0;
  *o = (unsigned long long)((SSL_CB_ALERT) | 0);  /* check that SSL_CB_ALERT is an integer */
  return n;
}

static int _cffi_const_SSL_CB_CONNECT_EXIT(unsigned long long *o)
{
  int n = (SSL_CB_CONNECT_EXIT) <= 0;
  *o = (unsigned long long)((SSL_CB_CONNECT_EXIT) | 0);  /* check that SSL_CB_CONNECT_EXIT is an integer */
  return n;
}

static int _cffi_const_SSL_CB_CONNECT_LOOP(unsigned long long *o)
{
  int n = (SSL_CB_CONNECT_LOOP) <= 0;
  *o = (unsigned long long)((SSL_CB_CONNECT_LOOP) | 0);  /* check that SSL_CB_CONNECT_LOOP is an integer */
  return n;
}

static int _cffi_const_SSL_CB_EXIT(unsigned long long *o)
{
  int n = (SSL_CB_EXIT) <= 0;
  *o = (unsigned long long)((SSL_CB_EXIT) | 0);  /* check that SSL_CB_EXIT is an integer */
  return n;
}

static int _cffi_const_SSL_CB_HANDSHAKE_DONE(unsigned long long *o)
{
  int n = (SSL_CB_HANDSHAKE_DONE) <= 0;
  *o = (unsigned long long)((SSL_CB_HANDSHAKE_DONE) | 0);  /* check that SSL_CB_HANDSHAKE_DONE is an integer */
  return n;
}

static int _cffi_const_SSL_CB_HANDSHAKE_START(unsigned long long *o)
{
  int n = (SSL_CB_HANDSHAKE_START) <= 0;
  *o = (unsigned long long)((SSL_CB_HANDSHAKE_START) | 0);  /* check that SSL_CB_HANDSHAKE_START is an integer */
  return n;
}

static int _cffi_const_SSL_CB_LOOP(unsigned long long *o)
{
  int n = (SSL_CB_LOOP) <= 0;
  *o = (unsigned long long)((SSL_CB_LOOP) | 0);  /* check that SSL_CB_LOOP is an integer */
  return n;
}

static int _cffi_const_SSL_CB_READ(unsigned long long *o)
{
  int n = (SSL_CB_READ) <= 0;
  *o = (unsigned long long)((SSL_CB_READ) | 0);  /* check that SSL_CB_READ is an integer */
  return n;
}

static int _cffi_const_SSL_CB_READ_ALERT(unsigned long long *o)
{
  int n = (SSL_CB_READ_ALERT) <= 0;
  *o = (unsigned long long)((SSL_CB_READ_ALERT) | 0);  /* check that SSL_CB_READ_ALERT is an integer */
  return n;
}

static int _cffi_const_SSL_CB_WRITE(unsigned long long *o)
{
  int n = (SSL_CB_WRITE) <= 0;
  *o = (unsigned long long)((SSL_CB_WRITE) | 0);  /* check that SSL_CB_WRITE is an integer */
  return n;
}

static int _cffi_const_SSL_CB_WRITE_ALERT(unsigned long long *o)
{
  int n = (SSL_CB_WRITE_ALERT) <= 0;
  *o = (unsigned long long)((SSL_CB_WRITE_ALERT) | 0);  /* check that SSL_CB_WRITE_ALERT is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_NONE(unsigned long long *o)
{
  int n = (SSL_ERROR_NONE) <= 0;
  *o = (unsigned long long)((SSL_ERROR_NONE) | 0);  /* check that SSL_ERROR_NONE is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_SSL(unsigned long long *o)
{
  int n = (SSL_ERROR_SSL) <= 0;
  *o = (unsigned long long)((SSL_ERROR_SSL) | 0);  /* check that SSL_ERROR_SSL is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_SYSCALL(unsigned long long *o)
{
  int n = (SSL_ERROR_SYSCALL) <= 0;
  *o = (unsigned long long)((SSL_ERROR_SYSCALL) | 0);  /* check that SSL_ERROR_SYSCALL is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_WANT_CONNECT(unsigned long long *o)
{
  int n = (SSL_ERROR_WANT_CONNECT) <= 0;
  *o = (unsigned long long)((SSL_ERROR_WANT_CONNECT) | 0);  /* check that SSL_ERROR_WANT_CONNECT is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_WANT_READ(unsigned long long *o)
{
  int n = (SSL_ERROR_WANT_READ) <= 0;
  *o = (unsigned long long)((SSL_ERROR_WANT_READ) | 0);  /* check that SSL_ERROR_WANT_READ is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_WANT_WRITE(unsigned long long *o)
{
  int n = (SSL_ERROR_WANT_WRITE) <= 0;
  *o = (unsigned long long)((SSL_ERROR_WANT_WRITE) | 0);  /* check that SSL_ERROR_WANT_WRITE is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_WANT_X509_LOOKUP(unsigned long long *o)
{
  int n = (SSL_ERROR_WANT_X509_LOOKUP) <= 0;
  *o = (unsigned long long)((SSL_ERROR_WANT_X509_LOOKUP) | 0);  /* check that SSL_ERROR_WANT_X509_LOOKUP is an integer */
  return n;
}

static int _cffi_const_SSL_ERROR_ZERO_RETURN(unsigned long long *o)
{
  int n = (SSL_ERROR_ZERO_RETURN) <= 0;
  *o = (unsigned long long)((SSL_ERROR_ZERO_RETURN) | 0);  /* check that SSL_ERROR_ZERO_RETURN is an integer */
  return n;
}

static int _cffi_const_SSL_FILETYPE_ASN1(unsigned long long *o)
{
  int n = (SSL_FILETYPE_ASN1) <= 0;
  *o = (unsigned long long)((SSL_FILETYPE_ASN1) | 0);  /* check that SSL_FILETYPE_ASN1 is an integer */
  return n;
}

static int _cffi_const_SSL_FILETYPE_PEM(unsigned long long *o)
{
  int n = (SSL_FILETYPE_PEM) <= 0;
  *o = (unsigned long long)((SSL_FILETYPE_PEM) | 0);  /* check that SSL_FILETYPE_PEM is an integer */
  return n;
}

static int _cffi_const_SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER(unsigned long long *o)
{
  int n = (SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER) <= 0;
  *o = (unsigned long long)((SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER) | 0);  /* check that SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER is an integer */
  return n;
}

static int _cffi_const_SSL_MODE_AUTO_RETRY(unsigned long long *o)
{
  int n = (SSL_MODE_AUTO_RETRY) <= 0;
  *o = (unsigned long long)((SSL_MODE_AUTO_RETRY) | 0);  /* check that SSL_MODE_AUTO_RETRY is an integer */
  return n;
}

static int _cffi_const_SSL_MODE_ENABLE_PARTIAL_WRITE(unsigned long long *o)
{
  int n = (SSL_MODE_ENABLE_PARTIAL_WRITE) <= 0;
  *o = (unsigned long long)((SSL_MODE_ENABLE_PARTIAL_WRITE) | 0);  /* check that SSL_MODE_ENABLE_PARTIAL_WRITE is an integer */
  return n;
}

static int _cffi_const_SSL_MODE_RELEASE_BUFFERS(unsigned long long *o)
{
  int n = (SSL_MODE_RELEASE_BUFFERS) <= 0;
  *o = (unsigned long long)((SSL_MODE_RELEASE_BUFFERS) | 0);  /* check that SSL_MODE_RELEASE_BUFFERS is an integer */
  return n;
}

static int _cffi_const_SSL_OP_ALL(unsigned long long *o)
{
  int n = (SSL_OP_ALL) <= 0;
  *o = (unsigned long long)((SSL_OP_ALL) | 0);  /* check that SSL_OP_ALL is an integer */
  return n;
}

static int _cffi_const_SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION(unsigned long long *o)
{
  int n = (SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) <= 0;
  *o = (unsigned long long)((SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) | 0);  /* check that SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION is an integer */
  return n;
}

static int _cffi_const_SSL_OP_CIPHER_SERVER_PREFERENCE(unsigned long long *o)
{
  int n = (SSL_OP_CIPHER_SERVER_PREFERENCE) <= 0;
  *o = (unsigned long long)((SSL_OP_CIPHER_SERVER_PREFERENCE) | 0);  /* check that SSL_OP_CIPHER_SERVER_PREFERENCE is an integer */
  return n;
}

static int _cffi_const_SSL_OP_COOKIE_EXCHANGE(unsigned long long *o)
{
  int n = (SSL_OP_COOKIE_EXCHANGE) <= 0;
  *o = (unsigned long long)((SSL_OP_COOKIE_EXCHANGE) | 0);  /* check that SSL_OP_COOKIE_EXCHANGE is an integer */
  return n;
}

static int _cffi_const_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS(unsigned long long *o)
{
  int n = (SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) <= 0;
  *o = (unsigned long long)((SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) | 0);  /* check that SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS is an integer */
  return n;
}

static int _cffi_const_SSL_OP_EPHEMERAL_RSA(unsigned long long *o)
{
  int n = (SSL_OP_EPHEMERAL_RSA) <= 0;
  *o = (unsigned long long)((SSL_OP_EPHEMERAL_RSA) | 0);  /* check that SSL_OP_EPHEMERAL_RSA is an integer */
  return n;
}

static int _cffi_const_SSL_OP_LEGACY_SERVER_CONNECT(unsigned long long *o)
{
  int n = (SSL_OP_LEGACY_SERVER_CONNECT) <= 0;
  *o = (unsigned long long)((SSL_OP_LEGACY_SERVER_CONNECT) | 0);  /* check that SSL_OP_LEGACY_SERVER_CONNECT is an integer */
  return n;
}

static int _cffi_const_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER(unsigned long long *o)
{
  int n = (SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) <= 0;
  *o = (unsigned long long)((SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) | 0);  /* check that SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER is an integer */
  return n;
}

static int _cffi_const_SSL_OP_MICROSOFT_SESS_ID_BUG(unsigned long long *o)
{
  int n = (SSL_OP_MICROSOFT_SESS_ID_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_MICROSOFT_SESS_ID_BUG) | 0);  /* check that SSL_OP_MICROSOFT_SESS_ID_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_MSIE_SSLV2_RSA_PADDING(unsigned long long *o)
{
  int n = (SSL_OP_MSIE_SSLV2_RSA_PADDING) <= 0;
  *o = (unsigned long long)((SSL_OP_MSIE_SSLV2_RSA_PADDING) | 0);  /* check that SSL_OP_MSIE_SSLV2_RSA_PADDING is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NETSCAPE_CA_DN_BUG(unsigned long long *o)
{
  int n = (SSL_OP_NETSCAPE_CA_DN_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_NETSCAPE_CA_DN_BUG) | 0);  /* check that SSL_OP_NETSCAPE_CA_DN_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NETSCAPE_CHALLENGE_BUG(unsigned long long *o)
{
  int n = (SSL_OP_NETSCAPE_CHALLENGE_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_NETSCAPE_CHALLENGE_BUG) | 0);  /* check that SSL_OP_NETSCAPE_CHALLENGE_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG(unsigned long long *o)
{
  int n = (SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) | 0);  /* check that SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG(unsigned long long *o)
{
  int n = (SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) | 0);  /* check that SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_COMPRESSION(unsigned long long *o)
{
  int n = (SSL_OP_NO_COMPRESSION) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_COMPRESSION) | 0);  /* check that SSL_OP_NO_COMPRESSION is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_QUERY_MTU(unsigned long long *o)
{
  int n = (SSL_OP_NO_QUERY_MTU) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_QUERY_MTU) | 0);  /* check that SSL_OP_NO_QUERY_MTU is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_SSLv2(unsigned long long *o)
{
  int n = (SSL_OP_NO_SSLv2) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_SSLv2) | 0);  /* check that SSL_OP_NO_SSLv2 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_SSLv3(unsigned long long *o)
{
  int n = (SSL_OP_NO_SSLv3) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_SSLv3) | 0);  /* check that SSL_OP_NO_SSLv3 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_TICKET(unsigned long long *o)
{
  int n = (SSL_OP_NO_TICKET) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_TICKET) | 0);  /* check that SSL_OP_NO_TICKET is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_TLSv1(unsigned long long *o)
{
  int n = (SSL_OP_NO_TLSv1) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_TLSv1) | 0);  /* check that SSL_OP_NO_TLSv1 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_TLSv1_1(unsigned long long *o)
{
  int n = (SSL_OP_NO_TLSv1_1) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_TLSv1_1) | 0);  /* check that SSL_OP_NO_TLSv1_1 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_NO_TLSv1_2(unsigned long long *o)
{
  int n = (SSL_OP_NO_TLSv1_2) <= 0;
  *o = (unsigned long long)((SSL_OP_NO_TLSv1_2) | 0);  /* check that SSL_OP_NO_TLSv1_2 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_PKCS1_CHECK_1(unsigned long long *o)
{
  int n = (SSL_OP_PKCS1_CHECK_1) <= 0;
  *o = (unsigned long long)((SSL_OP_PKCS1_CHECK_1) | 0);  /* check that SSL_OP_PKCS1_CHECK_1 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_PKCS1_CHECK_2(unsigned long long *o)
{
  int n = (SSL_OP_PKCS1_CHECK_2) <= 0;
  *o = (unsigned long long)((SSL_OP_PKCS1_CHECK_2) | 0);  /* check that SSL_OP_PKCS1_CHECK_2 is an integer */
  return n;
}

static int _cffi_const_SSL_OP_SINGLE_DH_USE(unsigned long long *o)
{
  int n = (SSL_OP_SINGLE_DH_USE) <= 0;
  *o = (unsigned long long)((SSL_OP_SINGLE_DH_USE) | 0);  /* check that SSL_OP_SINGLE_DH_USE is an integer */
  return n;
}

static int _cffi_const_SSL_OP_SINGLE_ECDH_USE(unsigned long long *o)
{
  int n = (SSL_OP_SINGLE_ECDH_USE) <= 0;
  *o = (unsigned long long)((SSL_OP_SINGLE_ECDH_USE) | 0);  /* check that SSL_OP_SINGLE_ECDH_USE is an integer */
  return n;
}

static int _cffi_const_SSL_OP_SSLEAY_080_CLIENT_DH_BUG(unsigned long long *o)
{
  int n = (SSL_OP_SSLEAY_080_CLIENT_DH_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_SSLEAY_080_CLIENT_DH_BUG) | 0);  /* check that SSL_OP_SSLEAY_080_CLIENT_DH_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG(unsigned long long *o)
{
  int n = (SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG) | 0);  /* check that SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_TLS_BLOCK_PADDING_BUG(unsigned long long *o)
{
  int n = (SSL_OP_TLS_BLOCK_PADDING_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_TLS_BLOCK_PADDING_BUG) | 0);  /* check that SSL_OP_TLS_BLOCK_PADDING_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_TLS_D5_BUG(unsigned long long *o)
{
  int n = (SSL_OP_TLS_D5_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_TLS_D5_BUG) | 0);  /* check that SSL_OP_TLS_D5_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_OP_TLS_ROLLBACK_BUG(unsigned long long *o)
{
  int n = (SSL_OP_TLS_ROLLBACK_BUG) <= 0;
  *o = (unsigned long long)((SSL_OP_TLS_ROLLBACK_BUG) | 0);  /* check that SSL_OP_TLS_ROLLBACK_BUG is an integer */
  return n;
}

static int _cffi_const_SSL_RECEIVED_SHUTDOWN(unsigned long long *o)
{
  int n = (SSL_RECEIVED_SHUTDOWN) <= 0;
  *o = (unsigned long long)((SSL_RECEIVED_SHUTDOWN) | 0);  /* check that SSL_RECEIVED_SHUTDOWN is an integer */
  return n;
}

static int _cffi_const_SSL_SENT_SHUTDOWN(unsigned long long *o)
{
  int n = (SSL_SENT_SHUTDOWN) <= 0;
  *o = (unsigned long long)((SSL_SENT_SHUTDOWN) | 0);  /* check that SSL_SENT_SHUTDOWN is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_BOTH(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_BOTH) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_BOTH) | 0);  /* check that SSL_SESS_CACHE_BOTH is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_CLIENT(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_CLIENT) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_CLIENT) | 0);  /* check that SSL_SESS_CACHE_CLIENT is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_NO_AUTO_CLEAR(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_NO_AUTO_CLEAR) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_NO_AUTO_CLEAR) | 0);  /* check that SSL_SESS_CACHE_NO_AUTO_CLEAR is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_NO_INTERNAL(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_NO_INTERNAL) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_NO_INTERNAL) | 0);  /* check that SSL_SESS_CACHE_NO_INTERNAL is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_NO_INTERNAL_LOOKUP) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_NO_INTERNAL_LOOKUP) | 0);  /* check that SSL_SESS_CACHE_NO_INTERNAL_LOOKUP is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_NO_INTERNAL_STORE(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_NO_INTERNAL_STORE) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_NO_INTERNAL_STORE) | 0);  /* check that SSL_SESS_CACHE_NO_INTERNAL_STORE is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_OFF(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_OFF) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_OFF) | 0);  /* check that SSL_SESS_CACHE_OFF is an integer */
  return n;
}

static int _cffi_const_SSL_SESS_CACHE_SERVER(unsigned long long *o)
{
  int n = (SSL_SESS_CACHE_SERVER) <= 0;
  *o = (unsigned long long)((SSL_SESS_CACHE_SERVER) | 0);  /* check that SSL_SESS_CACHE_SERVER is an integer */
  return n;
}

static int _cffi_const_SSL_ST_ACCEPT(unsigned long long *o)
{
  int n = (SSL_ST_ACCEPT) <= 0;
  *o = (unsigned long long)((SSL_ST_ACCEPT) | 0);  /* check that SSL_ST_ACCEPT is an integer */
  return n;
}

static int _cffi_const_SSL_ST_BEFORE(unsigned long long *o)
{
  int n = (SSL_ST_BEFORE) <= 0;
  *o = (unsigned long long)((SSL_ST_BEFORE) | 0);  /* check that SSL_ST_BEFORE is an integer */
  return n;
}

static int _cffi_const_SSL_ST_CONNECT(unsigned long long *o)
{
  int n = (SSL_ST_CONNECT) <= 0;
  *o = (unsigned long long)((SSL_ST_CONNECT) | 0);  /* check that SSL_ST_CONNECT is an integer */
  return n;
}

static int _cffi_const_SSL_ST_INIT(unsigned long long *o)
{
  int n = (SSL_ST_INIT) <= 0;
  *o = (unsigned long long)((SSL_ST_INIT) | 0);  /* check that SSL_ST_INIT is an integer */
  return n;
}

static int _cffi_const_SSL_ST_MASK(unsigned long long *o)
{
  int n = (SSL_ST_MASK) <= 0;
  *o = (unsigned long long)((SSL_ST_MASK) | 0);  /* check that SSL_ST_MASK is an integer */
  return n;
}

static int _cffi_const_SSL_ST_OK(unsigned long long *o)
{
  int n = (SSL_ST_OK) <= 0;
  *o = (unsigned long long)((SSL_ST_OK) | 0);  /* check that SSL_ST_OK is an integer */
  return n;
}

static int _cffi_const_SSL_ST_RENEGOTIATE(unsigned long long *o)
{
  int n = (SSL_ST_RENEGOTIATE) <= 0;
  *o = (unsigned long long)((SSL_ST_RENEGOTIATE) | 0);  /* check that SSL_ST_RENEGOTIATE is an integer */
  return n;
}

static int _cffi_const_SSL_TLSEXT_ERR_ALERT_FATAL(unsigned long long *o)
{
  int n = (SSL_TLSEXT_ERR_ALERT_FATAL) <= 0;
  *o = (unsigned long long)((SSL_TLSEXT_ERR_ALERT_FATAL) | 0);  /* check that SSL_TLSEXT_ERR_ALERT_FATAL is an integer */
  return n;
}

static int _cffi_const_SSL_TLSEXT_ERR_ALERT_WARNING(unsigned long long *o)
{
  int n = (SSL_TLSEXT_ERR_ALERT_WARNING) <= 0;
  *o = (unsigned long long)((SSL_TLSEXT_ERR_ALERT_WARNING) | 0);  /* check that SSL_TLSEXT_ERR_ALERT_WARNING is an integer */
  return n;
}

static int _cffi_const_SSL_TLSEXT_ERR_NOACK(unsigned long long *o)
{
  int n = (SSL_TLSEXT_ERR_NOACK) <= 0;
  *o = (unsigned long long)((SSL_TLSEXT_ERR_NOACK) | 0);  /* check that SSL_TLSEXT_ERR_NOACK is an integer */
  return n;
}

static int _cffi_const_SSL_TLSEXT_ERR_OK(unsigned long long *o)
{
  int n = (SSL_TLSEXT_ERR_OK) <= 0;
  *o = (unsigned long long)((SSL_TLSEXT_ERR_OK) | 0);  /* check that SSL_TLSEXT_ERR_OK is an integer */
  return n;
}

static int _cffi_const_SSL_VERIFY_CLIENT_ONCE(unsigned long long *o)
{
  int n = (SSL_VERIFY_CLIENT_ONCE) <= 0;
  *o = (unsigned long long)((SSL_VERIFY_CLIENT_ONCE) | 0);  /* check that SSL_VERIFY_CLIENT_ONCE is an integer */
  return n;
}

static int _cffi_const_SSL_VERIFY_FAIL_IF_NO_PEER_CERT(unsigned long long *o)
{
  int n = (SSL_VERIFY_FAIL_IF_NO_PEER_CERT) <= 0;
  *o = (unsigned long long)((SSL_VERIFY_FAIL_IF_NO_PEER_CERT) | 0);  /* check that SSL_VERIFY_FAIL_IF_NO_PEER_CERT is an integer */
  return n;
}

static int _cffi_const_SSL_VERIFY_NONE(unsigned long long *o)
{
  int n = (SSL_VERIFY_NONE) <= 0;
  *o = (unsigned long long)((SSL_VERIFY_NONE) | 0);  /* check that SSL_VERIFY_NONE is an integer */
  return n;
}

static int _cffi_const_SSL_VERIFY_PEER(unsigned long long *o)
{
  int n = (SSL_VERIFY_PEER) <= 0;
  *o = (unsigned long long)((SSL_VERIFY_PEER) | 0);  /* check that SSL_VERIFY_PEER is an integer */
  return n;
}

static int _cffi_const_TLSEXT_NAMETYPE_host_name(unsigned long long *o)
{
  int n = (TLSEXT_NAMETYPE_host_name) <= 0;
  *o = (unsigned long long)((TLSEXT_NAMETYPE_host_name) | 0);  /* check that TLSEXT_NAMETYPE_host_name is an integer */
  return n;
}

static int _cffi_const_TLSEXT_STATUSTYPE_ocsp(unsigned long long *o)
{
  int n = (TLSEXT_STATUSTYPE_ocsp) <= 0;
  *o = (unsigned long long)((TLSEXT_STATUSTYPE_ocsp) | 0);  /* check that TLSEXT_STATUSTYPE_ocsp is an integer */
  return n;
}

static int _cffi_const_TLS_ST_BEFORE(unsigned long long *o)
{
  int n = (TLS_ST_BEFORE) <= 0;
  *o = (unsigned long long)((TLS_ST_BEFORE) | 0);  /* check that TLS_ST_BEFORE is an integer */
  return n;
}

static int _cffi_const_TLS_ST_OK(unsigned long long *o)
{
  int n = (TLS_ST_OK) <= 0;
  *o = (unsigned long long)((TLS_ST_OK) | 0);  /* check that TLS_ST_OK is an integer */
  return n;
}

static int _cffi_const_V_ASN1_GENERALIZEDTIME(unsigned long long *o)
{
  int n = (V_ASN1_GENERALIZEDTIME) <= 0;
  *o = (unsigned long long)((V_ASN1_GENERALIZEDTIME) | 0);  /* check that V_ASN1_GENERALIZEDTIME is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_COMPAT(unsigned long long *o)
{
  int n = (X509_FLAG_COMPAT) <= 0;
  *o = (unsigned long long)((X509_FLAG_COMPAT) | 0);  /* check that X509_FLAG_COMPAT is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_ATTRIBUTES(unsigned long long *o)
{
  int n = (X509_FLAG_NO_ATTRIBUTES) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_ATTRIBUTES) | 0);  /* check that X509_FLAG_NO_ATTRIBUTES is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_AUX(unsigned long long *o)
{
  int n = (X509_FLAG_NO_AUX) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_AUX) | 0);  /* check that X509_FLAG_NO_AUX is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_EXTENSIONS(unsigned long long *o)
{
  int n = (X509_FLAG_NO_EXTENSIONS) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_EXTENSIONS) | 0);  /* check that X509_FLAG_NO_EXTENSIONS is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_HEADER(unsigned long long *o)
{
  int n = (X509_FLAG_NO_HEADER) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_HEADER) | 0);  /* check that X509_FLAG_NO_HEADER is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_ISSUER(unsigned long long *o)
{
  int n = (X509_FLAG_NO_ISSUER) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_ISSUER) | 0);  /* check that X509_FLAG_NO_ISSUER is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_PUBKEY(unsigned long long *o)
{
  int n = (X509_FLAG_NO_PUBKEY) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_PUBKEY) | 0);  /* check that X509_FLAG_NO_PUBKEY is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_SERIAL(unsigned long long *o)
{
  int n = (X509_FLAG_NO_SERIAL) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_SERIAL) | 0);  /* check that X509_FLAG_NO_SERIAL is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_SIGDUMP(unsigned long long *o)
{
  int n = (X509_FLAG_NO_SIGDUMP) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_SIGDUMP) | 0);  /* check that X509_FLAG_NO_SIGDUMP is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_SIGNAME(unsigned long long *o)
{
  int n = (X509_FLAG_NO_SIGNAME) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_SIGNAME) | 0);  /* check that X509_FLAG_NO_SIGNAME is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_SUBJECT(unsigned long long *o)
{
  int n = (X509_FLAG_NO_SUBJECT) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_SUBJECT) | 0);  /* check that X509_FLAG_NO_SUBJECT is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_VALIDITY(unsigned long long *o)
{
  int n = (X509_FLAG_NO_VALIDITY) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_VALIDITY) | 0);  /* check that X509_FLAG_NO_VALIDITY is an integer */
  return n;
}

static int _cffi_const_X509_FLAG_NO_VERSION(unsigned long long *o)
{
  int n = (X509_FLAG_NO_VERSION) <= 0;
  *o = (unsigned long long)((X509_FLAG_NO_VERSION) | 0);  /* check that X509_FLAG_NO_VERSION is an integer */
  return n;
}

static int _cffi_const_X509_LU_CRL(unsigned long long *o)
{
  int n = (X509_LU_CRL) <= 0;
  *o = (unsigned long long)((X509_LU_CRL) | 0);  /* check that X509_LU_CRL is an integer */
  return n;
}

static int _cffi_const_X509_LU_X509(unsigned long long *o)
{
  int n = (X509_LU_X509) <= 0;
  *o = (unsigned long long)((X509_LU_X509) | 0);  /* check that X509_LU_X509 is an integer */
  return n;
}

static int _cffi_const_X509_R_CERT_ALREADY_IN_HASH_TABLE(unsigned long long *o)
{
  int n = (X509_R_CERT_ALREADY_IN_HASH_TABLE) <= 0;
  *o = (unsigned long long)((X509_R_CERT_ALREADY_IN_HASH_TABLE) | 0);  /* check that X509_R_CERT_ALREADY_IN_HASH_TABLE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH(unsigned long long *o)
{
  int n = (X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH) <= 0;
  *o = (unsigned long long)((X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH) | 0);  /* check that X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_AKID_SKID_MISMATCH(unsigned long long *o)
{
  int n = (X509_V_ERR_AKID_SKID_MISMATCH) <= 0;
  *o = (unsigned long long)((X509_V_ERR_AKID_SKID_MISMATCH) | 0);  /* check that X509_V_ERR_AKID_SKID_MISMATCH is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_APPLICATION_VERIFICATION(unsigned long long *o)
{
  int n = (X509_V_ERR_APPLICATION_VERIFICATION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_APPLICATION_VERIFICATION) | 0);  /* check that X509_V_ERR_APPLICATION_VERIFICATION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_CHAIN_TOO_LONG(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_CHAIN_TOO_LONG) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_CHAIN_TOO_LONG) | 0);  /* check that X509_V_ERR_CERT_CHAIN_TOO_LONG is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_HAS_EXPIRED(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_HAS_EXPIRED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_HAS_EXPIRED) | 0);  /* check that X509_V_ERR_CERT_HAS_EXPIRED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_NOT_YET_VALID(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_NOT_YET_VALID) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_NOT_YET_VALID) | 0);  /* check that X509_V_ERR_CERT_NOT_YET_VALID is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_REJECTED(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_REJECTED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_REJECTED) | 0);  /* check that X509_V_ERR_CERT_REJECTED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_REVOKED(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_REVOKED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_REVOKED) | 0);  /* check that X509_V_ERR_CERT_REVOKED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_SIGNATURE_FAILURE(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_SIGNATURE_FAILURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_SIGNATURE_FAILURE) | 0);  /* check that X509_V_ERR_CERT_SIGNATURE_FAILURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CERT_UNTRUSTED(unsigned long long *o)
{
  int n = (X509_V_ERR_CERT_UNTRUSTED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CERT_UNTRUSTED) | 0);  /* check that X509_V_ERR_CERT_UNTRUSTED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CRL_HAS_EXPIRED(unsigned long long *o)
{
  int n = (X509_V_ERR_CRL_HAS_EXPIRED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CRL_HAS_EXPIRED) | 0);  /* check that X509_V_ERR_CRL_HAS_EXPIRED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CRL_NOT_YET_VALID(unsigned long long *o)
{
  int n = (X509_V_ERR_CRL_NOT_YET_VALID) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CRL_NOT_YET_VALID) | 0);  /* check that X509_V_ERR_CRL_NOT_YET_VALID is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CRL_PATH_VALIDATION_ERROR(unsigned long long *o)
{
  int n = (X509_V_ERR_CRL_PATH_VALIDATION_ERROR) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CRL_PATH_VALIDATION_ERROR) | 0);  /* check that X509_V_ERR_CRL_PATH_VALIDATION_ERROR is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_CRL_SIGNATURE_FAILURE(unsigned long long *o)
{
  int n = (X509_V_ERR_CRL_SIGNATURE_FAILURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_CRL_SIGNATURE_FAILURE) | 0);  /* check that X509_V_ERR_CRL_SIGNATURE_FAILURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT(unsigned long long *o)
{
  int n = (X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) <= 0;
  *o = (unsigned long long)((X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) | 0);  /* check that X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_DIFFERENT_CRL_SCOPE(unsigned long long *o)
{
  int n = (X509_V_ERR_DIFFERENT_CRL_SCOPE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_DIFFERENT_CRL_SCOPE) | 0);  /* check that X509_V_ERR_DIFFERENT_CRL_SCOPE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_EMAIL_MISMATCH(unsigned long long *o)
{
  int n = (X509_V_ERR_EMAIL_MISMATCH) <= 0;
  *o = (unsigned long long)((X509_V_ERR_EMAIL_MISMATCH) | 0);  /* check that X509_V_ERR_EMAIL_MISMATCH is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD(unsigned long long *o)
{
  int n = (X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD) <= 0;
  *o = (unsigned long long)((X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD) | 0);  /* check that X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD(unsigned long long *o)
{
  int n = (X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD) <= 0;
  *o = (unsigned long long)((X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD) | 0);  /* check that X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD(unsigned long long *o)
{
  int n = (X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD) <= 0;
  *o = (unsigned long long)((X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD) | 0);  /* check that X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD(unsigned long long *o)
{
  int n = (X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD) <= 0;
  *o = (unsigned long long)((X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD) | 0);  /* check that X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_EXCLUDED_VIOLATION(unsigned long long *o)
{
  int n = (X509_V_ERR_EXCLUDED_VIOLATION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_EXCLUDED_VIOLATION) | 0);  /* check that X509_V_ERR_EXCLUDED_VIOLATION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_HOSTNAME_MISMATCH(unsigned long long *o)
{
  int n = (X509_V_ERR_HOSTNAME_MISMATCH) <= 0;
  *o = (unsigned long long)((X509_V_ERR_HOSTNAME_MISMATCH) | 0);  /* check that X509_V_ERR_HOSTNAME_MISMATCH is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_INVALID_CA(unsigned long long *o)
{
  int n = (X509_V_ERR_INVALID_CA) <= 0;
  *o = (unsigned long long)((X509_V_ERR_INVALID_CA) | 0);  /* check that X509_V_ERR_INVALID_CA is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_INVALID_EXTENSION(unsigned long long *o)
{
  int n = (X509_V_ERR_INVALID_EXTENSION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_INVALID_EXTENSION) | 0);  /* check that X509_V_ERR_INVALID_EXTENSION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_INVALID_NON_CA(unsigned long long *o)
{
  int n = (X509_V_ERR_INVALID_NON_CA) <= 0;
  *o = (unsigned long long)((X509_V_ERR_INVALID_NON_CA) | 0);  /* check that X509_V_ERR_INVALID_NON_CA is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_INVALID_POLICY_EXTENSION(unsigned long long *o)
{
  int n = (X509_V_ERR_INVALID_POLICY_EXTENSION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_INVALID_POLICY_EXTENSION) | 0);  /* check that X509_V_ERR_INVALID_POLICY_EXTENSION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_INVALID_PURPOSE(unsigned long long *o)
{
  int n = (X509_V_ERR_INVALID_PURPOSE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_INVALID_PURPOSE) | 0);  /* check that X509_V_ERR_INVALID_PURPOSE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_IP_ADDRESS_MISMATCH(unsigned long long *o)
{
  int n = (X509_V_ERR_IP_ADDRESS_MISMATCH) <= 0;
  *o = (unsigned long long)((X509_V_ERR_IP_ADDRESS_MISMATCH) | 0);  /* check that X509_V_ERR_IP_ADDRESS_MISMATCH is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_KEYUSAGE_NO_CERTSIGN(unsigned long long *o)
{
  int n = (X509_V_ERR_KEYUSAGE_NO_CERTSIGN) <= 0;
  *o = (unsigned long long)((X509_V_ERR_KEYUSAGE_NO_CERTSIGN) | 0);  /* check that X509_V_ERR_KEYUSAGE_NO_CERTSIGN is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_KEYUSAGE_NO_CRL_SIGN(unsigned long long *o)
{
  int n = (X509_V_ERR_KEYUSAGE_NO_CRL_SIGN) <= 0;
  *o = (unsigned long long)((X509_V_ERR_KEYUSAGE_NO_CRL_SIGN) | 0);  /* check that X509_V_ERR_KEYUSAGE_NO_CRL_SIGN is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE(unsigned long long *o)
{
  int n = (X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE) | 0);  /* check that X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_NO_EXPLICIT_POLICY(unsigned long long *o)
{
  int n = (X509_V_ERR_NO_EXPLICIT_POLICY) <= 0;
  *o = (unsigned long long)((X509_V_ERR_NO_EXPLICIT_POLICY) | 0);  /* check that X509_V_ERR_NO_EXPLICIT_POLICY is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_OUT_OF_MEM(unsigned long long *o)
{
  int n = (X509_V_ERR_OUT_OF_MEM) <= 0;
  *o = (unsigned long long)((X509_V_ERR_OUT_OF_MEM) | 0);  /* check that X509_V_ERR_OUT_OF_MEM is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_PATH_LENGTH_EXCEEDED(unsigned long long *o)
{
  int n = (X509_V_ERR_PATH_LENGTH_EXCEEDED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_PATH_LENGTH_EXCEEDED) | 0);  /* check that X509_V_ERR_PATH_LENGTH_EXCEEDED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_PERMITTED_VIOLATION(unsigned long long *o)
{
  int n = (X509_V_ERR_PERMITTED_VIOLATION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_PERMITTED_VIOLATION) | 0);  /* check that X509_V_ERR_PERMITTED_VIOLATION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED(unsigned long long *o)
{
  int n = (X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED) | 0);  /* check that X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED(unsigned long long *o)
{
  int n = (X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED) | 0);  /* check that X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN(unsigned long long *o)
{
  int n = (X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) | 0);  /* check that X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUBJECT_ISSUER_MISMATCH(unsigned long long *o)
{
  int n = (X509_V_ERR_SUBJECT_ISSUER_MISMATCH) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUBJECT_ISSUER_MISMATCH) | 0);  /* check that X509_V_ERR_SUBJECT_ISSUER_MISMATCH is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUBTREE_MINMAX(unsigned long long *o)
{
  int n = (X509_V_ERR_SUBTREE_MINMAX) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUBTREE_MINMAX) | 0);  /* check that X509_V_ERR_SUBTREE_MINMAX is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256(unsigned long long *o)
{
  int n = (X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256) | 0);  /* check that X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUITE_B_INVALID_ALGORITHM(unsigned long long *o)
{
  int n = (X509_V_ERR_SUITE_B_INVALID_ALGORITHM) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUITE_B_INVALID_ALGORITHM) | 0);  /* check that X509_V_ERR_SUITE_B_INVALID_ALGORITHM is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUITE_B_INVALID_CURVE(unsigned long long *o)
{
  int n = (X509_V_ERR_SUITE_B_INVALID_CURVE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUITE_B_INVALID_CURVE) | 0);  /* check that X509_V_ERR_SUITE_B_INVALID_CURVE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM(unsigned long long *o)
{
  int n = (X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM) | 0);  /* check that X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUITE_B_INVALID_VERSION(unsigned long long *o)
{
  int n = (X509_V_ERR_SUITE_B_INVALID_VERSION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUITE_B_INVALID_VERSION) | 0);  /* check that X509_V_ERR_SUITE_B_INVALID_VERSION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED(unsigned long long *o)
{
  int n = (X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED) <= 0;
  *o = (unsigned long long)((X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED) | 0);  /* check that X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY) | 0);  /* check that X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE) | 0);  /* check that X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE) | 0);  /* check that X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_GET_CRL(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_GET_CRL) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_GET_CRL) | 0);  /* check that X509_V_ERR_UNABLE_TO_GET_CRL is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER) | 0);  /* check that X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT) | 0);  /* check that X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) | 0);  /* check that X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE(unsigned long long *o)
{
  int n = (X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE) | 0);  /* check that X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION(unsigned long long *o)
{
  int n = (X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION) | 0);  /* check that X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION(unsigned long long *o)
{
  int n = (X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION) | 0);  /* check that X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNNESTED_RESOURCE(unsigned long long *o)
{
  int n = (X509_V_ERR_UNNESTED_RESOURCE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNNESTED_RESOURCE) | 0);  /* check that X509_V_ERR_UNNESTED_RESOURCE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX(unsigned long long *o)
{
  int n = (X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX) | 0);  /* check that X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE(unsigned long long *o)
{
  int n = (X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE) | 0);  /* check that X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE(unsigned long long *o)
{
  int n = (X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE) | 0);  /* check that X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE is an integer */
  return n;
}

static int _cffi_const_X509_V_ERR_UNSUPPORTED_NAME_SYNTAX(unsigned long long *o)
{
  int n = (X509_V_ERR_UNSUPPORTED_NAME_SYNTAX) <= 0;
  *o = (unsigned long long)((X509_V_ERR_UNSUPPORTED_NAME_SYNTAX) | 0);  /* check that X509_V_ERR_UNSUPPORTED_NAME_SYNTAX is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_ALLOW_PROXY_CERTS(unsigned long long *o)
{
  int n = (X509_V_FLAG_ALLOW_PROXY_CERTS) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_ALLOW_PROXY_CERTS) | 0);  /* check that X509_V_FLAG_ALLOW_PROXY_CERTS is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_CB_ISSUER_CHECK(unsigned long long *o)
{
  int n = (X509_V_FLAG_CB_ISSUER_CHECK) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_CB_ISSUER_CHECK) | 0);  /* check that X509_V_FLAG_CB_ISSUER_CHECK is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_CHECK_SS_SIGNATURE(unsigned long long *o)
{
  int n = (X509_V_FLAG_CHECK_SS_SIGNATURE) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_CHECK_SS_SIGNATURE) | 0);  /* check that X509_V_FLAG_CHECK_SS_SIGNATURE is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_CRL_CHECK(unsigned long long *o)
{
  int n = (X509_V_FLAG_CRL_CHECK) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_CRL_CHECK) | 0);  /* check that X509_V_FLAG_CRL_CHECK is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_CRL_CHECK_ALL(unsigned long long *o)
{
  int n = (X509_V_FLAG_CRL_CHECK_ALL) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_CRL_CHECK_ALL) | 0);  /* check that X509_V_FLAG_CRL_CHECK_ALL is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_EXPLICIT_POLICY(unsigned long long *o)
{
  int n = (X509_V_FLAG_EXPLICIT_POLICY) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_EXPLICIT_POLICY) | 0);  /* check that X509_V_FLAG_EXPLICIT_POLICY is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_EXTENDED_CRL_SUPPORT(unsigned long long *o)
{
  int n = (X509_V_FLAG_EXTENDED_CRL_SUPPORT) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_EXTENDED_CRL_SUPPORT) | 0);  /* check that X509_V_FLAG_EXTENDED_CRL_SUPPORT is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_IGNORE_CRITICAL(unsigned long long *o)
{
  int n = (X509_V_FLAG_IGNORE_CRITICAL) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_IGNORE_CRITICAL) | 0);  /* check that X509_V_FLAG_IGNORE_CRITICAL is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_INHIBIT_ANY(unsigned long long *o)
{
  int n = (X509_V_FLAG_INHIBIT_ANY) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_INHIBIT_ANY) | 0);  /* check that X509_V_FLAG_INHIBIT_ANY is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_INHIBIT_MAP(unsigned long long *o)
{
  int n = (X509_V_FLAG_INHIBIT_MAP) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_INHIBIT_MAP) | 0);  /* check that X509_V_FLAG_INHIBIT_MAP is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_NOTIFY_POLICY(unsigned long long *o)
{
  int n = (X509_V_FLAG_NOTIFY_POLICY) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_NOTIFY_POLICY) | 0);  /* check that X509_V_FLAG_NOTIFY_POLICY is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_PARTIAL_CHAIN(unsigned long long *o)
{
  int n = (X509_V_FLAG_PARTIAL_CHAIN) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_PARTIAL_CHAIN) | 0);  /* check that X509_V_FLAG_PARTIAL_CHAIN is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_POLICY_CHECK(unsigned long long *o)
{
  int n = (X509_V_FLAG_POLICY_CHECK) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_POLICY_CHECK) | 0);  /* check that X509_V_FLAG_POLICY_CHECK is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_SUITEB_128_LOS(unsigned long long *o)
{
  int n = (X509_V_FLAG_SUITEB_128_LOS) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_SUITEB_128_LOS) | 0);  /* check that X509_V_FLAG_SUITEB_128_LOS is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_SUITEB_128_LOS_ONLY(unsigned long long *o)
{
  int n = (X509_V_FLAG_SUITEB_128_LOS_ONLY) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_SUITEB_128_LOS_ONLY) | 0);  /* check that X509_V_FLAG_SUITEB_128_LOS_ONLY is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_SUITEB_192_LOS(unsigned long long *o)
{
  int n = (X509_V_FLAG_SUITEB_192_LOS) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_SUITEB_192_LOS) | 0);  /* check that X509_V_FLAG_SUITEB_192_LOS is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_TRUSTED_FIRST(unsigned long long *o)
{
  int n = (X509_V_FLAG_TRUSTED_FIRST) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_TRUSTED_FIRST) | 0);  /* check that X509_V_FLAG_TRUSTED_FIRST is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_USE_CHECK_TIME(unsigned long long *o)
{
  int n = (X509_V_FLAG_USE_CHECK_TIME) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_USE_CHECK_TIME) | 0);  /* check that X509_V_FLAG_USE_CHECK_TIME is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_USE_DELTAS(unsigned long long *o)
{
  int n = (X509_V_FLAG_USE_DELTAS) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_USE_DELTAS) | 0);  /* check that X509_V_FLAG_USE_DELTAS is an integer */
  return n;
}

static int _cffi_const_X509_V_FLAG_X509_STRICT(unsigned long long *o)
{
  int n = (X509_V_FLAG_X509_STRICT) <= 0;
  *o = (unsigned long long)((X509_V_FLAG_X509_STRICT) | 0);  /* check that X509_V_FLAG_X509_STRICT is an integer */
  return n;
}

static int _cffi_const_X509_V_OK(unsigned long long *o)
{
  int n = (X509_V_OK) <= 0;
  *o = (unsigned long long)((X509_V_OK) | 0);  /* check that X509_V_OK is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_COMPAT(unsigned long long *o)
{
  int n = (XN_FLAG_COMPAT) <= 0;
  *o = (unsigned long long)((XN_FLAG_COMPAT) | 0);  /* check that XN_FLAG_COMPAT is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_DN_REV(unsigned long long *o)
{
  int n = (XN_FLAG_DN_REV) <= 0;
  *o = (unsigned long long)((XN_FLAG_DN_REV) | 0);  /* check that XN_FLAG_DN_REV is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_DUMP_UNKNOWN_FIELDS(unsigned long long *o)
{
  int n = (XN_FLAG_DUMP_UNKNOWN_FIELDS) <= 0;
  *o = (unsigned long long)((XN_FLAG_DUMP_UNKNOWN_FIELDS) | 0);  /* check that XN_FLAG_DUMP_UNKNOWN_FIELDS is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_FN_ALIGN(unsigned long long *o)
{
  int n = (XN_FLAG_FN_ALIGN) <= 0;
  *o = (unsigned long long)((XN_FLAG_FN_ALIGN) | 0);  /* check that XN_FLAG_FN_ALIGN is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_FN_LN(unsigned long long *o)
{
  int n = (XN_FLAG_FN_LN) <= 0;
  *o = (unsigned long long)((XN_FLAG_FN_LN) | 0);  /* check that XN_FLAG_FN_LN is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_FN_MASK(unsigned long long *o)
{
  int n = (XN_FLAG_FN_MASK) <= 0;
  *o = (unsigned long long)((XN_FLAG_FN_MASK) | 0);  /* check that XN_FLAG_FN_MASK is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_FN_NONE(unsigned long long *o)
{
  int n = (XN_FLAG_FN_NONE) <= 0;
  *o = (unsigned long long)((XN_FLAG_FN_NONE) | 0);  /* check that XN_FLAG_FN_NONE is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_FN_OID(unsigned long long *o)
{
  int n = (XN_FLAG_FN_OID) <= 0;
  *o = (unsigned long long)((XN_FLAG_FN_OID) | 0);  /* check that XN_FLAG_FN_OID is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_FN_SN(unsigned long long *o)
{
  int n = (XN_FLAG_FN_SN) <= 0;
  *o = (unsigned long long)((XN_FLAG_FN_SN) | 0);  /* check that XN_FLAG_FN_SN is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_MULTILINE(unsigned long long *o)
{
  int n = (XN_FLAG_MULTILINE) <= 0;
  *o = (unsigned long long)((XN_FLAG_MULTILINE) | 0);  /* check that XN_FLAG_MULTILINE is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_ONELINE(unsigned long long *o)
{
  int n = (XN_FLAG_ONELINE) <= 0;
  *o = (unsigned long long)((XN_FLAG_ONELINE) | 0);  /* check that XN_FLAG_ONELINE is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_RFC2253(unsigned long long *o)
{
  int n = (XN_FLAG_RFC2253) <= 0;
  *o = (unsigned long long)((XN_FLAG_RFC2253) | 0);  /* check that XN_FLAG_RFC2253 is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_SEP_COMMA_PLUS(unsigned long long *o)
{
  int n = (XN_FLAG_SEP_COMMA_PLUS) <= 0;
  *o = (unsigned long long)((XN_FLAG_SEP_COMMA_PLUS) | 0);  /* check that XN_FLAG_SEP_COMMA_PLUS is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_SEP_CPLUS_SPC(unsigned long long *o)
{
  int n = (XN_FLAG_SEP_CPLUS_SPC) <= 0;
  *o = (unsigned long long)((XN_FLAG_SEP_CPLUS_SPC) | 0);  /* check that XN_FLAG_SEP_CPLUS_SPC is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_SEP_MASK(unsigned long long *o)
{
  int n = (XN_FLAG_SEP_MASK) <= 0;
  *o = (unsigned long long)((XN_FLAG_SEP_MASK) | 0);  /* check that XN_FLAG_SEP_MASK is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_SEP_MULTILINE(unsigned long long *o)
{
  int n = (XN_FLAG_SEP_MULTILINE) <= 0;
  *o = (unsigned long long)((XN_FLAG_SEP_MULTILINE) | 0);  /* check that XN_FLAG_SEP_MULTILINE is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_SEP_SPLUS_SPC(unsigned long long *o)
{
  int n = (XN_FLAG_SEP_SPLUS_SPC) <= 0;
  *o = (unsigned long long)((XN_FLAG_SEP_SPLUS_SPC) | 0);  /* check that XN_FLAG_SEP_SPLUS_SPC is an integer */
  return n;
}

static int _cffi_const_XN_FLAG_SPC_EQ(unsigned long long *o)
{
  int n = (XN_FLAG_SPC_EQ) <= 0;
  *o = (unsigned long long)((XN_FLAG_SPC_EQ) | 0);  /* check that XN_FLAG_SPC_EQ is an integer */
  return n;
}

static void _cffi_d_ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION * x0)
{
  ACCESS_DESCRIPTION_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ACCESS_DESCRIPTION_free(PyObject *self, PyObject *arg0)
{
  ACCESS_DESCRIPTION * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1394), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ACCESS_DESCRIPTION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1394), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ACCESS_DESCRIPTION_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ACCESS_DESCRIPTION_free _cffi_d_ACCESS_DESCRIPTION_free
#endif

static ACCESS_DESCRIPTION * _cffi_d_ACCESS_DESCRIPTION_new(void)
{
  return ACCESS_DESCRIPTION_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ACCESS_DESCRIPTION_new(PyObject *self, PyObject *noarg)
{
  ACCESS_DESCRIPTION * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ACCESS_DESCRIPTION_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1394));
}
#else
#  define _cffi_f_ACCESS_DESCRIPTION_new _cffi_d_ACCESS_DESCRIPTION_new
#endif

static int _cffi_d_AES_set_decrypt_key(unsigned char const * x0, int x1, AES_KEY * x2)
{
  return AES_set_decrypt_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_AES_set_decrypt_key(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  int x1;
  AES_KEY * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "AES_set_decrypt_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(148), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(973), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (AES_KEY *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(973), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = AES_set_decrypt_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_AES_set_decrypt_key _cffi_d_AES_set_decrypt_key
#endif

static int _cffi_d_AES_set_encrypt_key(unsigned char const * x0, int x1, AES_KEY * x2)
{
  return AES_set_encrypt_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_AES_set_encrypt_key(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  int x1;
  AES_KEY * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "AES_set_encrypt_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(148), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(973), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (AES_KEY *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(973), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = AES_set_encrypt_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_AES_set_encrypt_key _cffi_d_AES_set_encrypt_key
#endif

static int _cffi_d_AES_unwrap_key(AES_KEY * x0, unsigned char const * x1, unsigned char * x2, unsigned char const * x3, unsigned int x4)
{
  return AES_unwrap_key(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_AES_unwrap_key(PyObject *self, PyObject *args)
{
  AES_KEY * x0;
  unsigned char const * x1;
  unsigned char * x2;
  unsigned char const * x3;
  unsigned int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "AES_unwrap_key", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(973), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (AES_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(973), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, unsigned int);
  if (x4 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = AES_unwrap_key(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_AES_unwrap_key _cffi_d_AES_unwrap_key
#endif

static int _cffi_d_AES_wrap_key(AES_KEY * x0, unsigned char const * x1, unsigned char * x2, unsigned char const * x3, unsigned int x4)
{
  return AES_wrap_key(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_AES_wrap_key(PyObject *self, PyObject *args)
{
  AES_KEY * x0;
  unsigned char const * x1;
  unsigned char * x2;
  unsigned char const * x3;
  unsigned int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "AES_wrap_key", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(973), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (AES_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(973), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, unsigned int);
  if (x4 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = AES_wrap_key(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_AES_wrap_key _cffi_d_AES_wrap_key
#endif

static void _cffi_d_ASN1_BIT_STRING_free(ASN1_OCTET_STRING * x0)
{
  ASN1_BIT_STRING_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_BIT_STRING_free(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_BIT_STRING_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_BIT_STRING_free _cffi_d_ASN1_BIT_STRING_free
#endif

static int _cffi_d_ASN1_BIT_STRING_get_bit(ASN1_OCTET_STRING * x0, int x1)
{
  return ASN1_BIT_STRING_get_bit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_BIT_STRING_get_bit(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_BIT_STRING_get_bit", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_BIT_STRING_get_bit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_BIT_STRING_get_bit _cffi_d_ASN1_BIT_STRING_get_bit
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_BIT_STRING_new(void)
{
  return ASN1_BIT_STRING_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_BIT_STRING_new(PyObject *self, PyObject *noarg)
{
  ASN1_OCTET_STRING * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_BIT_STRING_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_BIT_STRING_new _cffi_d_ASN1_BIT_STRING_new
#endif

static int _cffi_d_ASN1_BIT_STRING_set_bit(ASN1_OCTET_STRING * x0, int x1, int x2)
{
  return ASN1_BIT_STRING_set_bit(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_BIT_STRING_set_bit(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  int x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ASN1_BIT_STRING_set_bit", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_BIT_STRING_set_bit(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_BIT_STRING_set_bit _cffi_d_ASN1_BIT_STRING_set_bit
#endif

static void _cffi_d_ASN1_ENUMERATED_free(ASN1_ENUMERATED * x0)
{
  ASN1_ENUMERATED_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_ENUMERATED_free(PyObject *self, PyObject *arg0)
{
  ASN1_ENUMERATED * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(980), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_ENUMERATED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(980), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_ENUMERATED_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_ENUMERATED_free _cffi_d_ASN1_ENUMERATED_free
#endif

static long _cffi_d_ASN1_ENUMERATED_get(ASN1_ENUMERATED * x0)
{
  return ASN1_ENUMERATED_get(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_ENUMERATED_get(PyObject *self, PyObject *arg0)
{
  ASN1_ENUMERATED * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(980), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_ENUMERATED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(980), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_ENUMERATED_get(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_ASN1_ENUMERATED_get _cffi_d_ASN1_ENUMERATED_get
#endif

static ASN1_ENUMERATED * _cffi_d_ASN1_ENUMERATED_new(void)
{
  return ASN1_ENUMERATED_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_ENUMERATED_new(PyObject *self, PyObject *noarg)
{
  ASN1_ENUMERATED * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_ENUMERATED_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(980));
}
#else
#  define _cffi_f_ASN1_ENUMERATED_new _cffi_d_ASN1_ENUMERATED_new
#endif

static int _cffi_d_ASN1_ENUMERATED_set(ASN1_ENUMERATED * x0, long x1)
{
  return ASN1_ENUMERATED_set(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_ENUMERATED_set(PyObject *self, PyObject *args)
{
  ASN1_ENUMERATED * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_ENUMERATED_set", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(980), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_ENUMERATED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(980), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_ENUMERATED_set(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_ENUMERATED_set _cffi_d_ASN1_ENUMERATED_set
#endif

static int _cffi_d_ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME * x0)
{
  return ASN1_GENERALIZEDTIME_check(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_GENERALIZEDTIME_check(PyObject *self, PyObject *arg0)
{
  ASN1_GENERALIZEDTIME * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_GENERALIZEDTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(9), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_GENERALIZEDTIME_check(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_GENERALIZEDTIME_check _cffi_d_ASN1_GENERALIZEDTIME_check
#endif

static void _cffi_d_ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME * x0)
{
  ASN1_GENERALIZEDTIME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_GENERALIZEDTIME_free(PyObject *self, PyObject *arg0)
{
  ASN1_GENERALIZEDTIME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_GENERALIZEDTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(9), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_GENERALIZEDTIME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_GENERALIZEDTIME_free _cffi_d_ASN1_GENERALIZEDTIME_free
#endif

static ASN1_GENERALIZEDTIME * _cffi_d_ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME * x0, time_t x1)
{
  return ASN1_GENERALIZEDTIME_set(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_GENERALIZEDTIME_set(PyObject *self, PyObject *args)
{
  ASN1_GENERALIZEDTIME * x0;
  time_t x1;
  Py_ssize_t datasize;
  ASN1_GENERALIZEDTIME * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_GENERALIZEDTIME_set", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_GENERALIZEDTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(9), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, time_t);
  if (x1 == (time_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_GENERALIZEDTIME_set(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(9));
}
#else
#  define _cffi_f_ASN1_GENERALIZEDTIME_set _cffi_d_ASN1_GENERALIZEDTIME_set
#endif

static int _cffi_d_ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME * x0, char const * x1)
{
  return ASN1_GENERALIZEDTIME_set_string(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_GENERALIZEDTIME_set_string(PyObject *self, PyObject *args)
{
  ASN1_GENERALIZEDTIME * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_GENERALIZEDTIME_set_string", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_GENERALIZEDTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(9), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_GENERALIZEDTIME_set_string(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_GENERALIZEDTIME_set_string _cffi_d_ASN1_GENERALIZEDTIME_set_string
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_IA5STRING_new(void)
{
  return ASN1_IA5STRING_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_IA5STRING_new(PyObject *self, PyObject *noarg)
{
  ASN1_OCTET_STRING * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_IA5STRING_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_IA5STRING_new _cffi_d_ASN1_IA5STRING_new
#endif

static int _cffi_d_ASN1_INTEGER_cmp(ASN1_INTEGER * x0, ASN1_INTEGER * x1)
{
  return ASN1_INTEGER_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_cmp(PyObject *self, PyObject *args)
{
  ASN1_INTEGER * x0;
  ASN1_INTEGER * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_INTEGER_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(17), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_INTEGER_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_INTEGER_cmp _cffi_d_ASN1_INTEGER_cmp
#endif

static ASN1_INTEGER * _cffi_d_ASN1_INTEGER_dup(ASN1_INTEGER * x0)
{
  return ASN1_INTEGER_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_dup(PyObject *self, PyObject *arg0)
{
  ASN1_INTEGER * x0;
  Py_ssize_t datasize;
  ASN1_INTEGER * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_INTEGER_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(17));
}
#else
#  define _cffi_f_ASN1_INTEGER_dup _cffi_d_ASN1_INTEGER_dup
#endif

static void _cffi_d_ASN1_INTEGER_free(ASN1_INTEGER * x0)
{
  ASN1_INTEGER_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_free(PyObject *self, PyObject *arg0)
{
  ASN1_INTEGER * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_INTEGER_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_INTEGER_free _cffi_d_ASN1_INTEGER_free
#endif

static long _cffi_d_ASN1_INTEGER_get(ASN1_INTEGER * x0)
{
  return ASN1_INTEGER_get(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_get(PyObject *self, PyObject *arg0)
{
  ASN1_INTEGER * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_INTEGER_get(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_ASN1_INTEGER_get _cffi_d_ASN1_INTEGER_get
#endif

static ASN1_INTEGER * _cffi_d_ASN1_INTEGER_new(void)
{
  return ASN1_INTEGER_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_new(PyObject *self, PyObject *noarg)
{
  ASN1_INTEGER * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_INTEGER_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(17));
}
#else
#  define _cffi_f_ASN1_INTEGER_new _cffi_d_ASN1_INTEGER_new
#endif

static int _cffi_d_ASN1_INTEGER_set(ASN1_INTEGER * x0, long x1)
{
  return ASN1_INTEGER_set(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_set(PyObject *self, PyObject *args)
{
  ASN1_INTEGER * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_INTEGER_set", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_INTEGER_set(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_INTEGER_set _cffi_d_ASN1_INTEGER_set
#endif

static BIGNUM * _cffi_d_ASN1_INTEGER_to_BN(ASN1_INTEGER * x0, BIGNUM * x1)
{
  return ASN1_INTEGER_to_BN(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_INTEGER_to_BN(PyObject *self, PyObject *args)
{
  ASN1_INTEGER * x0;
  BIGNUM * x1;
  Py_ssize_t datasize;
  BIGNUM * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_INTEGER_to_BN", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_INTEGER_to_BN(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_ASN1_INTEGER_to_BN _cffi_d_ASN1_INTEGER_to_BN
#endif

static ASN1_ITEM const * _cffi_d_ASN1_ITEM_ptr(ASN1_ITEM_EXP * x0)
{
  return ASN1_ITEM_ptr(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_ITEM_ptr(PyObject *self, PyObject *arg0)
{
  ASN1_ITEM_EXP * x0;
  Py_ssize_t datasize;
  ASN1_ITEM const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_ITEM_EXP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(36), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_ITEM_ptr(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(114));
}
#else
#  define _cffi_f_ASN1_ITEM_ptr _cffi_d_ASN1_ITEM_ptr
#endif

static void _cffi_d_ASN1_OBJECT_free(ASN1_OBJECT * x0)
{
  ASN1_OBJECT_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OBJECT_free(PyObject *self, PyObject *arg0)
{
  ASN1_OBJECT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(811), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_OBJECT_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_OBJECT_free _cffi_d_ASN1_OBJECT_free
#endif

static ASN1_OBJECT * _cffi_d_ASN1_OBJECT_new(void)
{
  return ASN1_OBJECT_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OBJECT_new(PyObject *self, PyObject *noarg)
{
  ASN1_OBJECT * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_OBJECT_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_ASN1_OBJECT_new _cffi_d_ASN1_OBJECT_new
#endif

static int _cffi_d_ASN1_OCTET_STRING_cmp(ASN1_OCTET_STRING * x0, ASN1_OCTET_STRING * x1)
{
  return ASN1_OCTET_STRING_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OCTET_STRING_cmp(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_OCTET_STRING_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_OCTET_STRING_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_OCTET_STRING_cmp _cffi_d_ASN1_OCTET_STRING_cmp
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_OCTET_STRING_dup(ASN1_OCTET_STRING * x0)
{
  return ASN1_OCTET_STRING_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OCTET_STRING_dup(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_OCTET_STRING_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_OCTET_STRING_dup _cffi_d_ASN1_OCTET_STRING_dup
#endif

static void _cffi_d_ASN1_OCTET_STRING_free(ASN1_OCTET_STRING * x0)
{
  ASN1_OCTET_STRING_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OCTET_STRING_free(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_OCTET_STRING_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_OCTET_STRING_free _cffi_d_ASN1_OCTET_STRING_free
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_OCTET_STRING_new(void)
{
  return ASN1_OCTET_STRING_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OCTET_STRING_new(PyObject *self, PyObject *noarg)
{
  ASN1_OCTET_STRING * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_OCTET_STRING_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_OCTET_STRING_new _cffi_d_ASN1_OCTET_STRING_new
#endif

static int _cffi_d_ASN1_OCTET_STRING_set(ASN1_OCTET_STRING * x0, unsigned char const * x1, int x2)
{
  return ASN1_OCTET_STRING_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_OCTET_STRING_set(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  unsigned char const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ASN1_OCTET_STRING_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_OCTET_STRING_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_OCTET_STRING_set _cffi_d_ASN1_OCTET_STRING_set
#endif

static int _cffi_d_ASN1_STRING_cmp(ASN1_OCTET_STRING * x0, ASN1_OCTET_STRING * x1)
{
  return ASN1_STRING_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_cmp(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_STRING_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_STRING_cmp _cffi_d_ASN1_STRING_cmp
#endif

static unsigned char * _cffi_d_ASN1_STRING_data(ASN1_OCTET_STRING * x0)
{
  return ASN1_STRING_data(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_data(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;
  unsigned char * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_data(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(975));
}
#else
#  define _cffi_f_ASN1_STRING_data _cffi_d_ASN1_STRING_data
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_STRING_dup(ASN1_OCTET_STRING * x0)
{
  return ASN1_STRING_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_dup(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_STRING_dup _cffi_d_ASN1_STRING_dup
#endif

static void _cffi_d_ASN1_STRING_free(ASN1_OCTET_STRING * x0)
{
  ASN1_STRING_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_free(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_STRING_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_STRING_free _cffi_d_ASN1_STRING_free
#endif

static int _cffi_d_ASN1_STRING_length(ASN1_OCTET_STRING * x0)
{
  return ASN1_STRING_length(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_length(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_length(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_STRING_length _cffi_d_ASN1_STRING_length
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_STRING_new(void)
{
  return ASN1_STRING_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_new(PyObject *self, PyObject *noarg)
{
  ASN1_OCTET_STRING * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_STRING_new _cffi_d_ASN1_STRING_new
#endif

static int _cffi_d_ASN1_STRING_set(ASN1_OCTET_STRING * x0, void const * x1, int x2)
{
  return ASN1_STRING_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_set(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  void const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ASN1_STRING_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_STRING_set _cffi_d_ASN1_STRING_set
#endif

static int _cffi_d_ASN1_STRING_set_default_mask_asc(char * x0)
{
  return ASN1_STRING_set_default_mask_asc(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_set_default_mask_asc(PyObject *self, PyObject *arg0)
{
  char * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(594), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_set_default_mask_asc(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_STRING_set_default_mask_asc _cffi_d_ASN1_STRING_set_default_mask_asc
#endif

static int _cffi_d_ASN1_STRING_to_UTF8(unsigned char * * x0, ASN1_OCTET_STRING * x1)
{
  return ASN1_STRING_to_UTF8(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_to_UTF8(PyObject *self, PyObject *args)
{
  unsigned char * * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_STRING_to_UTF8", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(985), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_to_UTF8(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_STRING_to_UTF8 _cffi_d_ASN1_STRING_to_UTF8
#endif

static int _cffi_d_ASN1_STRING_type(ASN1_OCTET_STRING * x0)
{
  return ASN1_STRING_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_type(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_STRING_type _cffi_d_ASN1_STRING_type
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_STRING_type_new(int x0)
{
  return ASN1_STRING_type_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_STRING_type_new(PyObject *self, PyObject *arg0)
{
  int x0;
  ASN1_OCTET_STRING * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_STRING_type_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_STRING_type_new _cffi_d_ASN1_STRING_type_new
#endif

static int _cffi_d_ASN1_TIME_check(ASN1_OCTET_STRING * x0)
{
  return ASN1_TIME_check(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_check(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_TIME_check(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_TIME_check _cffi_d_ASN1_TIME_check
#endif

static void _cffi_d_ASN1_TIME_free(ASN1_OCTET_STRING * x0)
{
  ASN1_TIME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_free(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_TIME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_TIME_free _cffi_d_ASN1_TIME_free
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_TIME_new(void)
{
  return ASN1_TIME_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_new(PyObject *self, PyObject *noarg)
{
  ASN1_OCTET_STRING * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_TIME_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_TIME_new _cffi_d_ASN1_TIME_new
#endif

static int _cffi_d_ASN1_TIME_print(BIO * x0, ASN1_OCTET_STRING * x1)
{
  return ASN1_TIME_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_TIME_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_TIME_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_TIME_print _cffi_d_ASN1_TIME_print
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_TIME_set(ASN1_OCTET_STRING * x0, time_t x1)
{
  return ASN1_TIME_set(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_set(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  time_t x1;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_TIME_set", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, time_t);
  if (x1 == (time_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_TIME_set(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_TIME_set _cffi_d_ASN1_TIME_set
#endif

static int _cffi_d_ASN1_TIME_set_string(ASN1_OCTET_STRING * x0, char const * x1)
{
  return ASN1_TIME_set_string(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_set_string(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_TIME_set_string", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_TIME_set_string(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_TIME_set_string _cffi_d_ASN1_TIME_set_string
#endif

static ASN1_GENERALIZEDTIME * _cffi_d_ASN1_TIME_to_generalizedtime(ASN1_OCTET_STRING * x0, ASN1_GENERALIZEDTIME * * x1)
{
  return ASN1_TIME_to_generalizedtime(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_TIME_to_generalizedtime(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  ASN1_GENERALIZEDTIME * * x1;
  Py_ssize_t datasize;
  ASN1_GENERALIZEDTIME * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_TIME_to_generalizedtime", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(14), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_GENERALIZEDTIME * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(14), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_TIME_to_generalizedtime(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(9));
}
#else
#  define _cffi_f_ASN1_TIME_to_generalizedtime _cffi_d_ASN1_TIME_to_generalizedtime
#endif

static int _cffi_d_ASN1_UTCTIME_check(ASN1_UTCTIME * x0)
{
  return ASN1_UTCTIME_check(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTCTIME_check(PyObject *self, PyObject *arg0)
{
  ASN1_UTCTIME * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(105), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_UTCTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(105), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_UTCTIME_check(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_UTCTIME_check _cffi_d_ASN1_UTCTIME_check
#endif

static int _cffi_d_ASN1_UTCTIME_cmp_time_t(ASN1_UTCTIME const * x0, time_t x1)
{
  return ASN1_UTCTIME_cmp_time_t(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTCTIME_cmp_time_t(PyObject *self, PyObject *args)
{
  ASN1_UTCTIME const * x0;
  time_t x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_UTCTIME_cmp_time_t", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1063), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_UTCTIME const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1063), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, time_t);
  if (x1 == (time_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_UTCTIME_cmp_time_t(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_UTCTIME_cmp_time_t _cffi_d_ASN1_UTCTIME_cmp_time_t
#endif

static void _cffi_d_ASN1_UTCTIME_free(ASN1_UTCTIME * x0)
{
  ASN1_UTCTIME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTCTIME_free(PyObject *self, PyObject *arg0)
{
  ASN1_UTCTIME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(105), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_UTCTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(105), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_UTCTIME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_UTCTIME_free _cffi_d_ASN1_UTCTIME_free
#endif

static ASN1_UTCTIME * _cffi_d_ASN1_UTCTIME_new(void)
{
  return ASN1_UTCTIME_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTCTIME_new(PyObject *self, PyObject *noarg)
{
  ASN1_UTCTIME * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_UTCTIME_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(105));
}
#else
#  define _cffi_f_ASN1_UTCTIME_new _cffi_d_ASN1_UTCTIME_new
#endif

static int _cffi_d_ASN1_UTCTIME_print(BIO * x0, ASN1_UTCTIME * x1)
{
  return ASN1_UTCTIME_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTCTIME_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  ASN1_UTCTIME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_UTCTIME_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(105), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_UTCTIME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(105), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_UTCTIME_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ASN1_UTCTIME_print _cffi_d_ASN1_UTCTIME_print
#endif

static ASN1_UTCTIME * _cffi_d_ASN1_UTCTIME_set(ASN1_UTCTIME * x0, time_t x1)
{
  return ASN1_UTCTIME_set(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTCTIME_set(PyObject *self, PyObject *args)
{
  ASN1_UTCTIME * x0;
  time_t x1;
  Py_ssize_t datasize;
  ASN1_UTCTIME * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ASN1_UTCTIME_set", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(105), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_UTCTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(105), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, time_t);
  if (x1 == (time_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_UTCTIME_set(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(105));
}
#else
#  define _cffi_f_ASN1_UTCTIME_set _cffi_d_ASN1_UTCTIME_set
#endif

static void _cffi_d_ASN1_UTF8STRING_free(ASN1_OCTET_STRING * x0)
{
  ASN1_UTF8STRING_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTF8STRING_free(PyObject *self, PyObject *arg0)
{
  ASN1_OCTET_STRING * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ASN1_UTF8STRING_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ASN1_UTF8STRING_free _cffi_d_ASN1_UTF8STRING_free
#endif

static ASN1_OCTET_STRING * _cffi_d_ASN1_UTF8STRING_new(void)
{
  return ASN1_UTF8STRING_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_UTF8STRING_new(PyObject *self, PyObject *noarg)
{
  ASN1_OCTET_STRING * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_UTF8STRING_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_ASN1_UTF8STRING_new _cffi_d_ASN1_UTF8STRING_new
#endif

static ASN1_VALUE * _cffi_d_ASN1_item_d2i(ASN1_VALUE * * x0, unsigned char const * * x1, long x2, ASN1_ITEM const * x3)
{
  return ASN1_item_d2i(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ASN1_item_d2i(PyObject *self, PyObject *args)
{
  ASN1_VALUE * * x0;
  unsigned char const * * x1;
  long x2;
  ASN1_ITEM const * x3;
  Py_ssize_t datasize;
  ASN1_VALUE * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ASN1_item_d2i", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(111), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_VALUE * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(111), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(114), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (ASN1_ITEM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(114), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ASN1_item_d2i(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3645));
}
#else
#  define _cffi_f_ASN1_item_d2i _cffi_d_ASN1_item_d2i
#endif

static void _cffi_d_AUTHORITY_KEYID_free(AUTHORITY_KEYID * x0)
{
  AUTHORITY_KEYID_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_AUTHORITY_KEYID_free(PyObject *self, PyObject *arg0)
{
  AUTHORITY_KEYID * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (AUTHORITY_KEYID *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { AUTHORITY_KEYID_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_AUTHORITY_KEYID_free _cffi_d_AUTHORITY_KEYID_free
#endif

static AUTHORITY_KEYID * _cffi_d_AUTHORITY_KEYID_new(void)
{
  return AUTHORITY_KEYID_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_AUTHORITY_KEYID_new(PyObject *self, PyObject *noarg)
{
  AUTHORITY_KEYID * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = AUTHORITY_KEYID_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3155));
}
#else
#  define _cffi_f_AUTHORITY_KEYID_new _cffi_d_AUTHORITY_KEYID_new
#endif

static void _cffi_d_BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS * x0)
{
  BASIC_CONSTRAINTS_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BASIC_CONSTRAINTS_free(PyObject *self, PyObject *arg0)
{
  BASIC_CONSTRAINTS * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3158), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BASIC_CONSTRAINTS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3158), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BASIC_CONSTRAINTS_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BASIC_CONSTRAINTS_free _cffi_d_BASIC_CONSTRAINTS_free
#endif

static BASIC_CONSTRAINTS * _cffi_d_BASIC_CONSTRAINTS_new(void)
{
  return BASIC_CONSTRAINTS_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BASIC_CONSTRAINTS_new(PyObject *self, PyObject *noarg)
{
  BASIC_CONSTRAINTS * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BASIC_CONSTRAINTS_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3158));
}
#else
#  define _cffi_f_BASIC_CONSTRAINTS_new _cffi_d_BASIC_CONSTRAINTS_new
#endif

static long _cffi_d_BIO_append_filename(BIO * x0, char * x1)
{
  return BIO_append_filename(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_append_filename(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_append_filename", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_append_filename(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_append_filename _cffi_d_BIO_append_filename
#endif

static long _cffi_d_BIO_callback_ctrl(BIO * x0, int x1, void(* x2)(BIO *, int, char const *, int, long, long))
{
  return BIO_callback_ctrl(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_callback_ctrl(PyObject *self, PyObject *args)
{
  BIO * x0;
  int x1;
  void(* x2)(BIO *, int, char const *, int, long, long);
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_callback_ctrl", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = (void(*)(BIO *, int, char const *, int, long, long))_cffi_to_c_pointer(arg2, _cffi_type(1341));
  if (x2 == (void(*)(BIO *, int, char const *, int, long, long))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_callback_ctrl(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_callback_ctrl _cffi_d_BIO_callback_ctrl
#endif

static void _cffi_d_BIO_clear_retry_flags(BIO * x0)
{
  BIO_clear_retry_flags(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_clear_retry_flags(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BIO_clear_retry_flags(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BIO_clear_retry_flags _cffi_d_BIO_clear_retry_flags
#endif

static long _cffi_d_BIO_ctrl(BIO * x0, int x1, long x2, void * x3)
{
  return BIO_ctrl(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_ctrl(PyObject *self, PyObject *args)
{
  BIO * x0;
  int x1;
  long x2;
  void * x3;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BIO_ctrl", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_ctrl(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_ctrl _cffi_d_BIO_ctrl
#endif

static size_t _cffi_d_BIO_ctrl_pending(BIO * x0)
{
  return BIO_ctrl_pending(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_ctrl_pending(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  size_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_ctrl_pending(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_BIO_ctrl_pending _cffi_d_BIO_ctrl_pending
#endif

static size_t _cffi_d_BIO_ctrl_wpending(BIO * x0)
{
  return BIO_ctrl_wpending(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_ctrl_wpending(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  size_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_ctrl_wpending(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_BIO_ctrl_wpending _cffi_d_BIO_ctrl_wpending
#endif

static int _cffi_d_BIO_eof(BIO * x0)
{
  return BIO_eof(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_eof(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_eof(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_eof _cffi_d_BIO_eof
#endif

static BIO_METHOD * _cffi_d_BIO_f_buffer(void)
{
  return BIO_f_buffer();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_f_buffer(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_f_buffer(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_f_buffer _cffi_d_BIO_f_buffer
#endif

static BIO_METHOD * _cffi_d_BIO_f_null(void)
{
  return BIO_f_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_f_null(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_f_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_f_null _cffi_d_BIO_f_null
#endif

static BIO * _cffi_d_BIO_find_type(BIO * x0, int x1)
{
  return BIO_find_type(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_find_type(PyObject *self, PyObject *args)
{
  BIO * x0;
  int x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_find_type", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_find_type(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_find_type _cffi_d_BIO_find_type
#endif

static int _cffi_d_BIO_flush(BIO * x0)
{
  return BIO_flush(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_flush(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_flush(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_flush _cffi_d_BIO_flush
#endif

static int _cffi_d_BIO_free(BIO * x0)
{
  return BIO_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_free(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_free _cffi_d_BIO_free
#endif

static void _cffi_d_BIO_free_all(BIO * x0)
{
  BIO_free_all(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_free_all(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BIO_free_all(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BIO_free_all _cffi_d_BIO_free_all
#endif

static long _cffi_d_BIO_get_buffer_num_lines(BIO * x0)
{
  return BIO_get_buffer_num_lines(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_buffer_num_lines(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_buffer_num_lines(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_get_buffer_num_lines _cffi_d_BIO_get_buffer_num_lines
#endif

static int _cffi_d_BIO_get_close(BIO * x0)
{
  return BIO_get_close(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_close(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_close(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_get_close _cffi_d_BIO_get_close
#endif

static long _cffi_d_BIO_get_fd(BIO * x0, char * x1)
{
  return BIO_get_fd(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_fd(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_get_fd", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_fd(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_get_fd _cffi_d_BIO_get_fd
#endif

static long _cffi_d_BIO_get_fp(BIO * x0, FILE * * x1)
{
  return BIO_get_fp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_fp(PyObject *self, PyObject *args)
{
  BIO * x0;
  FILE * * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_get_fp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2861), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (FILE * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2861), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_fp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_get_fp _cffi_d_BIO_get_fp
#endif

static int _cffi_d_BIO_get_info_callback(BIO * x0, void(* * x1)(BIO *, int, char const *, int, long, long))
{
  return BIO_get_info_callback(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_info_callback(PyObject *self, PyObject *args)
{
  BIO * x0;
  void(* * x1)(BIO *, int, char const *, int, long, long);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_get_info_callback", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1337), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void(* *)(BIO *, int, char const *, int, long, long))alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1337), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_info_callback(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_get_info_callback _cffi_d_BIO_get_info_callback
#endif

static long _cffi_d_BIO_get_mem_data(BIO * x0, char * * x1)
{
  return BIO_get_mem_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_mem_data(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_get_mem_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2870), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2870), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_mem_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_get_mem_data _cffi_d_BIO_get_mem_data
#endif

static long _cffi_d_BIO_get_mem_ptr(BIO * x0, BUF_MEM * * x1)
{
  return BIO_get_mem_ptr(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_get_mem_ptr(PyObject *self, PyObject *args)
{
  BIO * x0;
  BUF_MEM * * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_get_mem_ptr", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2852), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BUF_MEM * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2852), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_get_mem_ptr(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_get_mem_ptr _cffi_d_BIO_get_mem_ptr
#endif

static int _cffi_d_BIO_gets(BIO * x0, char * x1, int x2)
{
  return BIO_gets(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_gets(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_gets", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_gets(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_gets _cffi_d_BIO_gets
#endif

static long _cffi_d_BIO_int_ctrl(BIO * x0, int x1, long x2, int x3)
{
  return BIO_int_ctrl(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_int_ctrl(PyObject *self, PyObject *args)
{
  BIO * x0;
  int x1;
  long x2;
  int x3;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BIO_int_ctrl", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_int_ctrl(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_int_ctrl _cffi_d_BIO_int_ctrl
#endif

static int _cffi_d_BIO_method_type(BIO const * x0)
{
  return BIO_method_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_method_type(PyObject *self, PyObject *arg0)
{
  BIO const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1344), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1344), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_method_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_method_type _cffi_d_BIO_method_type
#endif

static BIO * _cffi_d_BIO_new(BIO_METHOD * x0)
{
  return BIO_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new(PyObject *self, PyObject *arg0)
{
  BIO_METHOD * x0;
  Py_ssize_t datasize;
  BIO * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(175), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO_METHOD *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(175), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new _cffi_d_BIO_new
#endif

static BIO * _cffi_d_BIO_new_CMS(BIO * x0, CMS_ContentInfo * x1)
{
  return BIO_new_CMS(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new_CMS(PyObject *self, PyObject *args)
{
  BIO * x0;
  CMS_ContentInfo * x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_new_CMS", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(168), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new_CMS(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new_CMS _cffi_d_BIO_new_CMS
#endif

static BIO * _cffi_d_BIO_new_fd(int x0, int x1)
{
  return BIO_new_fd(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new_fd(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_new_fd", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new_fd(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new_fd _cffi_d_BIO_new_fd
#endif

static BIO * _cffi_d_BIO_new_file(char const * x0, char const * x1)
{
  return BIO_new_file(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new_file(PyObject *self, PyObject *args)
{
  char const * x0;
  char const * x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_new_file", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new_file(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new_file _cffi_d_BIO_new_file
#endif

static BIO * _cffi_d_BIO_new_fp(FILE * x0, int x1)
{
  return BIO_new_fp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new_fp(PyObject *self, PyObject *args)
{
  FILE * x0;
  int x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_new_fp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(178), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(178), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new_fp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new_fp _cffi_d_BIO_new_fp
#endif

static BIO * _cffi_d_BIO_new_mem_buf(void * x0, int x1)
{
  return BIO_new_mem_buf(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new_mem_buf(PyObject *self, PyObject *args)
{
  void * x0;
  int x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_new_mem_buf", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(92), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new_mem_buf(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new_mem_buf _cffi_d_BIO_new_mem_buf
#endif

static BIO * _cffi_d_BIO_new_socket(int x0, int x1)
{
  return BIO_new_socket(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_new_socket(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_new_socket", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_new_socket(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_new_socket _cffi_d_BIO_new_socket
#endif

static BIO * _cffi_d_BIO_next(BIO * x0)
{
  return BIO_next(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_next(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  BIO * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_next(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_next _cffi_d_BIO_next
#endif

static int _cffi_d_BIO_pending(BIO * x0)
{
  return BIO_pending(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_pending(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_pending(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_pending _cffi_d_BIO_pending
#endif

static BIO * _cffi_d_BIO_pop(BIO * x0)
{
  return BIO_pop(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_pop(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  BIO * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_pop(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_pop _cffi_d_BIO_pop
#endif

static BIO * _cffi_d_BIO_push(BIO * x0, BIO * x1)
{
  return BIO_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_push(PyObject *self, PyObject *args)
{
  BIO * x0;
  BIO * x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(160), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_BIO_push _cffi_d_BIO_push
#endif

static int _cffi_d_BIO_puts(BIO * x0, char const * x1)
{
  return BIO_puts(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_puts(PyObject *self, PyObject *args)
{
  BIO * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_puts", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_puts(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_puts _cffi_d_BIO_puts
#endif

static int _cffi_d_BIO_read(BIO * x0, void * x1, int x2)
{
  return BIO_read(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_read(PyObject *self, PyObject *args)
{
  BIO * x0;
  void * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_read", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_read(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_read _cffi_d_BIO_read
#endif

static long _cffi_d_BIO_read_filename(BIO * x0, char * x1)
{
  return BIO_read_filename(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_read_filename(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_read_filename", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_read_filename(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_read_filename _cffi_d_BIO_read_filename
#endif

static int _cffi_d_BIO_reset(BIO * x0)
{
  return BIO_reset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_reset(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_reset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_reset _cffi_d_BIO_reset
#endif

static int _cffi_d_BIO_retry_type(BIO * x0)
{
  return BIO_retry_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_retry_type(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_retry_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_retry_type _cffi_d_BIO_retry_type
#endif

static long _cffi_d_BIO_rw_filename(BIO * x0, char * x1)
{
  return BIO_rw_filename(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_rw_filename(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_rw_filename", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_rw_filename(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_rw_filename _cffi_d_BIO_rw_filename
#endif

static BIO_METHOD * _cffi_d_BIO_s_fd(void)
{
  return BIO_s_fd();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_s_fd(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_s_fd(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_s_fd _cffi_d_BIO_s_fd
#endif

static BIO_METHOD * _cffi_d_BIO_s_file(void)
{
  return BIO_s_file();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_s_file(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_s_file(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_s_file _cffi_d_BIO_s_file
#endif

static BIO_METHOD * _cffi_d_BIO_s_mem(void)
{
  return BIO_s_mem();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_s_mem(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_s_mem(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_s_mem _cffi_d_BIO_s_mem
#endif

static BIO_METHOD * _cffi_d_BIO_s_null(void)
{
  return BIO_s_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_s_null(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_s_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_s_null _cffi_d_BIO_s_null
#endif

static BIO_METHOD * _cffi_d_BIO_s_socket(void)
{
  return BIO_s_socket();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_s_socket(PyObject *self, PyObject *noarg)
{
  BIO_METHOD * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_s_socket(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_BIO_s_socket _cffi_d_BIO_s_socket
#endif

static int _cffi_d_BIO_seek(BIO * x0, int x1)
{
  return BIO_seek(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_seek(PyObject *self, PyObject *args)
{
  BIO * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_seek", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_seek(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_seek _cffi_d_BIO_seek
#endif

static long _cffi_d_BIO_set_buffer_read_data(BIO * x0, void * x1, long x2)
{
  return BIO_set_buffer_read_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_buffer_read_data(PyObject *self, PyObject *args)
{
  BIO * x0;
  void * x1;
  long x2;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_set_buffer_read_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_buffer_read_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_buffer_read_data _cffi_d_BIO_set_buffer_read_data
#endif

static long _cffi_d_BIO_set_buffer_size(BIO * x0, long x1)
{
  return BIO_set_buffer_size(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_buffer_size(PyObject *self, PyObject *args)
{
  BIO * x0;
  long x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_buffer_size", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_buffer_size(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_buffer_size _cffi_d_BIO_set_buffer_size
#endif

static int _cffi_d_BIO_set_close(BIO * x0, long x1)
{
  return BIO_set_close(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_close(PyObject *self, PyObject *args)
{
  BIO * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_close", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_close(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_set_close _cffi_d_BIO_set_close
#endif

static long _cffi_d_BIO_set_fd(BIO * x0, long x1, int x2)
{
  return BIO_set_fd(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_fd(PyObject *self, PyObject *args)
{
  BIO * x0;
  long x1;
  int x2;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_set_fd", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_fd(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_fd _cffi_d_BIO_set_fd
#endif

static long _cffi_d_BIO_set_fp(BIO * x0, FILE * x1, int x2)
{
  return BIO_set_fp(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_fp(PyObject *self, PyObject *args)
{
  BIO * x0;
  FILE * x1;
  int x2;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_set_fp", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(178), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (FILE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(178), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_fp(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_fp _cffi_d_BIO_set_fp
#endif

static int _cffi_d_BIO_set_info_callback(BIO * x0, void(* x1)(BIO *, int, char const *, int, long, long))
{
  return BIO_set_info_callback(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_info_callback(PyObject *self, PyObject *args)
{
  BIO * x0;
  void(* x1)(BIO *, int, char const *, int, long, long);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_info_callback", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = (void(*)(BIO *, int, char const *, int, long, long))_cffi_to_c_pointer(arg1, _cffi_type(1341));
  if (x1 == (void(*)(BIO *, int, char const *, int, long, long))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_info_callback(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_set_info_callback _cffi_d_BIO_set_info_callback
#endif

static long _cffi_d_BIO_set_mem_buf(BIO * x0, BUF_MEM * x1, int x2)
{
  return BIO_set_mem_buf(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_mem_buf(PyObject *self, PyObject *args)
{
  BIO * x0;
  BUF_MEM * x1;
  int x2;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_set_mem_buf", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2856), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BUF_MEM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2856), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_mem_buf(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_mem_buf _cffi_d_BIO_set_mem_buf
#endif

static long _cffi_d_BIO_set_mem_eof_return(BIO * x0, int x1)
{
  return BIO_set_mem_eof_return(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_mem_eof_return(PyObject *self, PyObject *args)
{
  BIO * x0;
  int x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_mem_eof_return", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_mem_eof_return(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_mem_eof_return _cffi_d_BIO_set_mem_eof_return
#endif

static long _cffi_d_BIO_set_nbio(BIO * x0, long x1)
{
  return BIO_set_nbio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_nbio(PyObject *self, PyObject *args)
{
  BIO * x0;
  long x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_nbio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_nbio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_nbio _cffi_d_BIO_set_nbio
#endif

static long _cffi_d_BIO_set_read_buffer_size(BIO * x0, long x1)
{
  return BIO_set_read_buffer_size(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_read_buffer_size(PyObject *self, PyObject *args)
{
  BIO * x0;
  long x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_read_buffer_size", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_read_buffer_size(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_read_buffer_size _cffi_d_BIO_set_read_buffer_size
#endif

static void _cffi_d_BIO_set_retry_read(BIO * x0)
{
  BIO_set_retry_read(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_retry_read(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BIO_set_retry_read(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BIO_set_retry_read _cffi_d_BIO_set_retry_read
#endif

static long _cffi_d_BIO_set_write_buffer_size(BIO * x0, long x1)
{
  return BIO_set_write_buffer_size(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_set_write_buffer_size(PyObject *self, PyObject *args)
{
  BIO * x0;
  long x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_set_write_buffer_size", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_set_write_buffer_size(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_set_write_buffer_size _cffi_d_BIO_set_write_buffer_size
#endif

static int _cffi_d_BIO_should_io_special(BIO * x0)
{
  return BIO_should_io_special(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_should_io_special(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_should_io_special(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_should_io_special _cffi_d_BIO_should_io_special
#endif

static int _cffi_d_BIO_should_read(BIO * x0)
{
  return BIO_should_read(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_should_read(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_should_read(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_should_read _cffi_d_BIO_should_read
#endif

static int _cffi_d_BIO_should_retry(BIO * x0)
{
  return BIO_should_retry(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_should_retry(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_should_retry(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_should_retry _cffi_d_BIO_should_retry
#endif

static int _cffi_d_BIO_should_write(BIO * x0)
{
  return BIO_should_write(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_should_write(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_should_write(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_should_write _cffi_d_BIO_should_write
#endif

static int _cffi_d_BIO_tell(BIO * x0)
{
  return BIO_tell(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_tell(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_tell(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_tell _cffi_d_BIO_tell
#endif

static int _cffi_d_BIO_up_ref(BIO * x0)
{
  return BIO_up_ref(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_up_ref(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_up_ref(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_up_ref _cffi_d_BIO_up_ref
#endif

static void _cffi_d_BIO_vfree(BIO * x0)
{
  BIO_vfree(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_vfree(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BIO_vfree(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BIO_vfree _cffi_d_BIO_vfree
#endif

static int _cffi_d_BIO_wpending(BIO * x0)
{
  return BIO_wpending(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_wpending(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_wpending(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_wpending _cffi_d_BIO_wpending
#endif

static int _cffi_d_BIO_write(BIO * x0, void const * x1, int x2)
{
  return BIO_write(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_write(PyObject *self, PyObject *args)
{
  BIO * x0;
  void const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BIO_write", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_write(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BIO_write _cffi_d_BIO_write
#endif

static long _cffi_d_BIO_write_filename(BIO * x0, char * x1)
{
  return BIO_write_filename(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BIO_write_filename(PyObject *self, PyObject *args)
{
  BIO * x0;
  char * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BIO_write_filename", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BIO_write_filename(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_BIO_write_filename _cffi_d_BIO_write_filename
#endif

static void _cffi_d_BN_CTX_end(BN_CTX * x0)
{
  BN_CTX_end(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_CTX_end(PyObject *self, PyObject *arg0)
{
  BN_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(132), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BN_CTX_end(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BN_CTX_end _cffi_d_BN_CTX_end
#endif

static void _cffi_d_BN_CTX_free(BN_CTX * x0)
{
  BN_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_CTX_free(PyObject *self, PyObject *arg0)
{
  BN_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(132), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BN_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BN_CTX_free _cffi_d_BN_CTX_free
#endif

static BIGNUM * _cffi_d_BN_CTX_get(BN_CTX * x0)
{
  return BN_CTX_get(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_CTX_get(PyObject *self, PyObject *arg0)
{
  BN_CTX * x0;
  Py_ssize_t datasize;
  BIGNUM * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(132), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_CTX_get(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_BN_CTX_get _cffi_d_BN_CTX_get
#endif

static BN_CTX * _cffi_d_BN_CTX_new(void)
{
  return BN_CTX_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_CTX_new(PyObject *self, PyObject *noarg)
{
  BN_CTX * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_CTX_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(132));
}
#else
#  define _cffi_f_BN_CTX_new _cffi_d_BN_CTX_new
#endif

static void _cffi_d_BN_CTX_start(BN_CTX * x0)
{
  BN_CTX_start(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_CTX_start(PyObject *self, PyObject *arg0)
{
  BN_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(132), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BN_CTX_start(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BN_CTX_start _cffi_d_BN_CTX_start
#endif

static int _cffi_d_BN_add(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2)
{
  return BN_add(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_add(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BN_add", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_add(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_add _cffi_d_BN_add
#endif

static BIGNUM * _cffi_d_BN_bin2bn(unsigned char const * x0, int x1, BIGNUM * x2)
{
  return BN_bin2bn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_bin2bn(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  int x1;
  BIGNUM * x2;
  Py_ssize_t datasize;
  BIGNUM * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BN_bin2bn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(148), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_bin2bn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_BN_bin2bn _cffi_d_BN_bin2bn
#endif

static int _cffi_d_BN_bn2bin(BIGNUM const * x0, unsigned char * x1)
{
  return BN_bn2bin(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_bn2bin(PyObject *self, PyObject *args)
{
  BIGNUM const * x0;
  unsigned char * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_bn2bin", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_bn2bin(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_bn2bin _cffi_d_BN_bn2bin
#endif

static char * _cffi_d_BN_bn2hex(BIGNUM const * x0)
{
  return BN_bn2hex(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_bn2hex(PyObject *self, PyObject *arg0)
{
  BIGNUM const * x0;
  Py_ssize_t datasize;
  char * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_bn2hex(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_BN_bn2hex _cffi_d_BN_bn2hex
#endif

static int _cffi_d_BN_clear_bit(BIGNUM * x0, int x1)
{
  return BN_clear_bit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_clear_bit(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_clear_bit", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_clear_bit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_clear_bit _cffi_d_BN_clear_bit
#endif

static int _cffi_d_BN_cmp(BIGNUM const * x0, BIGNUM const * x1)
{
  return BN_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_cmp(PyObject *self, PyObject *args)
{
  BIGNUM const * x0;
  BIGNUM const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_cmp _cffi_d_BN_cmp
#endif

static BIGNUM * _cffi_d_BN_copy(BIGNUM * x0, BIGNUM const * x1)
{
  return BN_copy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_copy(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  Py_ssize_t datasize;
  BIGNUM * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_copy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_copy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_BN_copy _cffi_d_BN_copy
#endif

static int _cffi_d_BN_dec2bn(BIGNUM * * x0, char const * x1)
{
  return BN_dec2bn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_dec2bn(PyObject *self, PyObject *args)
{
  BIGNUM * * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_dec2bn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1067), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1067), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_dec2bn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_dec2bn _cffi_d_BN_dec2bn
#endif

static int _cffi_d_BN_div(BIGNUM * x0, BIGNUM * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return BN_div(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_div(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "BN_div", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_div(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_div _cffi_d_BN_div
#endif

static BIGNUM * _cffi_d_BN_dup(BIGNUM const * x0)
{
  return BN_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_dup(PyObject *self, PyObject *arg0)
{
  BIGNUM const * x0;
  Py_ssize_t datasize;
  BIGNUM * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_BN_dup _cffi_d_BN_dup
#endif

static int _cffi_d_BN_exp(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_exp(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_exp(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_exp", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_exp(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_exp _cffi_d_BN_exp
#endif

static void _cffi_d_BN_free(BIGNUM * x0)
{
  BN_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_free(PyObject *self, PyObject *arg0)
{
  BIGNUM * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BN_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BN_free _cffi_d_BN_free
#endif

static int _cffi_d_BN_gcd(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_gcd(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_gcd(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_gcd", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_gcd(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_gcd _cffi_d_BN_gcd
#endif

static BN_ULONG _cffi_d_BN_get_word(BIGNUM const * x0)
{
  return BN_get_word(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_get_word(PyObject *self, PyObject *arg0)
{
  BIGNUM const * x0;
  Py_ssize_t datasize;
  BN_ULONG result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_get_word(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, BN_ULONG);
}
#else
#  define _cffi_f_BN_get_word _cffi_d_BN_get_word
#endif

static int _cffi_d_BN_hex2bn(BIGNUM * * x0, char const * x1)
{
  return BN_hex2bn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_hex2bn(PyObject *self, PyObject *args)
{
  BIGNUM * * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_hex2bn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1067), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1067), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_hex2bn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_hex2bn _cffi_d_BN_hex2bn
#endif

static int _cffi_d_BN_is_bit_set(BIGNUM const * x0, int x1)
{
  return BN_is_bit_set(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_is_bit_set(PyObject *self, PyObject *args)
{
  BIGNUM const * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_is_bit_set", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_is_bit_set(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_is_bit_set _cffi_d_BN_is_bit_set
#endif

static int _cffi_d_BN_lshift(BIGNUM * x0, BIGNUM const * x1, int x2)
{
  return BN_lshift(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_lshift(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BN_lshift", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_lshift(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_lshift _cffi_d_BN_lshift
#endif

static int _cffi_d_BN_lshift1(BIGNUM * x0, BIGNUM * x1)
{
  return BN_lshift1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_lshift1(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_lshift1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_lshift1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_lshift1 _cffi_d_BN_lshift1
#endif

static int _cffi_d_BN_mask_bits(BIGNUM * x0, int x1)
{
  return BN_mask_bits(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mask_bits(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_mask_bits", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mask_bits(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mask_bits _cffi_d_BN_mask_bits
#endif

static int _cffi_d_BN_mod(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_mod(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_mod", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mod _cffi_d_BN_mod
#endif

static int _cffi_d_BN_mod_add(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return BN_mod_add(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod_add(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "BN_mod_add", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod_add(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mod_add _cffi_d_BN_mod_add
#endif

static int _cffi_d_BN_mod_exp(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return BN_mod_exp(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod_exp(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "BN_mod_exp", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod_exp(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mod_exp _cffi_d_BN_mod_exp
#endif

static BIGNUM * _cffi_d_BN_mod_inverse(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_mod_inverse(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod_inverse(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  BIGNUM * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_mod_inverse", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod_inverse(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_BN_mod_inverse _cffi_d_BN_mod_inverse
#endif

static int _cffi_d_BN_mod_mul(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return BN_mod_mul(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod_mul(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "BN_mod_mul", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod_mul(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mod_mul _cffi_d_BN_mod_mul
#endif

static int _cffi_d_BN_mod_sqr(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_mod_sqr(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod_sqr(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_mod_sqr", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod_sqr(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mod_sqr _cffi_d_BN_mod_sqr
#endif

static int _cffi_d_BN_mod_sub(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return BN_mod_sub(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mod_sub(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "BN_mod_sub", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mod_sub(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mod_sub _cffi_d_BN_mod_sub
#endif

static int _cffi_d_BN_mul(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_mul(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_mul(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_mul", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_mul(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_mul _cffi_d_BN_mul
#endif

static BIGNUM * _cffi_d_BN_new(void)
{
  return BN_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_new(PyObject *self, PyObject *noarg)
{
  BIGNUM * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_BN_new _cffi_d_BN_new
#endif

static int _cffi_d_BN_nnmod(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return BN_nnmod(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_nnmod(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "BN_nnmod", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_nnmod(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_nnmod _cffi_d_BN_nnmod
#endif

static int _cffi_d_BN_num_bits(BIGNUM const * x0)
{
  return BN_num_bits(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_num_bits(PyObject *self, PyObject *arg0)
{
  BIGNUM const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_num_bits(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_num_bits _cffi_d_BN_num_bits
#endif

static int _cffi_d_BN_num_bytes(BIGNUM const * x0)
{
  return BN_num_bytes(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_num_bytes(PyObject *self, PyObject *arg0)
{
  BIGNUM const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_num_bytes(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_num_bytes _cffi_d_BN_num_bytes
#endif

static int _cffi_d_BN_one(BIGNUM * x0)
{
  return BN_one(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_one(PyObject *self, PyObject *arg0)
{
  BIGNUM * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_one(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_one _cffi_d_BN_one
#endif

static int _cffi_d_BN_rshift(BIGNUM * x0, BIGNUM * x1, int x2)
{
  return BN_rshift(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_rshift(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BN_rshift", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_rshift(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_rshift _cffi_d_BN_rshift
#endif

static int _cffi_d_BN_rshift1(BIGNUM * x0, BIGNUM * x1)
{
  return BN_rshift1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_rshift1(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_rshift1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_rshift1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_rshift1 _cffi_d_BN_rshift1
#endif

static int _cffi_d_BN_set_bit(BIGNUM * x0, int x1)
{
  return BN_set_bit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_set_bit(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_set_bit", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_set_bit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_set_bit _cffi_d_BN_set_bit
#endif

static int _cffi_d_BN_set_word(BIGNUM * x0, BN_ULONG x1)
{
  return BN_set_word(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_set_word(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BN_ULONG x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_set_word", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, BN_ULONG);
  if (x1 == (BN_ULONG)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_set_word(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_set_word _cffi_d_BN_set_word
#endif

static int _cffi_d_BN_sqr(BIGNUM * x0, BIGNUM const * x1, BN_CTX * x2)
{
  return BN_sqr(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_sqr(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BN_CTX * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BN_sqr", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(132), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_sqr(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_sqr _cffi_d_BN_sqr
#endif

static int _cffi_d_BN_sub(BIGNUM * x0, BIGNUM const * x1, BIGNUM const * x2)
{
  return BN_sub(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_sub(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BN_sub", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_sub(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_sub _cffi_d_BN_sub
#endif

static ASN1_INTEGER * _cffi_d_BN_to_ASN1_INTEGER(BIGNUM * x0, ASN1_INTEGER * x1)
{
  return BN_to_ASN1_INTEGER(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_to_ASN1_INTEGER(PyObject *self, PyObject *args)
{
  BIGNUM * x0;
  ASN1_INTEGER * x1;
  Py_ssize_t datasize;
  ASN1_INTEGER * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BN_to_ASN1_INTEGER", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(17), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_to_ASN1_INTEGER(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(17));
}
#else
#  define _cffi_f_BN_to_ASN1_INTEGER _cffi_d_BN_to_ASN1_INTEGER
#endif

static BIGNUM const * _cffi_d_BN_value_one(void)
{
  return BN_value_one();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_value_one(PyObject *self, PyObject *noarg)
{
  BIGNUM const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_value_one(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(126));
}
#else
#  define _cffi_f_BN_value_one _cffi_d_BN_value_one
#endif

static int _cffi_d_BN_zero(BIGNUM * x0)
{
  return BN_zero(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BN_zero(PyObject *self, PyObject *arg0)
{
  BIGNUM * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BN_zero(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_BN_zero _cffi_d_BN_zero
#endif

static void _cffi_d_CERTIFICATEPOLICIES_free(Cryptography_STACK_OF_POLICYINFO * x0)
{
  CERTIFICATEPOLICIES_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CERTIFICATEPOLICIES_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_POLICYINFO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(637), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(637), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CERTIFICATEPOLICIES_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CERTIFICATEPOLICIES_free _cffi_d_CERTIFICATEPOLICIES_free
#endif

static int _cffi_d_CMAC_CTX_copy(CMAC_CTX * x0, CMAC_CTX const * x1)
{
  return CMAC_CTX_copy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMAC_CTX_copy(PyObject *self, PyObject *args)
{
  CMAC_CTX * x0;
  CMAC_CTX const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CMAC_CTX_copy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1347), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1347), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1348), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (CMAC_CTX const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1348), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMAC_CTX_copy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMAC_CTX_copy _cffi_d_CMAC_CTX_copy
#endif

static void _cffi_d_CMAC_CTX_free(CMAC_CTX * x0)
{
  CMAC_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMAC_CTX_free(PyObject *self, PyObject *arg0)
{
  CMAC_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1347), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1347), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CMAC_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CMAC_CTX_free _cffi_d_CMAC_CTX_free
#endif

static CMAC_CTX * _cffi_d_CMAC_CTX_new(void)
{
  return CMAC_CTX_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMAC_CTX_new(PyObject *self, PyObject *noarg)
{
  CMAC_CTX * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMAC_CTX_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1347));
}
#else
#  define _cffi_f_CMAC_CTX_new _cffi_d_CMAC_CTX_new
#endif

static int _cffi_d_CMAC_Final(CMAC_CTX * x0, unsigned char * x1, size_t * x2)
{
  return CMAC_Final(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMAC_Final(PyObject *self, PyObject *args)
{
  CMAC_CTX * x0;
  unsigned char * x1;
  size_t * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "CMAC_Final", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1347), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1347), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1353), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (size_t *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1353), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMAC_Final(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMAC_Final _cffi_d_CMAC_Final
#endif

static int _cffi_d_CMAC_Init(CMAC_CTX * x0, void const * x1, size_t x2, EVP_CIPHER const * x3, ENGINE * x4)
{
  return CMAC_Init(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMAC_Init(PyObject *self, PyObject *args)
{
  CMAC_CTX * x0;
  void const * x1;
  size_t x2;
  EVP_CIPHER const * x3;
  ENGINE * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "CMAC_Init", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1347), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1347), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(212), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(435), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMAC_Init(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMAC_Init _cffi_d_CMAC_Init
#endif

static int _cffi_d_CMAC_Update(CMAC_CTX * x0, void const * x1, size_t x2)
{
  return CMAC_Update(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMAC_Update(PyObject *self, PyObject *args)
{
  CMAC_CTX * x0;
  void const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "CMAC_Update", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1347), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1347), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMAC_Update(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMAC_Update _cffi_d_CMAC_Update
#endif

static CMS_SignerInfo * _cffi_d_CMS_add1_signer(CMS_ContentInfo * x0, X509 * x1, EVP_PKEY * x2, EVP_MD const * x3, unsigned int x4)
{
  return CMS_add1_signer(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMS_add1_signer(PyObject *self, PyObject *args)
{
  CMS_ContentInfo * x0;
  X509 * x1;
  EVP_PKEY * x2;
  EVP_MD const * x3;
  unsigned int x4;
  Py_ssize_t datasize;
  CMS_SignerInfo * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "CMS_add1_signer", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(168), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(217), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(226), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, unsigned int);
  if (x4 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMS_add1_signer(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3662));
}
#else
#  define _cffi_f_CMS_add1_signer _cffi_d_CMS_add1_signer
#endif

static int _cffi_d_CMS_decrypt(CMS_ContentInfo * x0, EVP_PKEY * x1, X509 * x2, BIO * x3, BIO * x4, unsigned int x5)
{
  return CMS_decrypt(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMS_decrypt(PyObject *self, PyObject *args)
{
  CMS_ContentInfo * x0;
  EVP_PKEY * x1;
  X509 * x2;
  BIO * x3;
  BIO * x4;
  unsigned int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "CMS_decrypt", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(168), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(28), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIO *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(160), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BIO *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(160), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, unsigned int);
  if (x5 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMS_decrypt(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMS_decrypt _cffi_d_CMS_decrypt
#endif

static CMS_ContentInfo * _cffi_d_CMS_encrypt(Cryptography_STACK_OF_X509 * x0, BIO * x1, EVP_CIPHER const * x2, unsigned int x3)
{
  return CMS_encrypt(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMS_encrypt(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509 * x0;
  BIO * x1;
  EVP_CIPHER const * x2;
  unsigned int x3;
  Py_ssize_t datasize;
  CMS_ContentInfo * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "CMS_encrypt", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(160), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, unsigned int);
  if (x3 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMS_encrypt(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(168));
}
#else
#  define _cffi_f_CMS_encrypt _cffi_d_CMS_encrypt
#endif

static int _cffi_d_CMS_final(CMS_ContentInfo * x0, BIO * x1, BIO * x2, unsigned int x3)
{
  return CMS_final(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMS_final(PyObject *self, PyObject *args)
{
  CMS_ContentInfo * x0;
  BIO * x1;
  BIO * x2;
  unsigned int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "CMS_final", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(168), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(160), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIO *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(160), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, unsigned int);
  if (x3 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMS_final(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMS_final _cffi_d_CMS_final
#endif

static CMS_ContentInfo * _cffi_d_CMS_sign(X509 * x0, EVP_PKEY * x1, Cryptography_STACK_OF_X509 * x2, BIO * x3, unsigned int x4)
{
  return CMS_sign(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMS_sign(PyObject *self, PyObject *args)
{
  X509 * x0;
  EVP_PKEY * x1;
  Cryptography_STACK_OF_X509 * x2;
  BIO * x3;
  unsigned int x4;
  Py_ssize_t datasize;
  CMS_ContentInfo * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "CMS_sign", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(210), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIO *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(160), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, unsigned int);
  if (x4 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMS_sign(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(168));
}
#else
#  define _cffi_f_CMS_sign _cffi_d_CMS_sign
#endif

static int _cffi_d_CMS_verify(CMS_ContentInfo * x0, Cryptography_STACK_OF_X509 * x1, X509_STORE * x2, BIO * x3, BIO * x4, unsigned int x5)
{
  return CMS_verify(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CMS_verify(PyObject *self, PyObject *args)
{
  CMS_ContentInfo * x0;
  Cryptography_STACK_OF_X509 * x1;
  X509_STORE * x2;
  BIO * x3;
  BIO * x4;
  unsigned int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "CMS_verify", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(168), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(210), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(278), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIO *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(160), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BIO *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(160), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, unsigned int);
  if (x5 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CMS_verify(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CMS_verify _cffi_d_CMS_verify
#endif

static void _cffi_d_CRL_DIST_POINTS_free(Cryptography_STACK_OF_DIST_POINT * x0)
{
  CRL_DIST_POINTS_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRL_DIST_POINTS_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_DIST_POINT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(310), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(310), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CRL_DIST_POINTS_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CRL_DIST_POINTS_free _cffi_d_CRL_DIST_POINTS_free
#endif

static void _cffi_d_CRYPTO_cleanup_all_ex_data(void)
{
  CRYPTO_cleanup_all_ex_data();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRYPTO_cleanup_all_ex_data(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CRYPTO_cleanup_all_ex_data(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CRYPTO_cleanup_all_ex_data _cffi_d_CRYPTO_cleanup_all_ex_data
#endif

static void(* _cffi_d_CRYPTO_get_locking_callback(void))(int, int, char const *, int)
{
  return CRYPTO_get_locking_callback();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRYPTO_get_locking_callback(PyObject *self, PyObject *noarg)
{
  void(* result)(int, int, char const *, int);

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CRYPTO_get_locking_callback(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3620));
}
#else
#  define _cffi_f_CRYPTO_get_locking_callback _cffi_d_CRYPTO_get_locking_callback
#endif

static void _cffi_d_CRYPTO_lock(int x0, int x1, char const * x2, int x3)
{
  CRYPTO_lock(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRYPTO_lock(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  char const * x2;
  int x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "CRYPTO_lock", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(57), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CRYPTO_lock(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CRYPTO_lock _cffi_d_CRYPTO_lock
#endif

static int _cffi_d_CRYPTO_mem_ctrl(int x0)
{
  return CRYPTO_mem_ctrl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRYPTO_mem_ctrl(PyObject *self, PyObject *arg0)
{
  int x0;
  int result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CRYPTO_mem_ctrl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CRYPTO_mem_ctrl _cffi_d_CRYPTO_mem_ctrl
#endif

static int _cffi_d_CRYPTO_num_locks(void)
{
  return CRYPTO_num_locks();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRYPTO_num_locks(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CRYPTO_num_locks(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_CRYPTO_num_locks _cffi_d_CRYPTO_num_locks
#endif

static void _cffi_d_CRYPTO_set_locking_callback(void(* x0)(int, int, char const *, int))
{
  CRYPTO_set_locking_callback(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CRYPTO_set_locking_callback(PyObject *self, PyObject *arg0)
{
  void(* x0)(int, int, char const *, int);

  x0 = (void(*)(int, int, char const *, int))_cffi_to_c_pointer(arg0, _cffi_type(3620));
  if (x0 == (void(*)(int, int, char const *, int))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CRYPTO_set_locking_callback(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CRYPTO_set_locking_callback _cffi_d_CRYPTO_set_locking_callback
#endif

static int _cffi_d_Cryptography_CRYPTO_set_mem_functions(void *(* x0)(size_t, char const *, int), void *(* x1)(void *, size_t, char const *, int), void(* x2)(void *, char const *, int))
{
  return Cryptography_CRYPTO_set_mem_functions(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_CRYPTO_set_mem_functions(PyObject *self, PyObject *args)
{
  void *(* x0)(size_t, char const *, int);
  void *(* x1)(void *, size_t, char const *, int);
  void(* x2)(void *, char const *, int);
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "Cryptography_CRYPTO_set_mem_functions", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = (void *(*)(size_t, char const *, int))_cffi_to_c_pointer(arg0, _cffi_type(2819));
  if (x0 == (void *(*)(size_t, char const *, int))NULL && PyErr_Occurred())
    return NULL;

  x1 = (void *(*)(void *, size_t, char const *, int))_cffi_to_c_pointer(arg1, _cffi_type(2820));
  if (x1 == (void *(*)(void *, size_t, char const *, int))NULL && PyErr_Occurred())
    return NULL;

  x2 = (void(*)(void *, char const *, int))_cffi_to_c_pointer(arg2, _cffi_type(2821));
  if (x2 == (void(*)(void *, char const *, int))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_CRYPTO_set_mem_functions(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_CRYPTO_set_mem_functions _cffi_d_Cryptography_CRYPTO_set_mem_functions
#endif

static int _cffi_d_Cryptography_DH_check(DH const * x0, int * x1)
{
  return Cryptography_DH_check(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_DH_check(PyObject *self, PyObject *args)
{
  DH const * x0;
  int * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "Cryptography_DH_check", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1167), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_DH_check(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_DH_check _cffi_d_Cryptography_DH_check
#endif

static long _cffi_d_Cryptography_DTLSv1_get_timeout(SSL * x0, time_t * x1, long * x2)
{
  return Cryptography_DTLSv1_get_timeout(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_DTLSv1_get_timeout(PyObject *self, PyObject *args)
{
  SSL * x0;
  time_t * x1;
  long * x2;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "Cryptography_DTLSv1_get_timeout", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2924), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (time_t *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2924), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2925), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (long *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(2925), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_DTLSv1_get_timeout(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_Cryptography_DTLSv1_get_timeout _cffi_d_Cryptography_DTLSv1_get_timeout
#endif

static void _cffi_d_Cryptography_EVP_MD_CTX_free(EVP_MD_CTX * x0)
{
  Cryptography_EVP_MD_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_EVP_MD_CTX_free(PyObject *self, PyObject *arg0)
{
  EVP_MD_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { Cryptography_EVP_MD_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_Cryptography_EVP_MD_CTX_free _cffi_d_Cryptography_EVP_MD_CTX_free
#endif

static EVP_MD_CTX * _cffi_d_Cryptography_EVP_MD_CTX_new(void)
{
  return Cryptography_EVP_MD_CTX_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_EVP_MD_CTX_new(PyObject *self, PyObject *noarg)
{
  EVP_MD_CTX * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_EVP_MD_CTX_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1856));
}
#else
#  define _cffi_f_Cryptography_EVP_MD_CTX_new _cffi_d_Cryptography_EVP_MD_CTX_new
#endif

static int _cffi_d_Cryptography_EVP_PKEY_id(EVP_PKEY const * x0)
{
  return Cryptography_EVP_PKEY_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_EVP_PKEY_id(PyObject *self, PyObject *arg0)
{
  EVP_PKEY const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(758), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_EVP_PKEY_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_EVP_PKEY_id _cffi_d_Cryptography_EVP_PKEY_id
#endif

static void _cffi_d_Cryptography_HMAC_CTX_free(HMAC_CTX * x0)
{
  Cryptography_HMAC_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_HMAC_CTX_free(PyObject *self, PyObject *arg0)
{
  HMAC_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1994), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (HMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1994), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { Cryptography_HMAC_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_Cryptography_HMAC_CTX_free _cffi_d_Cryptography_HMAC_CTX_free
#endif

static HMAC_CTX * _cffi_d_Cryptography_HMAC_CTX_new(void)
{
  return Cryptography_HMAC_CTX_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_HMAC_CTX_new(PyObject *self, PyObject *noarg)
{
  HMAC_CTX * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_HMAC_CTX_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1994));
}
#else
#  define _cffi_f_Cryptography_HMAC_CTX_new _cffi_d_Cryptography_HMAC_CTX_new
#endif

static int _cffi_d_Cryptography_X509_NAME_ENTRY_set(X509_NAME_ENTRY * x0)
{
  return Cryptography_X509_NAME_ENTRY_set(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_X509_NAME_ENTRY_set(PyObject *self, PyObject *arg0)
{
  X509_NAME_ENTRY * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(54), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(54), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_X509_NAME_ENTRY_set(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_X509_NAME_ENTRY_set _cffi_d_Cryptography_X509_NAME_ENTRY_set
#endif

static X509_REVOKED * _cffi_d_Cryptography_X509_REVOKED_dup(X509_REVOKED * x0)
{
  return Cryptography_X509_REVOKED_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_X509_REVOKED_dup(PyObject *self, PyObject *arg0)
{
  X509_REVOKED * x0;
  Py_ssize_t datasize;
  X509_REVOKED * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_X509_REVOKED_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(823));
}
#else
#  define _cffi_f_Cryptography_X509_REVOKED_dup _cffi_d_Cryptography_X509_REVOKED_dup
#endif

static int _cffi_d_Cryptography_add_osrandom_engine(void)
{
  return Cryptography_add_osrandom_engine();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_add_osrandom_engine(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_add_osrandom_engine(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_add_osrandom_engine _cffi_d_Cryptography_add_osrandom_engine
#endif

static DH * _cffi_d_Cryptography_d2i_DHxparams_bio(BIO * x0, DH * * x1)
{
  return Cryptography_d2i_DHxparams_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_d2i_DHxparams_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * * x1;
  Py_ssize_t datasize;
  DH * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "Cryptography_d2i_DHxparams_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(285), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_d2i_DHxparams_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_Cryptography_d2i_DHxparams_bio _cffi_d_Cryptography_d2i_DHxparams_bio
#endif

static void _cffi_d_Cryptography_free_wrapper(void * x0, char const * x1, int x2)
{
  Cryptography_free_wrapper(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_free_wrapper(PyObject *self, PyObject *args)
{
  void * x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "Cryptography_free_wrapper", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(92), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { Cryptography_free_wrapper(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_Cryptography_free_wrapper _cffi_d_Cryptography_free_wrapper
#endif

static int _cffi_d_Cryptography_i2d_DHxparams_bio(BIO * x0, DH * x1)
{
  return Cryptography_i2d_DHxparams_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_i2d_DHxparams_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "Cryptography_i2d_DHxparams_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(299), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_i2d_DHxparams_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_i2d_DHxparams_bio _cffi_d_Cryptography_i2d_DHxparams_bio
#endif

static void * _cffi_d_Cryptography_malloc_wrapper(size_t x0, char const * x1, int x2)
{
  return Cryptography_malloc_wrapper(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_malloc_wrapper(PyObject *self, PyObject *args)
{
  size_t x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "Cryptography_malloc_wrapper", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, size_t);
  if (x0 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_malloc_wrapper(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_Cryptography_malloc_wrapper _cffi_d_Cryptography_malloc_wrapper
#endif

static int _cffi_d_Cryptography_pem_password_cb(char * x0, int x1, int x2, void * x3)
{
  return Cryptography_pem_password_cb(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_pem_password_cb(PyObject *self, PyObject *args)
{
  char * x0;
  int x1;
  int x2;
  void * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "Cryptography_pem_password_cb", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(594), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_pem_password_cb(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_Cryptography_pem_password_cb _cffi_d_Cryptography_pem_password_cb
#endif

static void * _cffi_d_Cryptography_realloc_wrapper(void * x0, size_t x1, char const * x2, int x3)
{
  return Cryptography_realloc_wrapper(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Cryptography_realloc_wrapper(PyObject *self, PyObject *args)
{
  void * x0;
  size_t x1;
  char const * x2;
  int x3;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "Cryptography_realloc_wrapper", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(92), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(57), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = Cryptography_realloc_wrapper(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_Cryptography_realloc_wrapper _cffi_d_Cryptography_realloc_wrapper
#endif

static int _cffi_d_DH_check_pub_key(DH const * x0, BIGNUM const * x1, int * x2)
{
  return DH_check_pub_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_check_pub_key(PyObject *self, PyObject *args)
{
  DH const * x0;
  BIGNUM const * x1;
  int * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DH_check_pub_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1167), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_check_pub_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_check_pub_key _cffi_d_DH_check_pub_key
#endif

static int _cffi_d_DH_compute_key(unsigned char * x0, BIGNUM const * x1, DH * x2)
{
  return DH_compute_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_compute_key(PyObject *self, PyObject *args)
{
  unsigned char * x0;
  BIGNUM const * x1;
  DH * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DH_compute_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(975), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (DH *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(299), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_compute_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_compute_key _cffi_d_DH_compute_key
#endif

static void _cffi_d_DH_free(DH * x0)
{
  DH_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_free(PyObject *self, PyObject *arg0)
{
  DH * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DH_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DH_free _cffi_d_DH_free
#endif

static int _cffi_d_DH_generate_key(DH * x0)
{
  return DH_generate_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_generate_key(PyObject *self, PyObject *arg0)
{
  DH * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_generate_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_generate_key _cffi_d_DH_generate_key
#endif

static int _cffi_d_DH_generate_parameters_ex(DH * x0, int x1, int x2, BN_GENCB * x3)
{
  return DH_generate_parameters_ex(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_generate_parameters_ex(PyObject *self, PyObject *args)
{
  DH * x0;
  int x1;
  int x2;
  BN_GENCB * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "DH_generate_parameters_ex", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1496), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_GENCB *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1496), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_generate_parameters_ex(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_generate_parameters_ex _cffi_d_DH_generate_parameters_ex
#endif

static void _cffi_d_DH_get0_key(DH const * x0, BIGNUM const * * x1, BIGNUM const * * x2)
{
  DH_get0_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_get0_key(PyObject *self, PyObject *args)
{
  DH const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DH_get0_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1167), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DH_get0_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DH_get0_key _cffi_d_DH_get0_key
#endif

static void _cffi_d_DH_get0_pqg(DH const * x0, BIGNUM const * * x1, BIGNUM const * * x2, BIGNUM const * * x3)
{
  DH_get0_pqg(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_get0_pqg(PyObject *self, PyObject *args)
{
  DH const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  BIGNUM const * * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "DH_get0_pqg", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1167), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1619), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DH_get0_pqg(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DH_get0_pqg _cffi_d_DH_get0_pqg
#endif

static void * _cffi_d_DH_get_ex_data(DH * x0, int x1)
{
  return DH_get_ex_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_get_ex_data(PyObject *self, PyObject *args)
{
  DH * x0;
  int x1;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DH_get_ex_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_get_ex_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_DH_get_ex_data _cffi_d_DH_get_ex_data
#endif

static DH * _cffi_d_DH_new(void)
{
  return DH_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_new(PyObject *self, PyObject *noarg)
{
  DH * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_DH_new _cffi_d_DH_new
#endif

static int _cffi_d_DH_set0_key(DH * x0, BIGNUM * x1, BIGNUM * x2)
{
  return DH_set0_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_set0_key(PyObject *self, PyObject *args)
{
  DH * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DH_set0_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_set0_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_set0_key _cffi_d_DH_set0_key
#endif

static int _cffi_d_DH_set0_pqg(DH * x0, BIGNUM * x1, BIGNUM * x2, BIGNUM * x3)
{
  return DH_set0_pqg(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_set0_pqg(PyObject *self, PyObject *args)
{
  DH * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "DH_set0_pqg", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_set0_pqg(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_set0_pqg _cffi_d_DH_set0_pqg
#endif

static int _cffi_d_DH_set_ex_data(DH * x0, int x1, void * x2)
{
  return DH_set_ex_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_set_ex_data(PyObject *self, PyObject *args)
{
  DH * x0;
  int x1;
  void * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DH_set_ex_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_set_ex_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_set_ex_data _cffi_d_DH_set_ex_data
#endif

static int _cffi_d_DH_size(DH const * x0)
{
  return DH_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DH_size(PyObject *self, PyObject *arg0)
{
  DH const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1167), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DH_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DH_size _cffi_d_DH_size
#endif

static DH * _cffi_d_DHparams_dup(DH * x0)
{
  return DHparams_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DHparams_dup(PyObject *self, PyObject *arg0)
{
  DH * x0;
  Py_ssize_t datasize;
  DH * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(299), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DHparams_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_DHparams_dup _cffi_d_DHparams_dup
#endif

static int _cffi_d_DHparams_print(BIO * x0, DH const * x1)
{
  return DHparams_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DHparams_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DHparams_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1167), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DHparams_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DHparams_print _cffi_d_DHparams_print
#endif

static int _cffi_d_DHparams_print_fp(FILE * x0, DH const * x1)
{
  return DHparams_print_fp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DHparams_print_fp(PyObject *self, PyObject *args)
{
  FILE * x0;
  DH const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DHparams_print_fp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(178), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(178), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1167), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DHparams_print_fp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DHparams_print_fp _cffi_d_DHparams_print_fp
#endif

static void _cffi_d_DIST_POINT_NAME_free(DIST_POINT_NAME * x0)
{
  DIST_POINT_NAME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DIST_POINT_NAME_free(PyObject *self, PyObject *arg0)
{
  DIST_POINT_NAME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3239), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DIST_POINT_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3239), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DIST_POINT_NAME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DIST_POINT_NAME_free _cffi_d_DIST_POINT_NAME_free
#endif

static DIST_POINT_NAME * _cffi_d_DIST_POINT_NAME_new(void)
{
  return DIST_POINT_NAME_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DIST_POINT_NAME_new(PyObject *self, PyObject *noarg)
{
  DIST_POINT_NAME * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DIST_POINT_NAME_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3239));
}
#else
#  define _cffi_f_DIST_POINT_NAME_new _cffi_d_DIST_POINT_NAME_new
#endif

static void _cffi_d_DIST_POINT_free(DIST_POINT * x0)
{
  DIST_POINT_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DIST_POINT_free(PyObject *self, PyObject *arg0)
{
  DIST_POINT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1415), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1415), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DIST_POINT_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DIST_POINT_free _cffi_d_DIST_POINT_free
#endif

static DIST_POINT * _cffi_d_DIST_POINT_new(void)
{
  return DIST_POINT_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DIST_POINT_new(PyObject *self, PyObject *noarg)
{
  DIST_POINT * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DIST_POINT_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1415));
}
#else
#  define _cffi_f_DIST_POINT_new _cffi_d_DIST_POINT_new
#endif

static void _cffi_d_DSA_free(DSA * x0)
{
  DSA_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_free(PyObject *self, PyObject *arg0)
{
  DSA * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DSA_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DSA_free _cffi_d_DSA_free
#endif

static int _cffi_d_DSA_generate_key(DSA * x0)
{
  return DSA_generate_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_generate_key(PyObject *self, PyObject *arg0)
{
  DSA * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_generate_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_generate_key _cffi_d_DSA_generate_key
#endif

static int _cffi_d_DSA_generate_parameters_ex(DSA * x0, int x1, unsigned char * x2, int x3, int * x4, unsigned long * x5, BN_GENCB * x6)
{
  return DSA_generate_parameters_ex(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_generate_parameters_ex(PyObject *self, PyObject *args)
{
  DSA * x0;
  int x1;
  unsigned char * x2;
  int x3;
  int * x4;
  unsigned long * x5;
  BN_GENCB * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "DSA_generate_parameters_ex", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (int *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(1509), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1539), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (unsigned long *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(1539), arg5) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1496), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (BN_GENCB *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(1496), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_generate_parameters_ex(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_generate_parameters_ex _cffi_d_DSA_generate_parameters_ex
#endif

static void _cffi_d_DSA_get0_key(DSA const * x0, BIGNUM const * * x1, BIGNUM const * * x2)
{
  DSA_get0_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_get0_key(PyObject *self, PyObject *args)
{
  DSA const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DSA_get0_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1547), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1547), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DSA_get0_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DSA_get0_key _cffi_d_DSA_get0_key
#endif

static void _cffi_d_DSA_get0_pqg(DSA const * x0, BIGNUM const * * x1, BIGNUM const * * x2, BIGNUM const * * x3)
{
  DSA_get0_pqg(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_get0_pqg(PyObject *self, PyObject *args)
{
  DSA const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  BIGNUM const * * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "DSA_get0_pqg", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1547), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1547), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1619), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DSA_get0_pqg(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DSA_get0_pqg _cffi_d_DSA_get0_pqg
#endif

static DSA * _cffi_d_DSA_new(void)
{
  return DSA_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_new(PyObject *self, PyObject *noarg)
{
  DSA * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_DSA_new _cffi_d_DSA_new
#endif

static int _cffi_d_DSA_set0_key(DSA * x0, BIGNUM * x1, BIGNUM * x2)
{
  return DSA_set0_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_set0_key(PyObject *self, PyObject *args)
{
  DSA * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "DSA_set0_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_set0_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_set0_key _cffi_d_DSA_set0_key
#endif

static int _cffi_d_DSA_set0_pqg(DSA * x0, BIGNUM * x1, BIGNUM * x2, BIGNUM * x3)
{
  return DSA_set0_pqg(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_set0_pqg(PyObject *self, PyObject *args)
{
  DSA * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "DSA_set0_pqg", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_set0_pqg(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_set0_pqg _cffi_d_DSA_set0_pqg
#endif

static int _cffi_d_DSA_sign(int x0, unsigned char const * x1, int x2, unsigned char * x3, unsigned int * x4, DSA * x5)
{
  return DSA_sign(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_sign(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  int x2;
  unsigned char * x3;
  unsigned int * x4;
  DSA * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "DSA_sign", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(1871), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (DSA *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(333), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_sign(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_sign _cffi_d_DSA_sign
#endif

static int _cffi_d_DSA_size(DSA const * x0)
{
  return DSA_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_size(PyObject *self, PyObject *arg0)
{
  DSA const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1547), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1547), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_size _cffi_d_DSA_size
#endif

static int _cffi_d_DSA_verify(int x0, unsigned char const * x1, int x2, unsigned char const * x3, int x4, DSA * x5)
{
  return DSA_verify(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSA_verify(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  int x2;
  unsigned char const * x3;
  int x4;
  DSA * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "DSA_verify", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (DSA *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(333), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSA_verify(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_DSA_verify _cffi_d_DSA_verify
#endif

static DSA * _cffi_d_DSAparams_dup(DSA * x0)
{
  return DSAparams_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DSAparams_dup(PyObject *self, PyObject *arg0)
{
  DSA * x0;
  Py_ssize_t datasize;
  DSA * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DSAparams_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_DSAparams_dup _cffi_d_DSAparams_dup
#endif

static SSL_METHOD const * _cffi_d_DTLSv1_client_method(void)
{
  return DTLSv1_client_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DTLSv1_client_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DTLSv1_client_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_DTLSv1_client_method _cffi_d_DTLSv1_client_method
#endif

static long _cffi_d_DTLSv1_handle_timeout(SSL * x0)
{
  return DTLSv1_handle_timeout(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DTLSv1_handle_timeout(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DTLSv1_handle_timeout(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_DTLSv1_handle_timeout _cffi_d_DTLSv1_handle_timeout
#endif

static SSL_METHOD const * _cffi_d_DTLSv1_method(void)
{
  return DTLSv1_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DTLSv1_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DTLSv1_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_DTLSv1_method _cffi_d_DTLSv1_method
#endif

static SSL_METHOD const * _cffi_d_DTLSv1_server_method(void)
{
  return DTLSv1_server_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DTLSv1_server_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DTLSv1_server_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_DTLSv1_server_method _cffi_d_DTLSv1_server_method
#endif

static int _cffi_d_ECDH_compute_key(void * x0, size_t x1, EC_POINT const * x2, EC_KEY * x3, void *(* x4)(void const *, size_t, void *, size_t *))
{
  return ECDH_compute_key(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDH_compute_key(PyObject *self, PyObject *args)
{
  void * x0;
  size_t x1;
  EC_POINT const * x2;
  EC_KEY * x3;
  void *(* x4)(void const *, size_t, void *, size_t *);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "ECDH_compute_key", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(92), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(142), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(353), arg3) < 0)
      return NULL;
  }

  x4 = (void *(*)(void const *, size_t, void *, size_t *))_cffi_to_c_pointer(arg4, _cffi_type(2828));
  if (x4 == (void *(*)(void const *, size_t, void *, size_t *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDH_compute_key(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDH_compute_key _cffi_d_ECDH_compute_key
#endif

static void _cffi_d_ECDSA_SIG_free(ECDSA_SIG * x0)
{
  ECDSA_SIG_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_SIG_free(PyObject *self, PyObject *arg0)
{
  ECDSA_SIG * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3256), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ECDSA_SIG *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3256), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ECDSA_SIG_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ECDSA_SIG_free _cffi_d_ECDSA_SIG_free
#endif

static ECDSA_SIG * _cffi_d_ECDSA_SIG_new(void)
{
  return ECDSA_SIG_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_SIG_new(PyObject *self, PyObject *noarg)
{
  ECDSA_SIG * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_SIG_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3256));
}
#else
#  define _cffi_f_ECDSA_SIG_new _cffi_d_ECDSA_SIG_new
#endif

static ECDSA_SIG * _cffi_d_ECDSA_do_sign(unsigned char const * x0, int x1, EC_KEY * x2)
{
  return ECDSA_do_sign(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_do_sign(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  int x1;
  EC_KEY * x2;
  Py_ssize_t datasize;
  ECDSA_SIG * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ECDSA_do_sign", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(148), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(353), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_do_sign(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3256));
}
#else
#  define _cffi_f_ECDSA_do_sign _cffi_d_ECDSA_do_sign
#endif

static ECDSA_SIG * _cffi_d_ECDSA_do_sign_ex(unsigned char const * x0, int x1, BIGNUM const * x2, BIGNUM const * x3, EC_KEY * x4)
{
  return ECDSA_do_sign_ex(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_do_sign_ex(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  int x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  EC_KEY * x4;
  Py_ssize_t datasize;
  ECDSA_SIG * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "ECDSA_do_sign_ex", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(148), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(353), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_do_sign_ex(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3256));
}
#else
#  define _cffi_f_ECDSA_do_sign_ex _cffi_d_ECDSA_do_sign_ex
#endif

static int _cffi_d_ECDSA_do_verify(unsigned char const * x0, int x1, ECDSA_SIG const * x2, EC_KEY * x3)
{
  return ECDSA_do_verify(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_do_verify(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  int x1;
  ECDSA_SIG const * x2;
  EC_KEY * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ECDSA_do_verify", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(148), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1550), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ECDSA_SIG const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1550), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(353), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_do_verify(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDSA_do_verify _cffi_d_ECDSA_do_verify
#endif

static int _cffi_d_ECDSA_sign(int x0, unsigned char const * x1, int x2, unsigned char * x3, unsigned int * x4, EC_KEY * x5)
{
  return ECDSA_sign(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_sign(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  int x2;
  unsigned char * x3;
  unsigned int * x4;
  EC_KEY * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "ECDSA_sign", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(1871), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(353), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_sign(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDSA_sign _cffi_d_ECDSA_sign
#endif

static int _cffi_d_ECDSA_sign_ex(int x0, unsigned char const * x1, int x2, unsigned char * x3, unsigned int * x4, BIGNUM const * x5, BIGNUM const * x6, EC_KEY * x7)
{
  return ECDSA_sign_ex(x0, x1, x2, x3, x4, x5, x6, x7);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_sign_ex(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  int x2;
  unsigned char * x3;
  unsigned int * x4;
  BIGNUM const * x5;
  BIGNUM const * x6;
  EC_KEY * x7;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;

  if (!PyArg_UnpackTuple(args, "ECDSA_sign_ex", 8, 8, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(1871), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(126), arg5) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(126), arg6) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(353), arg7) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_sign_ex(x0, x1, x2, x3, x4, x5, x6, x7); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDSA_sign_ex _cffi_d_ECDSA_sign_ex
#endif

static int _cffi_d_ECDSA_sign_setup(EC_KEY * x0, BN_CTX * x1, BIGNUM * * x2, BIGNUM * * x3)
{
  return ECDSA_sign_setup(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_sign_setup(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  BN_CTX * x1;
  BIGNUM * * x2;
  BIGNUM * * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ECDSA_sign_setup", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(132), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1067), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1067), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1067), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1067), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_sign_setup(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDSA_sign_setup _cffi_d_ECDSA_sign_setup
#endif

static int _cffi_d_ECDSA_size(EC_KEY const * x0)
{
  return ECDSA_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_size(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDSA_size _cffi_d_ECDSA_size
#endif

static int _cffi_d_ECDSA_verify(int x0, unsigned char const * x1, int x2, unsigned char const * x3, int x4, EC_KEY * x5)
{
  return ECDSA_verify(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ECDSA_verify(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  int x2;
  unsigned char const * x3;
  int x4;
  EC_KEY * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "ECDSA_verify", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(353), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ECDSA_verify(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ECDSA_verify _cffi_d_ECDSA_verify
#endif

static EC_METHOD const * _cffi_d_EC_GF2m_simple_method(void)
{
  return EC_GF2m_simple_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GF2m_simple_method(PyObject *self, PyObject *noarg)
{
  EC_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GF2m_simple_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(369));
}
#else
#  define _cffi_f_EC_GF2m_simple_method _cffi_d_EC_GF2m_simple_method
#endif

static EC_METHOD const * _cffi_d_EC_GFp_mont_method(void)
{
  return EC_GFp_mont_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GFp_mont_method(PyObject *self, PyObject *noarg)
{
  EC_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GFp_mont_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(369));
}
#else
#  define _cffi_f_EC_GFp_mont_method _cffi_d_EC_GFp_mont_method
#endif

static EC_METHOD const * _cffi_d_EC_GFp_nist_method(void)
{
  return EC_GFp_nist_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GFp_nist_method(PyObject *self, PyObject *noarg)
{
  EC_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GFp_nist_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(369));
}
#else
#  define _cffi_f_EC_GFp_nist_method _cffi_d_EC_GFp_nist_method
#endif

static EC_METHOD const * _cffi_d_EC_GFp_simple_method(void)
{
  return EC_GFp_simple_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GFp_simple_method(PyObject *self, PyObject *noarg)
{
  EC_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GFp_simple_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(369));
}
#else
#  define _cffi_f_EC_GFp_simple_method _cffi_d_EC_GFp_simple_method
#endif

static void _cffi_d_EC_GROUP_clear_free(EC_GROUP * x0)
{
  EC_GROUP_clear_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_clear_free(PyObject *self, PyObject *arg0)
{
  EC_GROUP * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_GROUP_clear_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_GROUP_clear_free _cffi_d_EC_GROUP_clear_free
#endif

static void _cffi_d_EC_GROUP_free(EC_GROUP * x0)
{
  EC_GROUP_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_free(PyObject *self, PyObject *arg0)
{
  EC_GROUP * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_GROUP_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_GROUP_free _cffi_d_EC_GROUP_free
#endif

static EC_POINT const * _cffi_d_EC_GROUP_get0_generator(EC_GROUP const * x0)
{
  return EC_GROUP_get0_generator(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_get0_generator(PyObject *self, PyObject *arg0)
{
  EC_GROUP const * x0;
  Py_ssize_t datasize;
  EC_POINT const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_get0_generator(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(142));
}
#else
#  define _cffi_f_EC_GROUP_get0_generator _cffi_d_EC_GROUP_get0_generator
#endif

static int _cffi_d_EC_GROUP_get_curve_GF2m(EC_GROUP const * x0, BIGNUM * x1, BIGNUM * x2, BIGNUM * x3, BN_CTX * x4)
{
  return EC_GROUP_get_curve_GF2m(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_get_curve_GF2m(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_get_curve_GF2m", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_get_curve_GF2m(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_get_curve_GF2m _cffi_d_EC_GROUP_get_curve_GF2m
#endif

static int _cffi_d_EC_GROUP_get_curve_GFp(EC_GROUP const * x0, BIGNUM * x1, BIGNUM * x2, BIGNUM * x3, BN_CTX * x4)
{
  return EC_GROUP_get_curve_GFp(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_get_curve_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_get_curve_GFp", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_get_curve_GFp(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_get_curve_GFp _cffi_d_EC_GROUP_get_curve_GFp
#endif

static int _cffi_d_EC_GROUP_get_curve_name(EC_GROUP const * x0)
{
  return EC_GROUP_get_curve_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_get_curve_name(PyObject *self, PyObject *arg0)
{
  EC_GROUP const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_get_curve_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_get_curve_name _cffi_d_EC_GROUP_get_curve_name
#endif

static int _cffi_d_EC_GROUP_get_degree(EC_GROUP const * x0)
{
  return EC_GROUP_get_degree(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_get_degree(PyObject *self, PyObject *arg0)
{
  EC_GROUP const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_get_degree(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_get_degree _cffi_d_EC_GROUP_get_degree
#endif

static int _cffi_d_EC_GROUP_get_order(EC_GROUP const * x0, BIGNUM * x1, BN_CTX * x2)
{
  return EC_GROUP_get_order(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_get_order(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  BIGNUM * x1;
  BN_CTX * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_get_order", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(132), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_get_order(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_get_order _cffi_d_EC_GROUP_get_order
#endif

static int _cffi_d_EC_GROUP_have_precompute_mult(EC_GROUP const * x0)
{
  return EC_GROUP_have_precompute_mult(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_have_precompute_mult(PyObject *self, PyObject *arg0)
{
  EC_GROUP const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_have_precompute_mult(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_have_precompute_mult _cffi_d_EC_GROUP_have_precompute_mult
#endif

static EC_METHOD const * _cffi_d_EC_GROUP_method_of(EC_GROUP const * x0)
{
  return EC_GROUP_method_of(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_method_of(PyObject *self, PyObject *arg0)
{
  EC_GROUP const * x0;
  Py_ssize_t datasize;
  EC_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_method_of(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(369));
}
#else
#  define _cffi_f_EC_GROUP_method_of _cffi_d_EC_GROUP_method_of
#endif

static EC_GROUP * _cffi_d_EC_GROUP_new(EC_METHOD const * x0)
{
  return EC_GROUP_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_new(PyObject *self, PyObject *arg0)
{
  EC_METHOD const * x0;
  Py_ssize_t datasize;
  EC_GROUP * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(369), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_METHOD const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(369), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1554));
}
#else
#  define _cffi_f_EC_GROUP_new _cffi_d_EC_GROUP_new
#endif

static EC_GROUP * _cffi_d_EC_GROUP_new_by_curve_name(int x0)
{
  return EC_GROUP_new_by_curve_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_new_by_curve_name(PyObject *self, PyObject *arg0)
{
  int x0;
  EC_GROUP * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_new_by_curve_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1554));
}
#else
#  define _cffi_f_EC_GROUP_new_by_curve_name _cffi_d_EC_GROUP_new_by_curve_name
#endif

static EC_GROUP * _cffi_d_EC_GROUP_new_curve_GF2m(BIGNUM const * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return EC_GROUP_new_curve_GF2m(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_new_curve_GF2m(PyObject *self, PyObject *args)
{
  BIGNUM const * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  EC_GROUP * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_new_curve_GF2m", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_new_curve_GF2m(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1554));
}
#else
#  define _cffi_f_EC_GROUP_new_curve_GF2m _cffi_d_EC_GROUP_new_curve_GF2m
#endif

static EC_GROUP * _cffi_d_EC_GROUP_new_curve_GFp(BIGNUM const * x0, BIGNUM const * x1, BIGNUM const * x2, BN_CTX * x3)
{
  return EC_GROUP_new_curve_GFp(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_new_curve_GFp(PyObject *self, PyObject *args)
{
  BIGNUM const * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  EC_GROUP * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_new_curve_GFp", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(126), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_new_curve_GFp(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1554));
}
#else
#  define _cffi_f_EC_GROUP_new_curve_GFp _cffi_d_EC_GROUP_new_curve_GFp
#endif

static int _cffi_d_EC_GROUP_precompute_mult(EC_GROUP * x0, BN_CTX * x1)
{
  return EC_GROUP_precompute_mult(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_precompute_mult(PyObject *self, PyObject *args)
{
  EC_GROUP * x0;
  BN_CTX * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_precompute_mult", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(132), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_precompute_mult(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_precompute_mult _cffi_d_EC_GROUP_precompute_mult
#endif

static void _cffi_d_EC_GROUP_set_asn1_flag(EC_GROUP * x0, int x1)
{
  EC_GROUP_set_asn1_flag(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_set_asn1_flag(PyObject *self, PyObject *args)
{
  EC_GROUP * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_set_asn1_flag", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_GROUP_set_asn1_flag(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_GROUP_set_asn1_flag _cffi_d_EC_GROUP_set_asn1_flag
#endif

static int _cffi_d_EC_GROUP_set_curve_GF2m(EC_GROUP * x0, BIGNUM const * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return EC_GROUP_set_curve_GF2m(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_set_curve_GF2m(PyObject *self, PyObject *args)
{
  EC_GROUP * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_set_curve_GF2m", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_set_curve_GF2m(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_set_curve_GF2m _cffi_d_EC_GROUP_set_curve_GF2m
#endif

static int _cffi_d_EC_GROUP_set_curve_GFp(EC_GROUP * x0, BIGNUM const * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return EC_GROUP_set_curve_GFp(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_set_curve_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP * x0;
  BIGNUM const * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_set_curve_GFp", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_GROUP_set_curve_GFp(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_GROUP_set_curve_GFp _cffi_d_EC_GROUP_set_curve_GFp
#endif

static void _cffi_d_EC_GROUP_set_point_conversion_form(EC_GROUP * x0, point_conversion_form_t x1)
{
  EC_GROUP_set_point_conversion_form(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_GROUP_set_point_conversion_form(PyObject *self, PyObject *args)
{
  EC_GROUP * x0;
  point_conversion_form_t x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_GROUP_set_point_conversion_form", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1554), arg0) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(143), arg1) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_GROUP_set_point_conversion_form(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_GROUP_set_point_conversion_form _cffi_d_EC_GROUP_set_point_conversion_form
#endif

static int _cffi_d_EC_KEY_check_key(EC_KEY const * x0)
{
  return EC_KEY_check_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_check_key(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_check_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_check_key _cffi_d_EC_KEY_check_key
#endif

static void _cffi_d_EC_KEY_clear_flags(EC_KEY * x0, int x1)
{
  EC_KEY_clear_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_clear_flags(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_clear_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_KEY_clear_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_KEY_clear_flags _cffi_d_EC_KEY_clear_flags
#endif

static EC_KEY * _cffi_d_EC_KEY_copy(EC_KEY * x0, EC_KEY * x1)
{
  return EC_KEY_copy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_copy(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  EC_KEY * x1;
  Py_ssize_t datasize;
  EC_KEY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_copy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_copy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_EC_KEY_copy _cffi_d_EC_KEY_copy
#endif

static EC_KEY * _cffi_d_EC_KEY_dup(EC_KEY * x0)
{
  return EC_KEY_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_dup(PyObject *self, PyObject *arg0)
{
  EC_KEY * x0;
  Py_ssize_t datasize;
  EC_KEY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_EC_KEY_dup _cffi_d_EC_KEY_dup
#endif

static void _cffi_d_EC_KEY_free(EC_KEY * x0)
{
  EC_KEY_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_free(PyObject *self, PyObject *arg0)
{
  EC_KEY * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_KEY_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_KEY_free _cffi_d_EC_KEY_free
#endif

static int _cffi_d_EC_KEY_generate_key(EC_KEY * x0)
{
  return EC_KEY_generate_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_generate_key(PyObject *self, PyObject *arg0)
{
  EC_KEY * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_generate_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_generate_key _cffi_d_EC_KEY_generate_key
#endif

static EC_GROUP const * _cffi_d_EC_KEY_get0_group(EC_KEY const * x0)
{
  return EC_KEY_get0_group(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_get0_group(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  EC_GROUP const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_get0_group(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(141));
}
#else
#  define _cffi_f_EC_KEY_get0_group _cffi_d_EC_KEY_get0_group
#endif

static BIGNUM const * _cffi_d_EC_KEY_get0_private_key(EC_KEY const * x0)
{
  return EC_KEY_get0_private_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_get0_private_key(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  BIGNUM const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_get0_private_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(126));
}
#else
#  define _cffi_f_EC_KEY_get0_private_key _cffi_d_EC_KEY_get0_private_key
#endif

static EC_POINT const * _cffi_d_EC_KEY_get0_public_key(EC_KEY const * x0)
{
  return EC_KEY_get0_public_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_get0_public_key(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  EC_POINT const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_get0_public_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(142));
}
#else
#  define _cffi_f_EC_KEY_get0_public_key _cffi_d_EC_KEY_get0_public_key
#endif

static point_conversion_form_t _cffi_d_EC_KEY_get_conv_form(EC_KEY const * x0)
{
  return EC_KEY_get_conv_form(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_get_conv_form(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  point_conversion_form_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_get_conv_form(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_deref((char *)&result, _cffi_type(143));
}
#else
#  define _cffi_f_EC_KEY_get_conv_form _cffi_d_EC_KEY_get_conv_form
#endif

static unsigned int _cffi_d_EC_KEY_get_enc_flags(EC_KEY const * x0)
{
  return EC_KEY_get_enc_flags(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_get_enc_flags(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  unsigned int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_get_enc_flags(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_EC_KEY_get_enc_flags _cffi_d_EC_KEY_get_enc_flags
#endif

static int _cffi_d_EC_KEY_get_flags(EC_KEY const * x0)
{
  return EC_KEY_get_flags(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_get_flags(PyObject *self, PyObject *arg0)
{
  EC_KEY const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(155), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_get_flags(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_get_flags _cffi_d_EC_KEY_get_flags
#endif

static EC_KEY * _cffi_d_EC_KEY_new(void)
{
  return EC_KEY_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_new(PyObject *self, PyObject *noarg)
{
  EC_KEY * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_EC_KEY_new _cffi_d_EC_KEY_new
#endif

static EC_KEY * _cffi_d_EC_KEY_new_by_curve_name(int x0)
{
  return EC_KEY_new_by_curve_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_new_by_curve_name(PyObject *self, PyObject *arg0)
{
  int x0;
  EC_KEY * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_new_by_curve_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_EC_KEY_new_by_curve_name _cffi_d_EC_KEY_new_by_curve_name
#endif

static int _cffi_d_EC_KEY_precompute_mult(EC_KEY * x0, BN_CTX * x1)
{
  return EC_KEY_precompute_mult(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_precompute_mult(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  BN_CTX * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_precompute_mult", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(132), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_precompute_mult(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_precompute_mult _cffi_d_EC_KEY_precompute_mult
#endif

static void _cffi_d_EC_KEY_set_asn1_flag(EC_KEY * x0, int x1)
{
  EC_KEY_set_asn1_flag(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_asn1_flag(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_asn1_flag", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_KEY_set_asn1_flag(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_KEY_set_asn1_flag _cffi_d_EC_KEY_set_asn1_flag
#endif

static void _cffi_d_EC_KEY_set_conv_form(EC_KEY * x0, point_conversion_form_t x1)
{
  EC_KEY_set_conv_form(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_conv_form(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  point_conversion_form_t x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_conv_form", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(143), arg1) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_KEY_set_conv_form(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_KEY_set_conv_form _cffi_d_EC_KEY_set_conv_form
#endif

static void _cffi_d_EC_KEY_set_enc_flags(EC_KEY * x0, unsigned int x1)
{
  EC_KEY_set_enc_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_enc_flags(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  unsigned int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_enc_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned int);
  if (x1 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_KEY_set_enc_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_KEY_set_enc_flags _cffi_d_EC_KEY_set_enc_flags
#endif

static void _cffi_d_EC_KEY_set_flags(EC_KEY * x0, int x1)
{
  EC_KEY_set_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_flags(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_KEY_set_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_KEY_set_flags _cffi_d_EC_KEY_set_flags
#endif

static int _cffi_d_EC_KEY_set_group(EC_KEY * x0, EC_GROUP const * x1)
{
  return EC_KEY_set_group(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_group(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  EC_GROUP const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_group", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(141), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_set_group(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_set_group _cffi_d_EC_KEY_set_group
#endif

static int _cffi_d_EC_KEY_set_private_key(EC_KEY * x0, BIGNUM const * x1)
{
  return EC_KEY_set_private_key(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_private_key(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  BIGNUM const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_private_key", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_set_private_key(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_set_private_key _cffi_d_EC_KEY_set_private_key
#endif

static int _cffi_d_EC_KEY_set_public_key(EC_KEY * x0, EC_POINT const * x1)
{
  return EC_KEY_set_public_key(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_public_key(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  EC_POINT const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_public_key", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_set_public_key(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_set_public_key _cffi_d_EC_KEY_set_public_key
#endif

static int _cffi_d_EC_KEY_set_public_key_affine_coordinates(EC_KEY * x0, BIGNUM * x1, BIGNUM * x2)
{
  return EC_KEY_set_public_key_affine_coordinates(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_set_public_key_affine_coordinates(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EC_KEY_set_public_key_affine_coordinates", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_set_public_key_affine_coordinates(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_set_public_key_affine_coordinates _cffi_d_EC_KEY_set_public_key_affine_coordinates
#endif

static int _cffi_d_EC_KEY_up_ref(EC_KEY * x0)
{
  return EC_KEY_up_ref(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_KEY_up_ref(PyObject *self, PyObject *arg0)
{
  EC_KEY * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_KEY_up_ref(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_KEY_up_ref _cffi_d_EC_KEY_up_ref
#endif

static int _cffi_d_EC_METHOD_get_field_type(EC_METHOD const * x0)
{
  return EC_METHOD_get_field_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_METHOD_get_field_type(PyObject *self, PyObject *arg0)
{
  EC_METHOD const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(369), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_METHOD const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(369), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_METHOD_get_field_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_METHOD_get_field_type _cffi_d_EC_METHOD_get_field_type
#endif

static int _cffi_d_EC_POINT_add(EC_GROUP const * x0, EC_POINT * x1, EC_POINT const * x2, EC_POINT const * x3, BN_CTX * x4)
{
  return EC_POINT_add(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_add(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  EC_POINT const * x2;
  EC_POINT const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_add", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(142), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(142), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_add(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_add _cffi_d_EC_POINT_add
#endif

static EC_POINT * _cffi_d_EC_POINT_bn2point(EC_GROUP const * x0, BIGNUM const * x1, EC_POINT * x2, BN_CTX * x3)
{
  return EC_POINT_bn2point(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_bn2point(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  BIGNUM const * x1;
  EC_POINT * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  EC_POINT * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_POINT_bn2point", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(126), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(415), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_bn2point(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(415));
}
#else
#  define _cffi_f_EC_POINT_bn2point _cffi_d_EC_POINT_bn2point
#endif

static void _cffi_d_EC_POINT_clear_free(EC_POINT * x0)
{
  EC_POINT_clear_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_clear_free(PyObject *self, PyObject *arg0)
{
  EC_POINT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(415), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_POINT_clear_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_POINT_clear_free _cffi_d_EC_POINT_clear_free
#endif

static int _cffi_d_EC_POINT_cmp(EC_GROUP const * x0, EC_POINT const * x1, EC_POINT const * x2, BN_CTX * x3)
{
  return EC_POINT_cmp(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_cmp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  EC_POINT const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_POINT_cmp", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(142), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_cmp(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_cmp _cffi_d_EC_POINT_cmp
#endif

static int _cffi_d_EC_POINT_copy(EC_POINT * x0, EC_POINT const * x1)
{
  return EC_POINT_copy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_copy(PyObject *self, PyObject *args)
{
  EC_POINT * x0;
  EC_POINT const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_POINT_copy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(415), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_copy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_copy _cffi_d_EC_POINT_copy
#endif

static int _cffi_d_EC_POINT_dbl(EC_GROUP const * x0, EC_POINT * x1, EC_POINT const * x2, BN_CTX * x3)
{
  return EC_POINT_dbl(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_dbl(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  EC_POINT const * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_POINT_dbl", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(142), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_dbl(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_dbl _cffi_d_EC_POINT_dbl
#endif

static EC_POINT * _cffi_d_EC_POINT_dup(EC_POINT const * x0, EC_GROUP const * x1)
{
  return EC_POINT_dup(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_dup(PyObject *self, PyObject *args)
{
  EC_POINT const * x0;
  EC_GROUP const * x1;
  Py_ssize_t datasize;
  EC_POINT * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_POINT_dup", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(142), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(141), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_dup(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(415));
}
#else
#  define _cffi_f_EC_POINT_dup _cffi_d_EC_POINT_dup
#endif

static void _cffi_d_EC_POINT_free(EC_POINT * x0)
{
  EC_POINT_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_free(PyObject *self, PyObject *arg0)
{
  EC_POINT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(415), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EC_POINT_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EC_POINT_free _cffi_d_EC_POINT_free
#endif

static int _cffi_d_EC_POINT_get_Jprojective_coordinates_GFp(EC_GROUP const * x0, EC_POINT const * x1, BIGNUM * x2, BIGNUM * x3, BIGNUM * x4, BN_CTX * x5)
{
  return EC_POINT_get_Jprojective_coordinates_GFp(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_get_Jprojective_coordinates_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  BIGNUM * x4;
  BN_CTX * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "EC_POINT_get_Jprojective_coordinates_GFp", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(20), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(132), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_get_Jprojective_coordinates_GFp(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_get_Jprojective_coordinates_GFp _cffi_d_EC_POINT_get_Jprojective_coordinates_GFp
#endif

static int _cffi_d_EC_POINT_get_affine_coordinates_GF2m(EC_GROUP const * x0, EC_POINT const * x1, BIGNUM * x2, BIGNUM * x3, BN_CTX * x4)
{
  return EC_POINT_get_affine_coordinates_GF2m(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_get_affine_coordinates_GF2m(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_get_affine_coordinates_GF2m", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_get_affine_coordinates_GF2m(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_get_affine_coordinates_GF2m _cffi_d_EC_POINT_get_affine_coordinates_GF2m
#endif

static int _cffi_d_EC_POINT_get_affine_coordinates_GFp(EC_GROUP const * x0, EC_POINT const * x1, BIGNUM * x2, BIGNUM * x3, BN_CTX * x4)
{
  return EC_POINT_get_affine_coordinates_GFp(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_get_affine_coordinates_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_get_affine_coordinates_GFp", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_get_affine_coordinates_GFp(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_get_affine_coordinates_GFp _cffi_d_EC_POINT_get_affine_coordinates_GFp
#endif

static EC_POINT * _cffi_d_EC_POINT_hex2point(EC_GROUP const * x0, char const * x1, EC_POINT * x2, BN_CTX * x3)
{
  return EC_POINT_hex2point(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_hex2point(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  char const * x1;
  EC_POINT * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  EC_POINT * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_POINT_hex2point", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(415), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_hex2point(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(415));
}
#else
#  define _cffi_f_EC_POINT_hex2point _cffi_d_EC_POINT_hex2point
#endif

static int _cffi_d_EC_POINT_invert(EC_GROUP const * x0, EC_POINT * x1, BN_CTX * x2)
{
  return EC_POINT_invert(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_invert(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BN_CTX * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EC_POINT_invert", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(132), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_invert(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_invert _cffi_d_EC_POINT_invert
#endif

static int _cffi_d_EC_POINT_is_at_infinity(EC_GROUP const * x0, EC_POINT const * x1)
{
  return EC_POINT_is_at_infinity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_is_at_infinity(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_POINT_is_at_infinity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_is_at_infinity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_is_at_infinity _cffi_d_EC_POINT_is_at_infinity
#endif

static int _cffi_d_EC_POINT_is_on_curve(EC_GROUP const * x0, EC_POINT const * x1, BN_CTX * x2)
{
  return EC_POINT_is_on_curve(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_is_on_curve(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  BN_CTX * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EC_POINT_is_on_curve", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(132), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_is_on_curve(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_is_on_curve _cffi_d_EC_POINT_is_on_curve
#endif

static int _cffi_d_EC_POINT_make_affine(EC_GROUP const * x0, EC_POINT * x1, BN_CTX * x2)
{
  return EC_POINT_make_affine(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_make_affine(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BN_CTX * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EC_POINT_make_affine", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(132), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_make_affine(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_make_affine _cffi_d_EC_POINT_make_affine
#endif

static EC_METHOD const * _cffi_d_EC_POINT_method_of(EC_POINT const * x0)
{
  return EC_POINT_method_of(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_method_of(PyObject *self, PyObject *arg0)
{
  EC_POINT const * x0;
  Py_ssize_t datasize;
  EC_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(142), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_method_of(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(369));
}
#else
#  define _cffi_f_EC_POINT_method_of _cffi_d_EC_POINT_method_of
#endif

static int _cffi_d_EC_POINT_mul(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, EC_POINT const * x3, BIGNUM const * x4, BN_CTX * x5)
{
  return EC_POINT_mul(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_mul(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  EC_POINT const * x3;
  BIGNUM const * x4;
  BN_CTX * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "EC_POINT_mul", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(142), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(126), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(132), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_mul(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_mul _cffi_d_EC_POINT_mul
#endif

static EC_POINT * _cffi_d_EC_POINT_new(EC_GROUP const * x0)
{
  return EC_POINT_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_new(PyObject *self, PyObject *arg0)
{
  EC_GROUP const * x0;
  Py_ssize_t datasize;
  EC_POINT * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(415));
}
#else
#  define _cffi_f_EC_POINT_new _cffi_d_EC_POINT_new
#endif

static int _cffi_d_EC_POINT_oct2point(EC_GROUP const * x0, EC_POINT * x1, unsigned char const * x2, size_t x3, BN_CTX * x4)
{
  return EC_POINT_oct2point(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_oct2point(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  unsigned char const * x2;
  size_t x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_oct2point", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, size_t);
  if (x3 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_oct2point(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_oct2point _cffi_d_EC_POINT_oct2point
#endif

static BIGNUM * _cffi_d_EC_POINT_point2bn(EC_GROUP const * x0, EC_POINT const * x1, point_conversion_form_t x2, BIGNUM * x3, BN_CTX * x4)
{
  return EC_POINT_point2bn(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_point2bn(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  point_conversion_form_t x2;
  BIGNUM * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  BIGNUM * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_point2bn", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(143), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_point2bn(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_EC_POINT_point2bn _cffi_d_EC_POINT_point2bn
#endif

static char * _cffi_d_EC_POINT_point2hex(EC_GROUP const * x0, EC_POINT const * x1, point_conversion_form_t x2, BN_CTX * x3)
{
  return EC_POINT_point2hex(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_point2hex(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  point_conversion_form_t x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  char * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_POINT_point2hex", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(143), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_point2hex(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_EC_POINT_point2hex _cffi_d_EC_POINT_point2hex
#endif

static size_t _cffi_d_EC_POINT_point2oct(EC_GROUP const * x0, EC_POINT const * x1, point_conversion_form_t x2, unsigned char * x3, size_t x4, BN_CTX * x5)
{
  return EC_POINT_point2oct(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_point2oct(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT const * x1;
  point_conversion_form_t x2;
  unsigned char * x3;
  size_t x4;
  BN_CTX * x5;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "EC_POINT_point2oct", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(142), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(142), arg1) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(143), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, size_t);
  if (x4 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(132), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_point2oct(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_EC_POINT_point2oct _cffi_d_EC_POINT_point2oct
#endif

static int _cffi_d_EC_POINT_set_Jprojective_coordinates_GFp(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, BIGNUM const * x3, BIGNUM const * x4, BN_CTX * x5)
{
  return EC_POINT_set_Jprojective_coordinates_GFp(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_set_Jprojective_coordinates_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BIGNUM const * x4;
  BN_CTX * x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "EC_POINT_set_Jprojective_coordinates_GFp", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(126), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(132), arg5) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_set_Jprojective_coordinates_GFp(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_set_Jprojective_coordinates_GFp _cffi_d_EC_POINT_set_Jprojective_coordinates_GFp
#endif

static int _cffi_d_EC_POINT_set_affine_coordinates_GF2m(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return EC_POINT_set_affine_coordinates_GF2m(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_set_affine_coordinates_GF2m(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_set_affine_coordinates_GF2m", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_set_affine_coordinates_GF2m(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_set_affine_coordinates_GF2m _cffi_d_EC_POINT_set_affine_coordinates_GF2m
#endif

static int _cffi_d_EC_POINT_set_affine_coordinates_GFp(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, BIGNUM const * x3, BN_CTX * x4)
{
  return EC_POINT_set_affine_coordinates_GFp(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_set_affine_coordinates_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  BIGNUM const * x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_set_affine_coordinates_GFp", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(126), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_set_affine_coordinates_GFp(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_set_affine_coordinates_GFp _cffi_d_EC_POINT_set_affine_coordinates_GFp
#endif

static int _cffi_d_EC_POINT_set_compressed_coordinates_GF2m(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, int x3, BN_CTX * x4)
{
  return EC_POINT_set_compressed_coordinates_GF2m(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_set_compressed_coordinates_GF2m(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  int x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_set_compressed_coordinates_GF2m", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_set_compressed_coordinates_GF2m(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_set_compressed_coordinates_GF2m _cffi_d_EC_POINT_set_compressed_coordinates_GF2m
#endif

static int _cffi_d_EC_POINT_set_compressed_coordinates_GFp(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, int x3, BN_CTX * x4)
{
  return EC_POINT_set_compressed_coordinates_GFp(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_set_compressed_coordinates_GFp(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  int x3;
  BN_CTX * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EC_POINT_set_compressed_coordinates_GFp", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(132), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_set_compressed_coordinates_GFp(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_set_compressed_coordinates_GFp _cffi_d_EC_POINT_set_compressed_coordinates_GFp
#endif

static int _cffi_d_EC_POINT_set_to_infinity(EC_GROUP const * x0, EC_POINT * x1)
{
  return EC_POINT_set_to_infinity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINT_set_to_infinity(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_POINT_set_to_infinity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINT_set_to_infinity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINT_set_to_infinity _cffi_d_EC_POINT_set_to_infinity
#endif

static int _cffi_d_EC_POINTs_make_affine(EC_GROUP const * x0, size_t x1, EC_POINT * * x2, BN_CTX * x3)
{
  return EC_POINTs_make_affine(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINTs_make_affine(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  size_t x1;
  EC_POINT * * x2;
  BN_CTX * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EC_POINTs_make_affine", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1680), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EC_POINT * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1680), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(132), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINTs_make_affine(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINTs_make_affine _cffi_d_EC_POINTs_make_affine
#endif

static int _cffi_d_EC_POINTs_mul(EC_GROUP const * x0, EC_POINT * x1, BIGNUM const * x2, size_t x3, EC_POINT const * * x4, BIGNUM const * * x5, BN_CTX * x6)
{
  return EC_POINTs_mul(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_POINTs_mul(PyObject *self, PyObject *args)
{
  EC_GROUP const * x0;
  EC_POINT * x1;
  BIGNUM const * x2;
  size_t x3;
  EC_POINT const * * x4;
  BIGNUM const * * x5;
  BN_CTX * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "EC_POINTs_mul", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(141), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_GROUP const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(141), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(415), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(126), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(126), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, size_t);
  if (x3 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1618), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (EC_POINT const * *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(1618), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(1619), arg5) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(132), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_POINTs_mul(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EC_POINTs_mul _cffi_d_EC_POINTs_mul
#endif

static char const * _cffi_d_EC_curve_nid2nist(int x0)
{
  return EC_curve_nid2nist(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_curve_nid2nist(PyObject *self, PyObject *arg0)
{
  int x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_curve_nid2nist(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_EC_curve_nid2nist _cffi_d_EC_curve_nid2nist
#endif

static size_t _cffi_d_EC_get_builtin_curves(EC_builtin_curve * x0, size_t x1)
{
  return EC_get_builtin_curves(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EC_get_builtin_curves(PyObject *self, PyObject *args)
{
  EC_builtin_curve * x0;
  size_t x1;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EC_get_builtin_curves", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2978), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_builtin_curve *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2978), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EC_get_builtin_curves(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_EC_get_builtin_curves _cffi_d_EC_get_builtin_curves
#endif

static int _cffi_d_ENGINE_add(ENGINE * x0)
{
  return ENGINE_add(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_add(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_add(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_add _cffi_d_ENGINE_add
#endif

static void _cffi_d_ENGINE_add_conf_module(void)
{
  ENGINE_add_conf_module();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_add_conf_module(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_add_conf_module(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_add_conf_module _cffi_d_ENGINE_add_conf_module
#endif

static ENGINE * _cffi_d_ENGINE_by_id(char const * x0)
{
  return ENGINE_by_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_by_id(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  ENGINE * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_by_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_by_id _cffi_d_ENGINE_by_id
#endif

static void _cffi_d_ENGINE_cleanup(void)
{
  ENGINE_cleanup();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_cleanup(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_cleanup(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_cleanup _cffi_d_ENGINE_cleanup
#endif

static int _cffi_d_ENGINE_cmd_is_executable(ENGINE * x0, int x1)
{
  return ENGINE_cmd_is_executable(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_cmd_is_executable(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_cmd_is_executable", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_cmd_is_executable(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_cmd_is_executable _cffi_d_ENGINE_cmd_is_executable
#endif

static int _cffi_d_ENGINE_ctrl(ENGINE * x0, int x1, long x2, void * x3, void(* x4)(void))
{
  return ENGINE_ctrl(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_ctrl(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int x1;
  long x2;
  void * x3;
  void(* x4)(void);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "ENGINE_ctrl", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  x4 = (void(*)(void))_cffi_to_c_pointer(arg4, _cffi_type(1781));
  if (x4 == (void(*)(void))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_ctrl(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_ctrl _cffi_d_ENGINE_ctrl
#endif

static int _cffi_d_ENGINE_ctrl_cmd(ENGINE * x0, char const * x1, long x2, void * x3, void(* x4)(void), int x5)
{
  return ENGINE_ctrl_cmd(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_ctrl_cmd(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  long x2;
  void * x3;
  void(* x4)(void);
  int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "ENGINE_ctrl_cmd", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  x4 = (void(*)(void))_cffi_to_c_pointer(arg4, _cffi_type(1781));
  if (x4 == (void(*)(void))NULL && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_ctrl_cmd(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_ctrl_cmd _cffi_d_ENGINE_ctrl_cmd
#endif

static int _cffi_d_ENGINE_ctrl_cmd_string(ENGINE * x0, char const * x1, char const * x2, int x3)
{
  return ENGINE_ctrl_cmd_string(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_ctrl_cmd_string(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  char const * x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ENGINE_ctrl_cmd_string", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(57), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_ctrl_cmd_string(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_ctrl_cmd_string _cffi_d_ENGINE_ctrl_cmd_string
#endif

static int _cffi_d_ENGINE_finish(ENGINE * x0)
{
  return ENGINE_finish(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_finish(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_finish(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_finish _cffi_d_ENGINE_finish
#endif

static int _cffi_d_ENGINE_free(ENGINE * x0)
{
  return ENGINE_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_free(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_free _cffi_d_ENGINE_free
#endif

static DH_METHOD const * _cffi_d_ENGINE_get_DH(ENGINE const * x0)
{
  return ENGINE_get_DH(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_DH(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  DH_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_DH(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1732));
}
#else
#  define _cffi_f_ENGINE_get_DH _cffi_d_ENGINE_get_DH
#endif

static DSA_METHOD const * _cffi_d_ENGINE_get_DSA(ENGINE const * x0)
{
  return ENGINE_get_DSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_DSA(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  DSA_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_DSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1736));
}
#else
#  define _cffi_f_ENGINE_get_DSA _cffi_d_ENGINE_get_DSA
#endif

static RAND_METHOD const * _cffi_d_ENGINE_get_RAND(ENGINE const * x0)
{
  return ENGINE_get_RAND(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_RAND(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  RAND_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_RAND(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1760));
}
#else
#  define _cffi_f_ENGINE_get_RAND _cffi_d_ENGINE_get_RAND
#endif

static RSA_METHOD const * _cffi_d_ENGINE_get_RSA(ENGINE const * x0)
{
  return ENGINE_get_RSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_RSA(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  RSA_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_RSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1764));
}
#else
#  define _cffi_f_ENGINE_get_RSA _cffi_d_ENGINE_get_RSA
#endif

static EVP_CIPHER const * _cffi_d_ENGINE_get_cipher(ENGINE * x0, int x1)
{
  return ENGINE_get_cipher(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_cipher(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int x1;
  Py_ssize_t datasize;
  EVP_CIPHER const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_get_cipher", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_cipher(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(212));
}
#else
#  define _cffi_f_ENGINE_get_cipher _cffi_d_ENGINE_get_cipher
#endif

static ENGINE * _cffi_d_ENGINE_get_cipher_engine(int x0)
{
  return ENGINE_get_cipher_engine(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_cipher_engine(PyObject *self, PyObject *arg0)
{
  int x0;
  ENGINE * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_cipher_engine(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_cipher_engine _cffi_d_ENGINE_get_cipher_engine
#endif

static ENGINE_CMD_DEFN const * _cffi_d_ENGINE_get_cmd_defns(ENGINE const * x0)
{
  return ENGINE_get_cmd_defns(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_cmd_defns(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  ENGINE_CMD_DEFN const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_cmd_defns(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1744));
}
#else
#  define _cffi_f_ENGINE_get_cmd_defns _cffi_d_ENGINE_get_cmd_defns
#endif

static ENGINE * _cffi_d_ENGINE_get_default_DH(void)
{
  return ENGINE_get_default_DH();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_default_DH(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_default_DH(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_default_DH _cffi_d_ENGINE_get_default_DH
#endif

static ENGINE * _cffi_d_ENGINE_get_default_DSA(void)
{
  return ENGINE_get_default_DSA();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_default_DSA(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_default_DSA(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_default_DSA _cffi_d_ENGINE_get_default_DSA
#endif

static ENGINE * _cffi_d_ENGINE_get_default_RAND(void)
{
  return ENGINE_get_default_RAND();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_default_RAND(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_default_RAND(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_default_RAND _cffi_d_ENGINE_get_default_RAND
#endif

static ENGINE * _cffi_d_ENGINE_get_default_RSA(void)
{
  return ENGINE_get_default_RSA();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_default_RSA(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_default_RSA(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_default_RSA _cffi_d_ENGINE_get_default_RSA
#endif

static EVP_MD const * _cffi_d_ENGINE_get_digest(ENGINE * x0, int x1)
{
  return ENGINE_get_digest(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_digest(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int x1;
  Py_ssize_t datasize;
  EVP_MD const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_get_digest", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_digest(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_ENGINE_get_digest _cffi_d_ENGINE_get_digest
#endif

static ENGINE * _cffi_d_ENGINE_get_digest_engine(int x0)
{
  return ENGINE_get_digest_engine(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_digest_engine(PyObject *self, PyObject *arg0)
{
  int x0;
  ENGINE * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_digest_engine(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_digest_engine _cffi_d_ENGINE_get_digest_engine
#endif

static ENGINE * _cffi_d_ENGINE_get_first(void)
{
  return ENGINE_get_first();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_first(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_first(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_first _cffi_d_ENGINE_get_first
#endif

static int _cffi_d_ENGINE_get_flags(ENGINE const * x0)
{
  return ENGINE_get_flags(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_flags(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_flags(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_get_flags _cffi_d_ENGINE_get_flags
#endif

static char const * _cffi_d_ENGINE_get_id(ENGINE const * x0)
{
  return ENGINE_get_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_id(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_ENGINE_get_id _cffi_d_ENGINE_get_id
#endif

static ENGINE * _cffi_d_ENGINE_get_last(void)
{
  return ENGINE_get_last();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_last(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_last(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_last _cffi_d_ENGINE_get_last
#endif

static char const * _cffi_d_ENGINE_get_name(ENGINE const * x0)
{
  return ENGINE_get_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_name(PyObject *self, PyObject *arg0)
{
  ENGINE const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(307), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(307), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_ENGINE_get_name _cffi_d_ENGINE_get_name
#endif

static ENGINE * _cffi_d_ENGINE_get_next(ENGINE * x0)
{
  return ENGINE_get_next(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_next(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  ENGINE * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_next(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_next _cffi_d_ENGINE_get_next
#endif

static ENGINE * _cffi_d_ENGINE_get_prev(ENGINE * x0)
{
  return ENGINE_get_prev(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_prev(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  ENGINE * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_prev(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_get_prev _cffi_d_ENGINE_get_prev
#endif

static unsigned int _cffi_d_ENGINE_get_table_flags(void)
{
  return ENGINE_get_table_flags();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_get_table_flags(PyObject *self, PyObject *noarg)
{
  unsigned int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_get_table_flags(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_ENGINE_get_table_flags _cffi_d_ENGINE_get_table_flags
#endif

static int _cffi_d_ENGINE_init(ENGINE * x0)
{
  return ENGINE_init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_init(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_init _cffi_d_ENGINE_init
#endif

static void _cffi_d_ENGINE_load_builtin_engines(void)
{
  ENGINE_load_builtin_engines();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_load_builtin_engines(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_load_builtin_engines(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_load_builtin_engines _cffi_d_ENGINE_load_builtin_engines
#endif

static void _cffi_d_ENGINE_load_cryptodev(void)
{
  ENGINE_load_cryptodev();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_load_cryptodev(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_load_cryptodev(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_load_cryptodev _cffi_d_ENGINE_load_cryptodev
#endif

static void _cffi_d_ENGINE_load_dynamic(void)
{
  ENGINE_load_dynamic();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_load_dynamic(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_load_dynamic(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_load_dynamic _cffi_d_ENGINE_load_dynamic
#endif

static void _cffi_d_ENGINE_load_openssl(void)
{
  ENGINE_load_openssl();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_load_openssl(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_load_openssl(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_load_openssl _cffi_d_ENGINE_load_openssl
#endif

static EVP_PKEY * _cffi_d_ENGINE_load_private_key(ENGINE * x0, char const * x1, UI_METHOD * x2, void * x3)
{
  return ENGINE_load_private_key(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_load_private_key(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  UI_METHOD * x2;
  void * x3;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ENGINE_load_private_key", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(489), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (UI_METHOD *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(489), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_load_private_key(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_ENGINE_load_private_key _cffi_d_ENGINE_load_private_key
#endif

static EVP_PKEY * _cffi_d_ENGINE_load_public_key(ENGINE * x0, char const * x1, UI_METHOD * x2, void * x3)
{
  return ENGINE_load_public_key(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_load_public_key(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  UI_METHOD * x2;
  void * x3;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ENGINE_load_public_key", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(489), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (UI_METHOD *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(489), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_load_public_key(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_ENGINE_load_public_key _cffi_d_ENGINE_load_public_key
#endif

static ENGINE * _cffi_d_ENGINE_new(void)
{
  return ENGINE_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_new(PyObject *self, PyObject *noarg)
{
  ENGINE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(435));
}
#else
#  define _cffi_f_ENGINE_new _cffi_d_ENGINE_new
#endif

static int _cffi_d_ENGINE_register_DH(ENGINE * x0)
{
  return ENGINE_register_DH(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_DH(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_DH(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_DH _cffi_d_ENGINE_register_DH
#endif

static int _cffi_d_ENGINE_register_DSA(ENGINE * x0)
{
  return ENGINE_register_DSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_DSA(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_DSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_DSA _cffi_d_ENGINE_register_DSA
#endif

static int _cffi_d_ENGINE_register_RAND(ENGINE * x0)
{
  return ENGINE_register_RAND(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_RAND(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_RAND(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_RAND _cffi_d_ENGINE_register_RAND
#endif

static int _cffi_d_ENGINE_register_RSA(ENGINE * x0)
{
  return ENGINE_register_RSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_RSA(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_RSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_RSA _cffi_d_ENGINE_register_RSA
#endif

static void _cffi_d_ENGINE_register_all_DH(void)
{
  ENGINE_register_all_DH();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_DH(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_register_all_DH(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_register_all_DH _cffi_d_ENGINE_register_all_DH
#endif

static void _cffi_d_ENGINE_register_all_DSA(void)
{
  ENGINE_register_all_DSA();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_DSA(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_register_all_DSA(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_register_all_DSA _cffi_d_ENGINE_register_all_DSA
#endif

static void _cffi_d_ENGINE_register_all_RAND(void)
{
  ENGINE_register_all_RAND();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_RAND(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_register_all_RAND(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_register_all_RAND _cffi_d_ENGINE_register_all_RAND
#endif

static void _cffi_d_ENGINE_register_all_RSA(void)
{
  ENGINE_register_all_RSA();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_RSA(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_register_all_RSA(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_register_all_RSA _cffi_d_ENGINE_register_all_RSA
#endif

static void _cffi_d_ENGINE_register_all_ciphers(void)
{
  ENGINE_register_all_ciphers();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_ciphers(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_register_all_ciphers(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_register_all_ciphers _cffi_d_ENGINE_register_all_ciphers
#endif

static int _cffi_d_ENGINE_register_all_complete(void)
{
  return ENGINE_register_all_complete();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_complete(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_all_complete(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_all_complete _cffi_d_ENGINE_register_all_complete
#endif

static void _cffi_d_ENGINE_register_all_digests(void)
{
  ENGINE_register_all_digests();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_all_digests(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_register_all_digests(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_register_all_digests _cffi_d_ENGINE_register_all_digests
#endif

static int _cffi_d_ENGINE_register_ciphers(ENGINE * x0)
{
  return ENGINE_register_ciphers(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_ciphers(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_ciphers(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_ciphers _cffi_d_ENGINE_register_ciphers
#endif

static int _cffi_d_ENGINE_register_complete(ENGINE * x0)
{
  return ENGINE_register_complete(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_complete(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_complete(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_complete _cffi_d_ENGINE_register_complete
#endif

static int _cffi_d_ENGINE_register_digests(ENGINE * x0)
{
  return ENGINE_register_digests(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_register_digests(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_register_digests(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_register_digests _cffi_d_ENGINE_register_digests
#endif

static int _cffi_d_ENGINE_remove(ENGINE * x0)
{
  return ENGINE_remove(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_remove(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_remove(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_remove _cffi_d_ENGINE_remove
#endif

static int _cffi_d_ENGINE_set_DH(ENGINE * x0, DH_METHOD const * x1)
{
  return ENGINE_set_DH(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_DH(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  DH_METHOD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_DH", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1732), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH_METHOD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1732), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_DH(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_DH _cffi_d_ENGINE_set_DH
#endif

static int _cffi_d_ENGINE_set_DSA(ENGINE * x0, DSA_METHOD const * x1)
{
  return ENGINE_set_DSA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_DSA(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  DSA_METHOD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_DSA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1736), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA_METHOD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1736), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_DSA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_DSA _cffi_d_ENGINE_set_DSA
#endif

static int _cffi_d_ENGINE_set_RAND(ENGINE * x0, RAND_METHOD const * x1)
{
  return ENGINE_set_RAND(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_RAND(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  RAND_METHOD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_RAND", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1760), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RAND_METHOD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1760), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_RAND(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_RAND _cffi_d_ENGINE_set_RAND
#endif

static int _cffi_d_ENGINE_set_RSA(ENGINE * x0, RSA_METHOD const * x1)
{
  return ENGINE_set_RSA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_RSA(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  RSA_METHOD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_RSA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1764), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA_METHOD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1764), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_RSA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_RSA _cffi_d_ENGINE_set_RSA
#endif

static int _cffi_d_ENGINE_set_ciphers(ENGINE * x0, ENGINE_CIPHERS_PTR x1)
{
  return ENGINE_set_ciphers(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_ciphers(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  ENGINE_CIPHERS_PTR x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_ciphers", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1740), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE_CIPHERS_PTR)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1740), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_ciphers(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_ciphers _cffi_d_ENGINE_set_ciphers
#endif

static int _cffi_d_ENGINE_set_cmd_defns(ENGINE * x0, ENGINE_CMD_DEFN const * x1)
{
  return ENGINE_set_cmd_defns(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_cmd_defns(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  ENGINE_CMD_DEFN const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_cmd_defns", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1744), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE_CMD_DEFN const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1744), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_cmd_defns(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_cmd_defns _cffi_d_ENGINE_set_cmd_defns
#endif

static int _cffi_d_ENGINE_set_ctrl_function(ENGINE * x0, ENGINE_CTRL_FUNC_PTR x1)
{
  return ENGINE_set_ctrl_function(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_ctrl_function(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  ENGINE_CTRL_FUNC_PTR x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_ctrl_function", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1748), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE_CTRL_FUNC_PTR)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1748), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_ctrl_function(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_ctrl_function _cffi_d_ENGINE_set_ctrl_function
#endif

static int _cffi_d_ENGINE_set_default(ENGINE * x0, unsigned int x1)
{
  return ENGINE_set_default(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  unsigned int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_default", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned int);
  if (x1 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default _cffi_d_ENGINE_set_default
#endif

static int _cffi_d_ENGINE_set_default_DH(ENGINE * x0)
{
  return ENGINE_set_default_DH(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_DH(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_DH(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_DH _cffi_d_ENGINE_set_default_DH
#endif

static int _cffi_d_ENGINE_set_default_DSA(ENGINE * x0)
{
  return ENGINE_set_default_DSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_DSA(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_DSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_DSA _cffi_d_ENGINE_set_default_DSA
#endif

static int _cffi_d_ENGINE_set_default_RAND(ENGINE * x0)
{
  return ENGINE_set_default_RAND(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_RAND(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_RAND(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_RAND _cffi_d_ENGINE_set_default_RAND
#endif

static int _cffi_d_ENGINE_set_default_RSA(ENGINE * x0)
{
  return ENGINE_set_default_RSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_RSA(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_RSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_RSA _cffi_d_ENGINE_set_default_RSA
#endif

static int _cffi_d_ENGINE_set_default_ciphers(ENGINE * x0)
{
  return ENGINE_set_default_ciphers(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_ciphers(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_ciphers(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_ciphers _cffi_d_ENGINE_set_default_ciphers
#endif

static int _cffi_d_ENGINE_set_default_digests(ENGINE * x0)
{
  return ENGINE_set_default_digests(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_digests(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_digests(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_digests _cffi_d_ENGINE_set_default_digests
#endif

static int _cffi_d_ENGINE_set_default_string(ENGINE * x0, char const * x1)
{
  return ENGINE_set_default_string(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_default_string(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_default_string", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_default_string(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_default_string _cffi_d_ENGINE_set_default_string
#endif

static int _cffi_d_ENGINE_set_destroy_function(ENGINE * x0, int(* x1)(ENGINE *))
{
  return ENGINE_set_destroy_function(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_destroy_function(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int(* x1)(ENGINE *);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_destroy_function", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(ENGINE *))_cffi_to_c_pointer(arg1, _cffi_type(1786));
  if (x1 == (int(*)(ENGINE *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_destroy_function(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_destroy_function _cffi_d_ENGINE_set_destroy_function
#endif

static int _cffi_d_ENGINE_set_digests(ENGINE * x0, ENGINE_DIGESTS_PTR x1)
{
  return ENGINE_set_digests(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_digests(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  ENGINE_DIGESTS_PTR x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_digests", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1752), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE_DIGESTS_PTR)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1752), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_digests(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_digests _cffi_d_ENGINE_set_digests
#endif

static int _cffi_d_ENGINE_set_finish_function(ENGINE * x0, int(* x1)(ENGINE *))
{
  return ENGINE_set_finish_function(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_finish_function(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int(* x1)(ENGINE *);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_finish_function", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(ENGINE *))_cffi_to_c_pointer(arg1, _cffi_type(1786));
  if (x1 == (int(*)(ENGINE *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_finish_function(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_finish_function _cffi_d_ENGINE_set_finish_function
#endif

static int _cffi_d_ENGINE_set_flags(ENGINE * x0, int x1)
{
  return ENGINE_set_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_flags(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_flags _cffi_d_ENGINE_set_flags
#endif

static int _cffi_d_ENGINE_set_id(ENGINE * x0, char const * x1)
{
  return ENGINE_set_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_id(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_id _cffi_d_ENGINE_set_id
#endif

static int _cffi_d_ENGINE_set_init_function(ENGINE * x0, int(* x1)(ENGINE *))
{
  return ENGINE_set_init_function(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_init_function(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  int(* x1)(ENGINE *);
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_init_function", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(ENGINE *))_cffi_to_c_pointer(arg1, _cffi_type(1786));
  if (x1 == (int(*)(ENGINE *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_init_function(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_init_function _cffi_d_ENGINE_set_init_function
#endif

static int _cffi_d_ENGINE_set_load_privkey_function(ENGINE * x0, ENGINE_LOAD_KEY_PTR x1)
{
  return ENGINE_set_load_privkey_function(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_load_privkey_function(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  ENGINE_LOAD_KEY_PTR x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_load_privkey_function", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1756), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE_LOAD_KEY_PTR)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1756), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_load_privkey_function(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_load_privkey_function _cffi_d_ENGINE_set_load_privkey_function
#endif

static int _cffi_d_ENGINE_set_load_pubkey_function(ENGINE * x0, ENGINE_LOAD_KEY_PTR x1)
{
  return ENGINE_set_load_pubkey_function(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_load_pubkey_function(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  ENGINE_LOAD_KEY_PTR x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_load_pubkey_function", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1756), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE_LOAD_KEY_PTR)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1756), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_load_pubkey_function(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_load_pubkey_function _cffi_d_ENGINE_set_load_pubkey_function
#endif

static int _cffi_d_ENGINE_set_name(ENGINE * x0, char const * x1)
{
  return ENGINE_set_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_name(PyObject *self, PyObject *args)
{
  ENGINE * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ENGINE_set_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_set_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_set_name _cffi_d_ENGINE_set_name
#endif

static void _cffi_d_ENGINE_set_table_flags(unsigned int x0)
{
  ENGINE_set_table_flags(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_set_table_flags(PyObject *self, PyObject *arg0)
{
  unsigned int x0;

  x0 = _cffi_to_c_int(arg0, unsigned int);
  if (x0 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_set_table_flags(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_set_table_flags _cffi_d_ENGINE_set_table_flags
#endif

static void _cffi_d_ENGINE_unregister_DH(ENGINE * x0)
{
  ENGINE_unregister_DH(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_unregister_DH(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_unregister_DH(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_unregister_DH _cffi_d_ENGINE_unregister_DH
#endif

static void _cffi_d_ENGINE_unregister_DSA(ENGINE * x0)
{
  ENGINE_unregister_DSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_unregister_DSA(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_unregister_DSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_unregister_DSA _cffi_d_ENGINE_unregister_DSA
#endif

static void _cffi_d_ENGINE_unregister_RAND(ENGINE * x0)
{
  ENGINE_unregister_RAND(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_unregister_RAND(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_unregister_RAND(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_unregister_RAND _cffi_d_ENGINE_unregister_RAND
#endif

static void _cffi_d_ENGINE_unregister_RSA(ENGINE * x0)
{
  ENGINE_unregister_RSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_unregister_RSA(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_unregister_RSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_unregister_RSA _cffi_d_ENGINE_unregister_RSA
#endif

static void _cffi_d_ENGINE_unregister_ciphers(ENGINE * x0)
{
  ENGINE_unregister_ciphers(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_unregister_ciphers(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_unregister_ciphers(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_unregister_ciphers _cffi_d_ENGINE_unregister_ciphers
#endif

static void _cffi_d_ENGINE_unregister_digests(ENGINE * x0)
{
  ENGINE_unregister_digests(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_unregister_digests(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ENGINE_unregister_digests(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ENGINE_unregister_digests _cffi_d_ENGINE_unregister_digests
#endif

static int _cffi_d_ENGINE_up_ref(ENGINE * x0)
{
  return ENGINE_up_ref(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ENGINE_up_ref(PyObject *self, PyObject *arg0)
{
  ENGINE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(435), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ENGINE_up_ref(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ENGINE_up_ref _cffi_d_ENGINE_up_ref
#endif

static int _cffi_d_ERR_GET_FUNC(unsigned long x0)
{
  return ERR_GET_FUNC(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_GET_FUNC(PyObject *self, PyObject *arg0)
{
  unsigned long x0;
  int result;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_GET_FUNC(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ERR_GET_FUNC _cffi_d_ERR_GET_FUNC
#endif

static int _cffi_d_ERR_GET_LIB(unsigned long x0)
{
  return ERR_GET_LIB(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_GET_LIB(PyObject *self, PyObject *arg0)
{
  unsigned long x0;
  int result;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_GET_LIB(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ERR_GET_LIB _cffi_d_ERR_GET_LIB
#endif

static int _cffi_d_ERR_GET_REASON(unsigned long x0)
{
  return ERR_GET_REASON(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_GET_REASON(PyObject *self, PyObject *arg0)
{
  unsigned long x0;
  int result;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_GET_REASON(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ERR_GET_REASON _cffi_d_ERR_GET_REASON
#endif

static unsigned long _cffi_d_ERR_PACK(int x0, int x1, int x2)
{
  return ERR_PACK(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_PACK(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  int x2;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ERR_PACK", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_PACK(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_PACK _cffi_d_ERR_PACK
#endif

static void _cffi_const_ERR_add_error_data(char *o)
{
  *(void(* *)(int, ...))o = ERR_add_error_data;
}

static void _cffi_d_ERR_clear_error(void)
{
  ERR_clear_error();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_clear_error(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_clear_error(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_clear_error _cffi_d_ERR_clear_error
#endif

static char * _cffi_d_ERR_error_string(unsigned long x0, char * x1)
{
  return ERR_error_string(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_error_string(PyObject *self, PyObject *args)
{
  unsigned long x0;
  char * x1;
  Py_ssize_t datasize;
  char * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ERR_error_string", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_error_string(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_ERR_error_string _cffi_d_ERR_error_string
#endif

static void _cffi_d_ERR_error_string_n(unsigned long x0, char * x1, size_t x2)
{
  ERR_error_string_n(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_error_string_n(PyObject *self, PyObject *args)
{
  unsigned long x0;
  char * x1;
  size_t x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ERR_error_string_n", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_error_string_n(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_error_string_n _cffi_d_ERR_error_string_n
#endif

static void _cffi_d_ERR_free_strings(void)
{
  ERR_free_strings();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_free_strings(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_free_strings(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_free_strings _cffi_d_ERR_free_strings
#endif

static char const * _cffi_d_ERR_func_error_string(unsigned long x0)
{
  return ERR_func_error_string(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_func_error_string(PyObject *self, PyObject *arg0)
{
  unsigned long x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_func_error_string(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_ERR_func_error_string _cffi_d_ERR_func_error_string
#endif

static unsigned long _cffi_d_ERR_get_error(void)
{
  return ERR_get_error();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_get_error(PyObject *self, PyObject *noarg)
{
  unsigned long result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_get_error(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_get_error _cffi_d_ERR_get_error
#endif

static unsigned long _cffi_d_ERR_get_error_line(char const * * x0, int * x1)
{
  return ERR_get_error_line(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_get_error_line(PyObject *self, PyObject *args)
{
  char const * * x0;
  int * x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ERR_get_error_line", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3055), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_get_error_line(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_get_error_line _cffi_d_ERR_get_error_line
#endif

static unsigned long _cffi_d_ERR_get_error_line_data(char const * * x0, int * x1, char const * * x2, int * x3)
{
  return ERR_get_error_line_data(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_get_error_line_data(PyObject *self, PyObject *args)
{
  char const * * x0;
  int * x1;
  char const * * x2;
  int * x3;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ERR_get_error_line_data", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3055), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(3055), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (int *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1509), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_get_error_line_data(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_get_error_line_data _cffi_d_ERR_get_error_line_data
#endif

static int _cffi_d_ERR_get_next_error_library(void)
{
  return ERR_get_next_error_library();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_get_next_error_library(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_get_next_error_library(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_ERR_get_next_error_library _cffi_d_ERR_get_next_error_library
#endif

static ERR_STATE * _cffi_d_ERR_get_state(void)
{
  return ERR_get_state();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_get_state(PyObject *self, PyObject *noarg)
{
  ERR_STATE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_get_state(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3702));
}
#else
#  define _cffi_f_ERR_get_state _cffi_d_ERR_get_state
#endif

static char const * _cffi_d_ERR_lib_error_string(unsigned long x0)
{
  return ERR_lib_error_string(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_lib_error_string(PyObject *self, PyObject *arg0)
{
  unsigned long x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_lib_error_string(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_ERR_lib_error_string _cffi_d_ERR_lib_error_string
#endif

static void _cffi_d_ERR_load_RAND_strings(void)
{
  ERR_load_RAND_strings();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_load_RAND_strings(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_load_RAND_strings(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_load_RAND_strings _cffi_d_ERR_load_RAND_strings
#endif

static unsigned long _cffi_d_ERR_peek_error(void)
{
  return ERR_peek_error();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_peek_error(PyObject *self, PyObject *noarg)
{
  unsigned long result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_peek_error(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_peek_error _cffi_d_ERR_peek_error
#endif

static unsigned long _cffi_d_ERR_peek_error_line(char const * * x0, int * x1)
{
  return ERR_peek_error_line(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_peek_error_line(PyObject *self, PyObject *args)
{
  char const * * x0;
  int * x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ERR_peek_error_line", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3055), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_peek_error_line(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_peek_error_line _cffi_d_ERR_peek_error_line
#endif

static unsigned long _cffi_d_ERR_peek_error_line_data(char const * * x0, int * x1, char const * * x2, int * x3)
{
  return ERR_peek_error_line_data(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_peek_error_line_data(PyObject *self, PyObject *args)
{
  char const * * x0;
  int * x1;
  char const * * x2;
  int * x3;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ERR_peek_error_line_data", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3055), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(3055), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (int *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1509), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_peek_error_line_data(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_peek_error_line_data _cffi_d_ERR_peek_error_line_data
#endif

static unsigned long _cffi_d_ERR_peek_last_error(void)
{
  return ERR_peek_last_error();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_peek_last_error(PyObject *self, PyObject *noarg)
{
  unsigned long result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_peek_last_error(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_peek_last_error _cffi_d_ERR_peek_last_error
#endif

static unsigned long _cffi_d_ERR_peek_last_error_line(char const * * x0, int * x1)
{
  return ERR_peek_last_error_line(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_peek_last_error_line(PyObject *self, PyObject *args)
{
  char const * * x0;
  int * x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ERR_peek_last_error_line", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3055), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_peek_last_error_line(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_peek_last_error_line _cffi_d_ERR_peek_last_error_line
#endif

static unsigned long _cffi_d_ERR_peek_last_error_line_data(char const * * x0, int * x1, char const * * x2, int * x3)
{
  return ERR_peek_last_error_line_data(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_peek_last_error_line_data(PyObject *self, PyObject *args)
{
  char const * * x0;
  int * x1;
  char const * * x2;
  int * x3;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "ERR_peek_last_error_line_data", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3055), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3055), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(3055), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (int *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1509), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_peek_last_error_line_data(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_ERR_peek_last_error_line_data _cffi_d_ERR_peek_last_error_line_data
#endif

static void _cffi_d_ERR_print_errors(BIO * x0)
{
  ERR_print_errors(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_print_errors(PyObject *self, PyObject *arg0)
{
  BIO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_print_errors(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_print_errors _cffi_d_ERR_print_errors
#endif

static void _cffi_d_ERR_print_errors_fp(FILE * x0)
{
  ERR_print_errors_fp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_print_errors_fp(PyObject *self, PyObject *arg0)
{
  FILE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(178), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(178), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_print_errors_fp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_print_errors_fp _cffi_d_ERR_print_errors_fp
#endif

static void _cffi_d_ERR_put_error(int x0, int x1, int x2, char const * x3, int x4)
{
  ERR_put_error(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_put_error(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  int x2;
  char const * x3;
  int x4;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "ERR_put_error", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(57), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ERR_put_error(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ERR_put_error _cffi_d_ERR_put_error
#endif

static char const * _cffi_d_ERR_reason_error_string(unsigned long x0)
{
  return ERR_reason_error_string(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ERR_reason_error_string(PyObject *self, PyObject *arg0)
{
  unsigned long x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, unsigned long);
  if (x0 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ERR_reason_error_string(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_ERR_reason_error_string _cffi_d_ERR_reason_error_string
#endif

static int _cffi_d_EVP_CIPHER_CTX_block_size(EVP_CIPHER_CTX const * x0)
{
  return EVP_CIPHER_CTX_block_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_block_size(PyObject *self, PyObject *arg0)
{
  EVP_CIPHER_CTX const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(455), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(455), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_block_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_block_size _cffi_d_EVP_CIPHER_CTX_block_size
#endif

static EVP_CIPHER const * _cffi_d_EVP_CIPHER_CTX_cipher(EVP_CIPHER_CTX const * x0)
{
  return EVP_CIPHER_CTX_cipher(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_cipher(PyObject *self, PyObject *arg0)
{
  EVP_CIPHER_CTX const * x0;
  Py_ssize_t datasize;
  EVP_CIPHER const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(455), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(455), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_cipher(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(212));
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_cipher _cffi_d_EVP_CIPHER_CTX_cipher
#endif

static int _cffi_d_EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX * x0)
{
  return EVP_CIPHER_CTX_cleanup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_cleanup(PyObject *self, PyObject *arg0)
{
  EVP_CIPHER_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_cleanup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_cleanup _cffi_d_EVP_CIPHER_CTX_cleanup
#endif

static int _cffi_d_EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX * x0, int x1, int x2, void * x3)
{
  return EVP_CIPHER_CTX_ctrl(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_ctrl(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  int x1;
  int x2;
  void * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EVP_CIPHER_CTX_ctrl", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_ctrl(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_ctrl _cffi_d_EVP_CIPHER_CTX_ctrl
#endif

static void _cffi_d_EVP_CIPHER_CTX_free(EVP_CIPHER_CTX * x0)
{
  EVP_CIPHER_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_free(PyObject *self, PyObject *arg0)
{
  EVP_CIPHER_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EVP_CIPHER_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_free _cffi_d_EVP_CIPHER_CTX_free
#endif

static void _cffi_d_EVP_CIPHER_CTX_init(EVP_CIPHER_CTX * x0)
{
  EVP_CIPHER_CTX_init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_init(PyObject *self, PyObject *arg0)
{
  EVP_CIPHER_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EVP_CIPHER_CTX_init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_init _cffi_d_EVP_CIPHER_CTX_init
#endif

static EVP_CIPHER_CTX * _cffi_d_EVP_CIPHER_CTX_new(void)
{
  return EVP_CIPHER_CTX_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_new(PyObject *self, PyObject *noarg)
{
  EVP_CIPHER_CTX * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1810));
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_new _cffi_d_EVP_CIPHER_CTX_new
#endif

static int _cffi_d_EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX * x0, int x1)
{
  return EVP_CIPHER_CTX_set_key_length(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_set_key_length(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_CIPHER_CTX_set_key_length", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_set_key_length(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_set_key_length _cffi_d_EVP_CIPHER_CTX_set_key_length
#endif

static int _cffi_d_EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX * x0, int x1)
{
  return EVP_CIPHER_CTX_set_padding(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_CTX_set_padding(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_CIPHER_CTX_set_padding", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_CTX_set_padding(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CIPHER_CTX_set_padding _cffi_d_EVP_CIPHER_CTX_set_padding
#endif

static int _cffi_d_EVP_CIPHER_block_size(EVP_CIPHER const * x0)
{
  return EVP_CIPHER_block_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CIPHER_block_size(PyObject *self, PyObject *arg0)
{
  EVP_CIPHER const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(212), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CIPHER_block_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CIPHER_block_size _cffi_d_EVP_CIPHER_block_size
#endif

static int _cffi_d_EVP_CipherFinal_ex(EVP_CIPHER_CTX * x0, unsigned char * x1, int * x2)
{
  return EVP_CipherFinal_ex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CipherFinal_ex(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  unsigned char * x1;
  int * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_CipherFinal_ex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CipherFinal_ex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CipherFinal_ex _cffi_d_EVP_CipherFinal_ex
#endif

static int _cffi_d_EVP_CipherInit_ex(EVP_CIPHER_CTX * x0, EVP_CIPHER const * x1, ENGINE * x2, unsigned char const * x3, unsigned char const * x4, int x5)
{
  return EVP_CipherInit_ex(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CipherInit_ex(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  EVP_CIPHER const * x1;
  ENGINE * x2;
  unsigned char const * x3;
  unsigned char const * x4;
  int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "EVP_CipherInit_ex", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(212), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(435), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(148), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CipherInit_ex(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CipherInit_ex _cffi_d_EVP_CipherInit_ex
#endif

static int _cffi_d_EVP_CipherUpdate(EVP_CIPHER_CTX * x0, unsigned char * x1, int * x2, unsigned char const * x3, int x4)
{
  return EVP_CipherUpdate(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_CipherUpdate(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  unsigned char * x1;
  int * x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_CipherUpdate", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_CipherUpdate(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_CipherUpdate _cffi_d_EVP_CipherUpdate
#endif

static int _cffi_d_EVP_DecryptFinal_ex(EVP_CIPHER_CTX * x0, unsigned char * x1, int * x2)
{
  return EVP_DecryptFinal_ex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_DecryptFinal_ex(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  unsigned char * x1;
  int * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_DecryptFinal_ex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_DecryptFinal_ex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_DecryptFinal_ex _cffi_d_EVP_DecryptFinal_ex
#endif

static int _cffi_d_EVP_DecryptInit_ex(EVP_CIPHER_CTX * x0, EVP_CIPHER const * x1, ENGINE * x2, unsigned char const * x3, unsigned char const * x4)
{
  return EVP_DecryptInit_ex(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_DecryptInit_ex(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  EVP_CIPHER const * x1;
  ENGINE * x2;
  unsigned char const * x3;
  unsigned char const * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_DecryptInit_ex", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(212), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(435), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(148), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_DecryptInit_ex(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_DecryptInit_ex _cffi_d_EVP_DecryptInit_ex
#endif

static int _cffi_d_EVP_DecryptUpdate(EVP_CIPHER_CTX * x0, unsigned char * x1, int * x2, unsigned char const * x3, int x4)
{
  return EVP_DecryptUpdate(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_DecryptUpdate(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  unsigned char * x1;
  int * x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_DecryptUpdate", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_DecryptUpdate(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_DecryptUpdate _cffi_d_EVP_DecryptUpdate
#endif

static int _cffi_d_EVP_DigestFinal_ex(EVP_MD_CTX * x0, unsigned char * x1, unsigned int * x2)
{
  return EVP_DigestFinal_ex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_DigestFinal_ex(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  unsigned char * x1;
  unsigned int * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_DigestFinal_ex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1871), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_DigestFinal_ex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_DigestFinal_ex _cffi_d_EVP_DigestFinal_ex
#endif

static int _cffi_d_EVP_DigestInit_ex(EVP_MD_CTX * x0, EVP_MD const * x1, ENGINE * x2)
{
  return EVP_DigestInit_ex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_DigestInit_ex(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  EVP_MD const * x1;
  ENGINE * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_DigestInit_ex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(226), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(435), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_DigestInit_ex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_DigestInit_ex _cffi_d_EVP_DigestInit_ex
#endif

static int _cffi_d_EVP_DigestUpdate(EVP_MD_CTX * x0, void const * x1, size_t x2)
{
  return EVP_DigestUpdate(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_DigestUpdate(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  void const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_DigestUpdate", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_DigestUpdate(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_DigestUpdate _cffi_d_EVP_DigestUpdate
#endif

static int _cffi_d_EVP_EncryptFinal_ex(EVP_CIPHER_CTX * x0, unsigned char * x1, int * x2)
{
  return EVP_EncryptFinal_ex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_EncryptFinal_ex(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  unsigned char * x1;
  int * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_EncryptFinal_ex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_EncryptFinal_ex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_EncryptFinal_ex _cffi_d_EVP_EncryptFinal_ex
#endif

static int _cffi_d_EVP_EncryptInit_ex(EVP_CIPHER_CTX * x0, EVP_CIPHER const * x1, ENGINE * x2, unsigned char const * x3, unsigned char const * x4)
{
  return EVP_EncryptInit_ex(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_EncryptInit_ex(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  EVP_CIPHER const * x1;
  ENGINE * x2;
  unsigned char const * x3;
  unsigned char const * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_EncryptInit_ex", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(212), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(435), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(148), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_EncryptInit_ex(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_EncryptInit_ex _cffi_d_EVP_EncryptInit_ex
#endif

static int _cffi_d_EVP_EncryptUpdate(EVP_CIPHER_CTX * x0, unsigned char * x1, int * x2, unsigned char const * x3, int x4)
{
  return EVP_EncryptUpdate(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_EncryptUpdate(PyObject *self, PyObject *args)
{
  EVP_CIPHER_CTX * x0;
  unsigned char * x1;
  int * x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_EncryptUpdate", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_CIPHER_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_EncryptUpdate(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_EncryptUpdate _cffi_d_EVP_EncryptUpdate
#endif

static int _cffi_d_EVP_MD_CTX_block_size(EVP_MD_CTX const * x0)
{
  return EVP_MD_CTX_block_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_MD_CTX_block_size(PyObject *self, PyObject *arg0)
{
  EVP_MD_CTX const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(467), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(467), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_MD_CTX_block_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_MD_CTX_block_size _cffi_d_EVP_MD_CTX_block_size
#endif

static int _cffi_d_EVP_MD_CTX_copy_ex(EVP_MD_CTX * x0, EVP_MD_CTX const * x1)
{
  return EVP_MD_CTX_copy_ex(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_MD_CTX_copy_ex(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  EVP_MD_CTX const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_MD_CTX_copy_ex", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(467), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD_CTX const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(467), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_MD_CTX_copy_ex(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_MD_CTX_copy_ex _cffi_d_EVP_MD_CTX_copy_ex
#endif

static EVP_MD const * _cffi_d_EVP_MD_CTX_md(EVP_MD_CTX const * x0)
{
  return EVP_MD_CTX_md(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_MD_CTX_md(PyObject *self, PyObject *arg0)
{
  EVP_MD_CTX const * x0;
  Py_ssize_t datasize;
  EVP_MD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(467), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(467), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_MD_CTX_md(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_MD_CTX_md _cffi_d_EVP_MD_CTX_md
#endif

static int _cffi_d_EVP_MD_size(EVP_MD const * x0)
{
  return EVP_MD_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_MD_size(PyObject *self, PyObject *arg0)
{
  EVP_MD const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(226), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_MD_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_MD_size _cffi_d_EVP_MD_size
#endif

static int _cffi_d_EVP_PBE_scrypt(char const * x0, size_t x1, unsigned char const * x2, size_t x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t x7, unsigned char * x8, size_t x9)
{
  return EVP_PBE_scrypt(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PBE_scrypt(PyObject *self, PyObject *args)
{
  char const * x0;
  size_t x1;
  unsigned char const * x2;
  size_t x3;
  uint64_t x4;
  uint64_t x5;
  uint64_t x6;
  uint64_t x7;
  unsigned char * x8;
  size_t x9;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;

  if (!PyArg_UnpackTuple(args, "EVP_PBE_scrypt", 10, 10, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, size_t);
  if (x3 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, uint64_t);
  if (x5 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, uint64_t);
  if (x6 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x7 = _cffi_to_c_int(arg7, uint64_t);
  if (x7 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(975), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, size_t);
  if (x9 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PBE_scrypt(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PBE_scrypt _cffi_d_EVP_PBE_scrypt
#endif

static EVP_PKEY * _cffi_d_EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO * x0)
{
  return EVP_PKCS82PKEY(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKCS82PKEY(PyObject *self, PyObject *arg0)
{
  PKCS8_PRIV_KEY_INFO * x0;
  Py_ssize_t datasize;
  EVP_PKEY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(496), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS8_PRIV_KEY_INFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(496), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKCS82PKEY(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_EVP_PKCS82PKEY _cffi_d_EVP_PKCS82PKEY
#endif

static EVP_PKEY_CTX * _cffi_d_EVP_PKEY_CTX_dup(EVP_PKEY_CTX * x0)
{
  return EVP_PKEY_CTX_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_dup(PyObject *self, PyObject *arg0)
{
  EVP_PKEY_CTX * x0;
  Py_ssize_t datasize;
  EVP_PKEY_CTX * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(511));
}
#else
#  define _cffi_f_EVP_PKEY_CTX_dup _cffi_d_EVP_PKEY_CTX_dup
#endif

static void _cffi_d_EVP_PKEY_CTX_free(EVP_PKEY_CTX * x0)
{
  EVP_PKEY_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_free(PyObject *self, PyObject *arg0)
{
  EVP_PKEY_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EVP_PKEY_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EVP_PKEY_CTX_free _cffi_d_EVP_PKEY_CTX_free
#endif

static EVP_PKEY_CTX * _cffi_d_EVP_PKEY_CTX_new(EVP_PKEY * x0, ENGINE * x1)
{
  return EVP_PKEY_CTX_new(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_new(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  ENGINE * x1;
  Py_ssize_t datasize;
  EVP_PKEY_CTX * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_new", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(435), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_new(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(511));
}
#else
#  define _cffi_f_EVP_PKEY_CTX_new _cffi_d_EVP_PKEY_CTX_new
#endif

static EVP_PKEY_CTX * _cffi_d_EVP_PKEY_CTX_new_id(int x0, ENGINE * x1)
{
  return EVP_PKEY_CTX_new_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_new_id(PyObject *self, PyObject *args)
{
  int x0;
  ENGINE * x1;
  Py_ssize_t datasize;
  EVP_PKEY_CTX * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_new_id", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(435), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_new_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(511));
}
#else
#  define _cffi_f_EVP_PKEY_CTX_new_id _cffi_d_EVP_PKEY_CTX_new_id
#endif

static int _cffi_d_EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX * x0, EVP_MD * x1)
{
  return EVP_PKEY_CTX_set_rsa_mgf1_md(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_set_rsa_mgf1_md(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  EVP_MD * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_set_rsa_mgf1_md", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1954), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1954), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_set_rsa_mgf1_md(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_CTX_set_rsa_mgf1_md _cffi_d_EVP_PKEY_CTX_set_rsa_mgf1_md
#endif

static int _cffi_d_EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX * x0, EVP_MD * x1)
{
  return EVP_PKEY_CTX_set_rsa_oaep_md(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_set_rsa_oaep_md(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  EVP_MD * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_set_rsa_oaep_md", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1954), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1954), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_set_rsa_oaep_md(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_CTX_set_rsa_oaep_md _cffi_d_EVP_PKEY_CTX_set_rsa_oaep_md
#endif

static int _cffi_d_EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX * x0, int x1)
{
  return EVP_PKEY_CTX_set_rsa_padding(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_set_rsa_padding(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_set_rsa_padding", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_set_rsa_padding(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_CTX_set_rsa_padding _cffi_d_EVP_PKEY_CTX_set_rsa_padding
#endif

static int _cffi_d_EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX * x0, int x1)
{
  return EVP_PKEY_CTX_set_rsa_pss_saltlen(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_set_rsa_pss_saltlen(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_set_rsa_pss_saltlen", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_set_rsa_pss_saltlen(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_CTX_set_rsa_pss_saltlen _cffi_d_EVP_PKEY_CTX_set_rsa_pss_saltlen
#endif

static int _cffi_d_EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX * x0, EVP_MD const * x1)
{
  return EVP_PKEY_CTX_set_signature_md(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_CTX_set_signature_md(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  EVP_MD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_CTX_set_signature_md", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(226), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_CTX_set_signature_md(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_CTX_set_signature_md _cffi_d_EVP_PKEY_CTX_set_signature_md
#endif

static int _cffi_d_EVP_PKEY_add1_attr(EVP_PKEY * x0, X509_ATTRIBUTE * x1)
{
  return EVP_PKEY_add1_attr(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_add1_attr(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  X509_ATTRIBUTE * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_add1_attr", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1921), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_ATTRIBUTE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1921), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_add1_attr(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_add1_attr _cffi_d_EVP_PKEY_add1_attr
#endif

static int _cffi_d_EVP_PKEY_add1_attr_by_NID(EVP_PKEY * x0, int x1, int x2, unsigned char const * x3, int x4)
{
  return EVP_PKEY_add1_attr_by_NID(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_add1_attr_by_NID(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  int x1;
  int x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_add1_attr_by_NID", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_add1_attr_by_NID(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_add1_attr_by_NID _cffi_d_EVP_PKEY_add1_attr_by_NID
#endif

static int _cffi_d_EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY * x0, ASN1_OBJECT const * x1, int x2, unsigned char const * x3, int x4)
{
  return EVP_PKEY_add1_attr_by_OBJ(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_add1_attr_by_OBJ(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  ASN1_OBJECT const * x1;
  int x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_add1_attr_by_OBJ", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(44), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_add1_attr_by_OBJ(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_add1_attr_by_OBJ _cffi_d_EVP_PKEY_add1_attr_by_OBJ
#endif

static int _cffi_d_EVP_PKEY_add1_attr_by_txt(EVP_PKEY * x0, char const * x1, int x2, unsigned char const * x3, int x4)
{
  return EVP_PKEY_add1_attr_by_txt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_add1_attr_by_txt(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  char const * x1;
  int x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_add1_attr_by_txt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_add1_attr_by_txt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_add1_attr_by_txt _cffi_d_EVP_PKEY_add1_attr_by_txt
#endif

static int _cffi_d_EVP_PKEY_assign_DSA(EVP_PKEY * x0, DSA * x1)
{
  return EVP_PKEY_assign_DSA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_assign_DSA(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  DSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_assign_DSA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(333), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_assign_DSA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_assign_DSA _cffi_d_EVP_PKEY_assign_DSA
#endif

static int _cffi_d_EVP_PKEY_assign_EC_KEY(EVP_PKEY * x0, EC_KEY * x1)
{
  return EVP_PKEY_assign_EC_KEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_assign_EC_KEY(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  EC_KEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_assign_EC_KEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_assign_EC_KEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_assign_EC_KEY _cffi_d_EVP_PKEY_assign_EC_KEY
#endif

static int _cffi_d_EVP_PKEY_assign_RSA(EVP_PKEY * x0, RSA * x1)
{
  return EVP_PKEY_assign_RSA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_assign_RSA(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  RSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_assign_RSA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(672), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_assign_RSA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_assign_RSA _cffi_d_EVP_PKEY_assign_RSA
#endif

static int _cffi_d_EVP_PKEY_bits(EVP_PKEY * x0)
{
  return EVP_PKEY_bits(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_bits(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_bits(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_bits _cffi_d_EVP_PKEY_bits
#endif

static int _cffi_d_EVP_PKEY_cmp(EVP_PKEY const * x0, EVP_PKEY const * x1)
{
  return EVP_PKEY_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_cmp(PyObject *self, PyObject *args)
{
  EVP_PKEY const * x0;
  EVP_PKEY const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(758), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(758), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_cmp _cffi_d_EVP_PKEY_cmp
#endif

static int _cffi_d_EVP_PKEY_decrypt(EVP_PKEY_CTX * x0, unsigned char * x1, size_t * x2, unsigned char const * x3, size_t x4)
{
  return EVP_PKEY_decrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_decrypt(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  unsigned char * x1;
  size_t * x2;
  unsigned char const * x3;
  size_t x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_decrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1353), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (size_t *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1353), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, size_t);
  if (x4 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_decrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_decrypt _cffi_d_EVP_PKEY_decrypt
#endif

static int _cffi_d_EVP_PKEY_decrypt_init(EVP_PKEY_CTX * x0)
{
  return EVP_PKEY_decrypt_init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_decrypt_init(PyObject *self, PyObject *arg0)
{
  EVP_PKEY_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_decrypt_init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_decrypt_init _cffi_d_EVP_PKEY_decrypt_init
#endif

static X509_ATTRIBUTE * _cffi_d_EVP_PKEY_delete_attr(EVP_PKEY * x0, int x1)
{
  return EVP_PKEY_delete_attr(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_delete_attr(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  int x1;
  Py_ssize_t datasize;
  X509_ATTRIBUTE * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_delete_attr", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_delete_attr(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1921));
}
#else
#  define _cffi_f_EVP_PKEY_delete_attr _cffi_d_EVP_PKEY_delete_attr
#endif

static int _cffi_d_EVP_PKEY_encrypt(EVP_PKEY_CTX * x0, unsigned char * x1, size_t * x2, unsigned char const * x3, size_t x4)
{
  return EVP_PKEY_encrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_encrypt(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  unsigned char * x1;
  size_t * x2;
  unsigned char const * x3;
  size_t x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_encrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1353), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (size_t *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1353), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, size_t);
  if (x4 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_encrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_encrypt _cffi_d_EVP_PKEY_encrypt
#endif

static int _cffi_d_EVP_PKEY_encrypt_init(EVP_PKEY_CTX * x0)
{
  return EVP_PKEY_encrypt_init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_encrypt_init(PyObject *self, PyObject *arg0)
{
  EVP_PKEY_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_encrypt_init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_encrypt_init _cffi_d_EVP_PKEY_encrypt_init
#endif

static void _cffi_d_EVP_PKEY_free(EVP_PKEY * x0)
{
  EVP_PKEY_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_free(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { EVP_PKEY_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_EVP_PKEY_free _cffi_d_EVP_PKEY_free
#endif

static DH * _cffi_d_EVP_PKEY_get1_DH(EVP_PKEY * x0)
{
  return EVP_PKEY_get1_DH(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get1_DH(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;
  DH * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get1_DH(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_EVP_PKEY_get1_DH _cffi_d_EVP_PKEY_get1_DH
#endif

static DSA * _cffi_d_EVP_PKEY_get1_DSA(EVP_PKEY * x0)
{
  return EVP_PKEY_get1_DSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get1_DSA(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;
  DSA * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get1_DSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_EVP_PKEY_get1_DSA _cffi_d_EVP_PKEY_get1_DSA
#endif

static EC_KEY * _cffi_d_EVP_PKEY_get1_EC_KEY(EVP_PKEY * x0)
{
  return EVP_PKEY_get1_EC_KEY(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get1_EC_KEY(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;
  EC_KEY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get1_EC_KEY(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_EVP_PKEY_get1_EC_KEY _cffi_d_EVP_PKEY_get1_EC_KEY
#endif

static RSA * _cffi_d_EVP_PKEY_get1_RSA(EVP_PKEY * x0)
{
  return EVP_PKEY_get1_RSA(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get1_RSA(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;
  RSA * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get1_RSA(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_EVP_PKEY_get1_RSA _cffi_d_EVP_PKEY_get1_RSA
#endif

static X509_ATTRIBUTE * _cffi_d_EVP_PKEY_get_attr(EVP_PKEY const * x0, int x1)
{
  return EVP_PKEY_get_attr(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get_attr(PyObject *self, PyObject *args)
{
  EVP_PKEY const * x0;
  int x1;
  Py_ssize_t datasize;
  X509_ATTRIBUTE * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_get_attr", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(758), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get_attr(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1921));
}
#else
#  define _cffi_f_EVP_PKEY_get_attr _cffi_d_EVP_PKEY_get_attr
#endif

static int _cffi_d_EVP_PKEY_get_attr_by_NID(EVP_PKEY const * x0, int x1, int x2)
{
  return EVP_PKEY_get_attr_by_NID(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get_attr_by_NID(PyObject *self, PyObject *args)
{
  EVP_PKEY const * x0;
  int x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_get_attr_by_NID", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(758), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get_attr_by_NID(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_get_attr_by_NID _cffi_d_EVP_PKEY_get_attr_by_NID
#endif

static int _cffi_d_EVP_PKEY_get_attr_count(EVP_PKEY const * x0)
{
  return EVP_PKEY_get_attr_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_get_attr_count(PyObject *self, PyObject *arg0)
{
  EVP_PKEY const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(758), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_get_attr_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_get_attr_count _cffi_d_EVP_PKEY_get_attr_count
#endif

static int _cffi_d_EVP_PKEY_id(EVP_PKEY const * x0)
{
  return EVP_PKEY_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_id(PyObject *self, PyObject *arg0)
{
  EVP_PKEY const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(758), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(758), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_id _cffi_d_EVP_PKEY_id
#endif

static EVP_PKEY * _cffi_d_EVP_PKEY_new(void)
{
  return EVP_PKEY_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_new(PyObject *self, PyObject *noarg)
{
  EVP_PKEY * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_EVP_PKEY_new _cffi_d_EVP_PKEY_new
#endif

static int _cffi_d_EVP_PKEY_set1_DH(EVP_PKEY * x0, DH * x1)
{
  return EVP_PKEY_set1_DH(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_set1_DH(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  DH * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_set1_DH", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(299), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_set1_DH(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_set1_DH _cffi_d_EVP_PKEY_set1_DH
#endif

static int _cffi_d_EVP_PKEY_set1_DSA(EVP_PKEY * x0, DSA * x1)
{
  return EVP_PKEY_set1_DSA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_set1_DSA(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  DSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_set1_DSA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(333), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_set1_DSA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_set1_DSA _cffi_d_EVP_PKEY_set1_DSA
#endif

static int _cffi_d_EVP_PKEY_set1_EC_KEY(EVP_PKEY * x0, EC_KEY * x1)
{
  return EVP_PKEY_set1_EC_KEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_set1_EC_KEY(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  EC_KEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_set1_EC_KEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_set1_EC_KEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_set1_EC_KEY _cffi_d_EVP_PKEY_set1_EC_KEY
#endif

static int _cffi_d_EVP_PKEY_set1_RSA(EVP_PKEY * x0, RSA * x1)
{
  return EVP_PKEY_set1_RSA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_set1_RSA(PyObject *self, PyObject *args)
{
  EVP_PKEY * x0;
  RSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_set1_RSA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(672), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_set1_RSA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_set1_RSA _cffi_d_EVP_PKEY_set1_RSA
#endif

static int _cffi_d_EVP_PKEY_sign(EVP_PKEY_CTX * x0, unsigned char * x1, size_t * x2, unsigned char const * x3, size_t x4)
{
  return EVP_PKEY_sign(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_sign(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  unsigned char * x1;
  size_t * x2;
  unsigned char const * x3;
  size_t x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_sign", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1353), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (size_t *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1353), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, size_t);
  if (x4 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_sign(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_sign _cffi_d_EVP_PKEY_sign
#endif

static int _cffi_d_EVP_PKEY_sign_init(EVP_PKEY_CTX * x0)
{
  return EVP_PKEY_sign_init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_sign_init(PyObject *self, PyObject *arg0)
{
  EVP_PKEY_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_sign_init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_sign_init _cffi_d_EVP_PKEY_sign_init
#endif

static int _cffi_d_EVP_PKEY_size(EVP_PKEY * x0)
{
  return EVP_PKEY_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_size(PyObject *self, PyObject *arg0)
{
  EVP_PKEY * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(217), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_size _cffi_d_EVP_PKEY_size
#endif

static int _cffi_d_EVP_PKEY_type(int x0)
{
  return EVP_PKEY_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_type(PyObject *self, PyObject *arg0)
{
  int x0;
  int result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_type _cffi_d_EVP_PKEY_type
#endif

static int _cffi_d_EVP_PKEY_verify(EVP_PKEY_CTX * x0, unsigned char const * x1, size_t x2, unsigned char const * x3, size_t x4)
{
  return EVP_PKEY_verify(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_verify(PyObject *self, PyObject *args)
{
  EVP_PKEY_CTX * x0;
  unsigned char const * x1;
  size_t x2;
  unsigned char const * x3;
  size_t x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "EVP_PKEY_verify", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, size_t);
  if (x4 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_verify(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_verify _cffi_d_EVP_PKEY_verify
#endif

static int _cffi_d_EVP_PKEY_verify_init(EVP_PKEY_CTX * x0)
{
  return EVP_PKEY_verify_init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_PKEY_verify_init(PyObject *self, PyObject *arg0)
{
  EVP_PKEY_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(511), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_PKEY_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(511), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_PKEY_verify_init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_PKEY_verify_init _cffi_d_EVP_PKEY_verify_init
#endif

static int _cffi_d_EVP_SignFinal(EVP_MD_CTX * x0, unsigned char * x1, unsigned int * x2, EVP_PKEY * x3)
{
  return EVP_SignFinal(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_SignFinal(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  unsigned char * x1;
  unsigned int * x2;
  EVP_PKEY * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EVP_SignFinal", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1871), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(217), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_SignFinal(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_SignFinal _cffi_d_EVP_SignFinal
#endif

static int _cffi_d_EVP_SignInit(EVP_MD_CTX * x0, EVP_MD const * x1)
{
  return EVP_SignInit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_SignInit(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  EVP_MD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_SignInit", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(226), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_SignInit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_SignInit _cffi_d_EVP_SignInit
#endif

static int _cffi_d_EVP_SignUpdate(EVP_MD_CTX * x0, void const * x1, size_t x2)
{
  return EVP_SignUpdate(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_SignUpdate(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  void const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_SignUpdate", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_SignUpdate(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_SignUpdate _cffi_d_EVP_SignUpdate
#endif

static int _cffi_d_EVP_VerifyFinal(EVP_MD_CTX * x0, unsigned char const * x1, unsigned int x2, EVP_PKEY * x3)
{
  return EVP_VerifyFinal(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_VerifyFinal(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  unsigned char const * x1;
  unsigned int x2;
  EVP_PKEY * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "EVP_VerifyFinal", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned int);
  if (x2 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(217), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_VerifyFinal(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_VerifyFinal _cffi_d_EVP_VerifyFinal
#endif

static int _cffi_d_EVP_VerifyInit(EVP_MD_CTX * x0, EVP_MD const * x1)
{
  return EVP_VerifyInit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_VerifyInit(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  EVP_MD const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "EVP_VerifyInit", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(226), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_VerifyInit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_VerifyInit _cffi_d_EVP_VerifyInit
#endif

static int _cffi_d_EVP_VerifyUpdate(EVP_MD_CTX * x0, void const * x1, size_t x2)
{
  return EVP_VerifyUpdate(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_VerifyUpdate(PyObject *self, PyObject *args)
{
  EVP_MD_CTX * x0;
  void const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "EVP_VerifyUpdate", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1856), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EVP_MD_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1856), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_VerifyUpdate(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_EVP_VerifyUpdate _cffi_d_EVP_VerifyUpdate
#endif

static EVP_CIPHER const * _cffi_d_EVP_get_cipherbyname(char const * x0)
{
  return EVP_get_cipherbyname(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_get_cipherbyname(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  EVP_CIPHER const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_get_cipherbyname(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(212));
}
#else
#  define _cffi_f_EVP_get_cipherbyname _cffi_d_EVP_get_cipherbyname
#endif

static EVP_MD const * _cffi_d_EVP_get_digestbyname(char const * x0)
{
  return EVP_get_digestbyname(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_get_digestbyname(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  EVP_MD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_get_digestbyname(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_get_digestbyname _cffi_d_EVP_get_digestbyname
#endif

static EVP_MD const * _cffi_d_EVP_md5(void)
{
  return EVP_md5();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_md5(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_md5(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_md5 _cffi_d_EVP_md5
#endif

static EVP_MD const * _cffi_d_EVP_ripemd160(void)
{
  return EVP_ripemd160();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_ripemd160(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_ripemd160(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_ripemd160 _cffi_d_EVP_ripemd160
#endif

static EVP_MD const * _cffi_d_EVP_sha1(void)
{
  return EVP_sha1();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_sha1(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_sha1(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_sha1 _cffi_d_EVP_sha1
#endif

static EVP_MD const * _cffi_d_EVP_sha224(void)
{
  return EVP_sha224();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_sha224(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_sha224(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_sha224 _cffi_d_EVP_sha224
#endif

static EVP_MD const * _cffi_d_EVP_sha256(void)
{
  return EVP_sha256();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_sha256(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_sha256(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_sha256 _cffi_d_EVP_sha256
#endif

static EVP_MD const * _cffi_d_EVP_sha384(void)
{
  return EVP_sha384();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_sha384(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_sha384(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_sha384 _cffi_d_EVP_sha384
#endif

static EVP_MD const * _cffi_d_EVP_sha512(void)
{
  return EVP_sha512();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_EVP_sha512(PyObject *self, PyObject *noarg)
{
  EVP_MD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = EVP_sha512(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(226));
}
#else
#  define _cffi_f_EVP_sha512 _cffi_d_EVP_sha512
#endif

static void _cffi_d_GENERAL_NAMES_free(GENERAL_NAMES * x0)
{
  GENERAL_NAMES_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_GENERAL_NAMES_free(PyObject *self, PyObject *arg0)
{
  GENERAL_NAMES * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(518), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(518), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { GENERAL_NAMES_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_GENERAL_NAMES_free _cffi_d_GENERAL_NAMES_free
#endif

static GENERAL_NAMES * _cffi_d_GENERAL_NAMES_new(void)
{
  return GENERAL_NAMES_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_GENERAL_NAMES_new(PyObject *self, PyObject *noarg)
{
  GENERAL_NAMES * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = GENERAL_NAMES_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(518));
}
#else
#  define _cffi_f_GENERAL_NAMES_new _cffi_d_GENERAL_NAMES_new
#endif

static void _cffi_d_GENERAL_NAME_free(GENERAL_NAME * x0)
{
  GENERAL_NAME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_GENERAL_NAME_free(PyObject *self, PyObject *arg0)
{
  GENERAL_NAME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1228), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1228), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { GENERAL_NAME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_GENERAL_NAME_free _cffi_d_GENERAL_NAME_free
#endif

static GENERAL_NAME * _cffi_d_GENERAL_NAME_new(void)
{
  return GENERAL_NAME_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_GENERAL_NAME_new(PyObject *self, PyObject *noarg)
{
  GENERAL_NAME * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = GENERAL_NAME_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1228));
}
#else
#  define _cffi_f_GENERAL_NAME_new _cffi_d_GENERAL_NAME_new
#endif

static int _cffi_d_GENERAL_NAME_print(BIO * x0, GENERAL_NAME * x1)
{
  return GENERAL_NAME_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_GENERAL_NAME_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  GENERAL_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "GENERAL_NAME_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1228), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (GENERAL_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1228), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = GENERAL_NAME_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_GENERAL_NAME_print _cffi_d_GENERAL_NAME_print
#endif

static GENERAL_SUBTREE * _cffi_d_GENERAL_SUBTREE_new(void)
{
  return GENERAL_SUBTREE_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_GENERAL_SUBTREE_new(PyObject *self, PyObject *noarg)
{
  GENERAL_SUBTREE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = GENERAL_SUBTREE_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1422));
}
#else
#  define _cffi_f_GENERAL_SUBTREE_new _cffi_d_GENERAL_SUBTREE_new
#endif

static int _cffi_d_HMAC_CTX_copy(HMAC_CTX * x0, HMAC_CTX * x1)
{
  return HMAC_CTX_copy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_HMAC_CTX_copy(PyObject *self, PyObject *args)
{
  HMAC_CTX * x0;
  HMAC_CTX * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "HMAC_CTX_copy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1994), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (HMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1994), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1994), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (HMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1994), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = HMAC_CTX_copy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_HMAC_CTX_copy _cffi_d_HMAC_CTX_copy
#endif

static int _cffi_d_HMAC_Final(HMAC_CTX * x0, unsigned char * x1, unsigned int * x2)
{
  return HMAC_Final(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_HMAC_Final(PyObject *self, PyObject *args)
{
  HMAC_CTX * x0;
  unsigned char * x1;
  unsigned int * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "HMAC_Final", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1994), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (HMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1994), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1871), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = HMAC_Final(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_HMAC_Final _cffi_d_HMAC_Final
#endif

static int _cffi_d_HMAC_Init_ex(HMAC_CTX * x0, void const * x1, int x2, EVP_MD const * x3, ENGINE * x4)
{
  return HMAC_Init_ex(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_HMAC_Init_ex(PyObject *self, PyObject *args)
{
  HMAC_CTX * x0;
  void const * x1;
  int x2;
  EVP_MD const * x3;
  ENGINE * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "HMAC_Init_ex", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1994), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (HMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1994), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(226), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(435), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = HMAC_Init_ex(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_HMAC_Init_ex _cffi_d_HMAC_Init_ex
#endif

static int _cffi_d_HMAC_Update(HMAC_CTX * x0, unsigned char const * x1, size_t x2)
{
  return HMAC_Update(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_HMAC_Update(PyObject *self, PyObject *args)
{
  HMAC_CTX * x0;
  unsigned char const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "HMAC_Update", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1994), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (HMAC_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1994), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = HMAC_Update(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_HMAC_Update _cffi_d_HMAC_Update
#endif

static ASN1_OCTET_STRING * _cffi_d_M_ASN1_TIME_dup(void * x0)
{
  return M_ASN1_TIME_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_M_ASN1_TIME_dup(PyObject *self, PyObject *arg0)
{
  void * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(92), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = M_ASN1_TIME_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_M_ASN1_TIME_dup _cffi_d_M_ASN1_TIME_dup
#endif

static void _cffi_d_NAME_CONSTRAINTS_free(NAME_CONSTRAINTS * x0)
{
  NAME_CONSTRAINTS_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NAME_CONSTRAINTS_free(PyObject *self, PyObject *arg0)
{
  NAME_CONSTRAINTS * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3319), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NAME_CONSTRAINTS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3319), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { NAME_CONSTRAINTS_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_NAME_CONSTRAINTS_free _cffi_d_NAME_CONSTRAINTS_free
#endif

static NAME_CONSTRAINTS * _cffi_d_NAME_CONSTRAINTS_new(void)
{
  return NAME_CONSTRAINTS_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NAME_CONSTRAINTS_new(PyObject *self, PyObject *noarg)
{
  NAME_CONSTRAINTS * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NAME_CONSTRAINTS_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3319));
}
#else
#  define _cffi_f_NAME_CONSTRAINTS_new _cffi_d_NAME_CONSTRAINTS_new
#endif

static NETSCAPE_SPKI * _cffi_d_NETSCAPE_SPKI_b64_decode(char const * x0, int x1)
{
  return NETSCAPE_SPKI_b64_decode(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_b64_decode(PyObject *self, PyObject *args)
{
  char const * x0;
  int x1;
  Py_ssize_t datasize;
  NETSCAPE_SPKI * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "NETSCAPE_SPKI_b64_decode", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_b64_decode(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(493));
}
#else
#  define _cffi_f_NETSCAPE_SPKI_b64_decode _cffi_d_NETSCAPE_SPKI_b64_decode
#endif

static char * _cffi_d_NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI * x0)
{
  return NETSCAPE_SPKI_b64_encode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_b64_encode(PyObject *self, PyObject *arg0)
{
  NETSCAPE_SPKI * x0;
  Py_ssize_t datasize;
  char * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(493), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NETSCAPE_SPKI *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(493), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_b64_encode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_NETSCAPE_SPKI_b64_encode _cffi_d_NETSCAPE_SPKI_b64_encode
#endif

static void _cffi_d_NETSCAPE_SPKI_free(NETSCAPE_SPKI * x0)
{
  NETSCAPE_SPKI_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_free(PyObject *self, PyObject *arg0)
{
  NETSCAPE_SPKI * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(493), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NETSCAPE_SPKI *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(493), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { NETSCAPE_SPKI_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_NETSCAPE_SPKI_free _cffi_d_NETSCAPE_SPKI_free
#endif

static EVP_PKEY * _cffi_d_NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI * x0)
{
  return NETSCAPE_SPKI_get_pubkey(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_get_pubkey(PyObject *self, PyObject *arg0)
{
  NETSCAPE_SPKI * x0;
  Py_ssize_t datasize;
  EVP_PKEY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(493), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NETSCAPE_SPKI *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(493), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_get_pubkey(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_NETSCAPE_SPKI_get_pubkey _cffi_d_NETSCAPE_SPKI_get_pubkey
#endif

static NETSCAPE_SPKI * _cffi_d_NETSCAPE_SPKI_new(void)
{
  return NETSCAPE_SPKI_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_new(PyObject *self, PyObject *noarg)
{
  NETSCAPE_SPKI * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(493));
}
#else
#  define _cffi_f_NETSCAPE_SPKI_new _cffi_d_NETSCAPE_SPKI_new
#endif

static int _cffi_d_NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI * x0, EVP_PKEY * x1)
{
  return NETSCAPE_SPKI_set_pubkey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_set_pubkey(PyObject *self, PyObject *args)
{
  NETSCAPE_SPKI * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "NETSCAPE_SPKI_set_pubkey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(493), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NETSCAPE_SPKI *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(493), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_set_pubkey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_NETSCAPE_SPKI_set_pubkey _cffi_d_NETSCAPE_SPKI_set_pubkey
#endif

static int _cffi_d_NETSCAPE_SPKI_sign(NETSCAPE_SPKI * x0, EVP_PKEY * x1, EVP_MD const * x2)
{
  return NETSCAPE_SPKI_sign(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_sign(PyObject *self, PyObject *args)
{
  NETSCAPE_SPKI * x0;
  EVP_PKEY * x1;
  EVP_MD const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "NETSCAPE_SPKI_sign", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(493), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NETSCAPE_SPKI *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(493), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(226), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_sign(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_NETSCAPE_SPKI_sign _cffi_d_NETSCAPE_SPKI_sign
#endif

static int _cffi_d_NETSCAPE_SPKI_verify(NETSCAPE_SPKI * x0, EVP_PKEY * x1)
{
  return NETSCAPE_SPKI_verify(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NETSCAPE_SPKI_verify(PyObject *self, PyObject *args)
{
  NETSCAPE_SPKI * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "NETSCAPE_SPKI_verify", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(493), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NETSCAPE_SPKI *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(493), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NETSCAPE_SPKI_verify(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_NETSCAPE_SPKI_verify _cffi_d_NETSCAPE_SPKI_verify
#endif

static void _cffi_d_NOTICEREF_free(NOTICEREF * x0)
{
  NOTICEREF_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NOTICEREF_free(PyObject *self, PyObject *arg0)
{
  NOTICEREF * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3325), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (NOTICEREF *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3325), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { NOTICEREF_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_NOTICEREF_free _cffi_d_NOTICEREF_free
#endif

static NOTICEREF * _cffi_d_NOTICEREF_new(void)
{
  return NOTICEREF_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_NOTICEREF_new(PyObject *self, PyObject *noarg)
{
  NOTICEREF * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = NOTICEREF_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3325));
}
#else
#  define _cffi_f_NOTICEREF_new _cffi_d_NOTICEREF_new
#endif

static void _cffi_d_OBJ_NAME_do_all(int x0, void(* x1)(OBJ_NAME const *, void *), void * x2)
{
  OBJ_NAME_do_all(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_NAME_do_all(PyObject *self, PyObject *args)
{
  int x0;
  void(* x1)(OBJ_NAME const *, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "OBJ_NAME_do_all", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = (void(*)(OBJ_NAME const *, void *))_cffi_to_c_pointer(arg1, _cffi_type(3591));
  if (x1 == (void(*)(OBJ_NAME const *, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OBJ_NAME_do_all(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OBJ_NAME_do_all _cffi_d_OBJ_NAME_do_all
#endif

static void _cffi_d_OBJ_cleanup(void)
{
  OBJ_cleanup();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_cleanup(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OBJ_cleanup(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OBJ_cleanup _cffi_d_OBJ_cleanup
#endif

static int _cffi_d_OBJ_cmp(ASN1_OBJECT const * x0, ASN1_OBJECT const * x1)
{
  return OBJ_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_cmp(PyObject *self, PyObject *args)
{
  ASN1_OBJECT const * x0;
  ASN1_OBJECT const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OBJ_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(44), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(44), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_cmp _cffi_d_OBJ_cmp
#endif

static int _cffi_d_OBJ_create(char const * x0, char const * x1, char const * x2)
{
  return OBJ_create(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_create(PyObject *self, PyObject *args)
{
  char const * x0;
  char const * x1;
  char const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "OBJ_create", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(57), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_create(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_create _cffi_d_OBJ_create
#endif

static ASN1_OBJECT * _cffi_d_OBJ_dup(ASN1_OBJECT const * x0)
{
  return OBJ_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_dup(PyObject *self, PyObject *arg0)
{
  ASN1_OBJECT const * x0;
  Py_ssize_t datasize;
  ASN1_OBJECT * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(44), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_OBJ_dup _cffi_d_OBJ_dup
#endif

static int _cffi_d_OBJ_ln2nid(char const * x0)
{
  return OBJ_ln2nid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_ln2nid(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_ln2nid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_ln2nid _cffi_d_OBJ_ln2nid
#endif

static char const * _cffi_d_OBJ_nid2ln(int x0)
{
  return OBJ_nid2ln(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_nid2ln(PyObject *self, PyObject *arg0)
{
  int x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_nid2ln(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_OBJ_nid2ln _cffi_d_OBJ_nid2ln
#endif

static ASN1_OBJECT * _cffi_d_OBJ_nid2obj(int x0)
{
  return OBJ_nid2obj(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_nid2obj(PyObject *self, PyObject *arg0)
{
  int x0;
  ASN1_OBJECT * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_nid2obj(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_OBJ_nid2obj _cffi_d_OBJ_nid2obj
#endif

static char const * _cffi_d_OBJ_nid2sn(int x0)
{
  return OBJ_nid2sn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_nid2sn(PyObject *self, PyObject *arg0)
{
  int x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_nid2sn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_OBJ_nid2sn _cffi_d_OBJ_nid2sn
#endif

static int _cffi_d_OBJ_obj2nid(ASN1_OBJECT const * x0)
{
  return OBJ_obj2nid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_obj2nid(PyObject *self, PyObject *arg0)
{
  ASN1_OBJECT const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(44), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_obj2nid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_obj2nid _cffi_d_OBJ_obj2nid
#endif

static int _cffi_d_OBJ_obj2txt(char * x0, int x1, ASN1_OBJECT const * x2, int x3)
{
  return OBJ_obj2txt(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_obj2txt(PyObject *self, PyObject *args)
{
  char * x0;
  int x1;
  ASN1_OBJECT const * x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "OBJ_obj2txt", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(594), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ASN1_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(44), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_obj2txt(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_obj2txt _cffi_d_OBJ_obj2txt
#endif

static int _cffi_d_OBJ_sn2nid(char const * x0)
{
  return OBJ_sn2nid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_sn2nid(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_sn2nid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_sn2nid _cffi_d_OBJ_sn2nid
#endif

static int _cffi_d_OBJ_txt2nid(char const * x0)
{
  return OBJ_txt2nid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_txt2nid(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_txt2nid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OBJ_txt2nid _cffi_d_OBJ_txt2nid
#endif

static ASN1_OBJECT * _cffi_d_OBJ_txt2obj(char const * x0, int x1)
{
  return OBJ_txt2obj(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OBJ_txt2obj(PyObject *self, PyObject *args)
{
  char const * x0;
  int x1;
  Py_ssize_t datasize;
  ASN1_OBJECT * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OBJ_txt2obj", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OBJ_txt2obj(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_OBJ_txt2obj _cffi_d_OBJ_txt2obj
#endif

static int _cffi_d_OCSP_BASICRESP_add1_ext_i2d(OCSP_BASICRESP * x0, int x1, void * x2, int x3, unsigned long x4)
{
  return OCSP_BASICRESP_add1_ext_i2d(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_BASICRESP_add1_ext_i2d(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  int x1;
  void * x2;
  int x3;
  unsigned long x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "OCSP_BASICRESP_add1_ext_i2d", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, unsigned long);
  if (x4 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_BASICRESP_add1_ext_i2d(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_BASICRESP_add1_ext_i2d _cffi_d_OCSP_BASICRESP_add1_ext_i2d
#endif

static void _cffi_d_OCSP_BASICRESP_free(OCSP_BASICRESP * x0)
{
  OCSP_BASICRESP_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_BASICRESP_free(PyObject *self, PyObject *arg0)
{
  OCSP_BASICRESP * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OCSP_BASICRESP_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OCSP_BASICRESP_free _cffi_d_OCSP_BASICRESP_free
#endif

static X509_EXTENSION * _cffi_d_OCSP_BASICRESP_get_ext(OCSP_BASICRESP * x0, int x1)
{
  return OCSP_BASICRESP_get_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_BASICRESP_get_ext(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_BASICRESP_get_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_BASICRESP_get_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_OCSP_BASICRESP_get_ext _cffi_d_OCSP_BASICRESP_get_ext
#endif

static int _cffi_d_OCSP_BASICRESP_get_ext_count(OCSP_BASICRESP * x0)
{
  return OCSP_BASICRESP_get_ext_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_BASICRESP_get_ext_count(PyObject *self, PyObject *arg0)
{
  OCSP_BASICRESP * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_BASICRESP_get_ext_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_BASICRESP_get_ext_count _cffi_d_OCSP_BASICRESP_get_ext_count
#endif

static OCSP_BASICRESP * _cffi_d_OCSP_BASICRESP_new(void)
{
  return OCSP_BASICRESP_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_BASICRESP_new(PyObject *self, PyObject *noarg)
{
  OCSP_BASICRESP * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_BASICRESP_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(572));
}
#else
#  define _cffi_f_OCSP_BASICRESP_new _cffi_d_OCSP_BASICRESP_new
#endif

static X509_EXTENSION * _cffi_d_OCSP_ONEREQ_get_ext(OCSP_ONEREQ * x0, int x1)
{
  return OCSP_ONEREQ_get_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_ONEREQ_get_ext(PyObject *self, PyObject *args)
{
  OCSP_ONEREQ * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_ONEREQ_get_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_ONEREQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_ONEREQ_get_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_OCSP_ONEREQ_get_ext _cffi_d_OCSP_ONEREQ_get_ext
#endif

static int _cffi_d_OCSP_ONEREQ_get_ext_count(OCSP_ONEREQ * x0)
{
  return OCSP_ONEREQ_get_ext_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_ONEREQ_get_ext_count(PyObject *self, PyObject *arg0)
{
  OCSP_ONEREQ * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_ONEREQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(554), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_ONEREQ_get_ext_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_ONEREQ_get_ext_count _cffi_d_OCSP_ONEREQ_get_ext_count
#endif

static int _cffi_d_OCSP_REQUEST_add1_ext_i2d(OCSP_REQUEST * x0, int x1, void * x2, int x3, unsigned long x4)
{
  return OCSP_REQUEST_add1_ext_i2d(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_REQUEST_add1_ext_i2d(PyObject *self, PyObject *args)
{
  OCSP_REQUEST * x0;
  int x1;
  void * x2;
  int x3;
  unsigned long x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "OCSP_REQUEST_add1_ext_i2d", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(557), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_REQUEST *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(557), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, unsigned long);
  if (x4 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_REQUEST_add1_ext_i2d(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_REQUEST_add1_ext_i2d _cffi_d_OCSP_REQUEST_add1_ext_i2d
#endif

static void _cffi_d_OCSP_REQUEST_free(OCSP_REQUEST * x0)
{
  OCSP_REQUEST_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_REQUEST_free(PyObject *self, PyObject *arg0)
{
  OCSP_REQUEST * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(557), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_REQUEST *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(557), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OCSP_REQUEST_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OCSP_REQUEST_free _cffi_d_OCSP_REQUEST_free
#endif

static OCSP_REQUEST * _cffi_d_OCSP_REQUEST_new(void)
{
  return OCSP_REQUEST_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_REQUEST_new(PyObject *self, PyObject *noarg)
{
  OCSP_REQUEST * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_REQUEST_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(557));
}
#else
#  define _cffi_f_OCSP_REQUEST_new _cffi_d_OCSP_REQUEST_new
#endif

static X509_EXTENSION * _cffi_d_OCSP_SINGLERESP_get_ext(OCSP_SINGLERESP * x0, int x1)
{
  return OCSP_SINGLERESP_get_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_SINGLERESP_get_ext(PyObject *self, PyObject *args)
{
  OCSP_SINGLERESP * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_SINGLERESP_get_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(798), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_SINGLERESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(798), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_SINGLERESP_get_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_OCSP_SINGLERESP_get_ext _cffi_d_OCSP_SINGLERESP_get_ext
#endif

static int _cffi_d_OCSP_SINGLERESP_get_ext_count(OCSP_SINGLERESP * x0)
{
  return OCSP_SINGLERESP_get_ext_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_SINGLERESP_get_ext_count(PyObject *self, PyObject *arg0)
{
  OCSP_SINGLERESP * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(798), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_SINGLERESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(798), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_SINGLERESP_get_ext_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_SINGLERESP_get_ext_count _cffi_d_OCSP_SINGLERESP_get_ext_count
#endif

static int _cffi_d_OCSP_basic_add1_cert(OCSP_BASICRESP * x0, X509 * x1)
{
  return OCSP_basic_add1_cert(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_basic_add1_cert(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_basic_add1_cert", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_basic_add1_cert(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_basic_add1_cert _cffi_d_OCSP_basic_add1_cert
#endif

static int _cffi_d_OCSP_basic_add1_nonce(OCSP_BASICRESP * x0, unsigned char * x1, int x2)
{
  return OCSP_basic_add1_nonce(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_basic_add1_nonce(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  unsigned char * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "OCSP_basic_add1_nonce", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_basic_add1_nonce(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_basic_add1_nonce _cffi_d_OCSP_basic_add1_nonce
#endif

static OCSP_SINGLERESP * _cffi_d_OCSP_basic_add1_status(OCSP_BASICRESP * x0, OCSP_CERTID * x1, int x2, int x3, ASN1_OCTET_STRING * x4, ASN1_OCTET_STRING * x5, ASN1_OCTET_STRING * x6)
{
  return OCSP_basic_add1_status(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_basic_add1_status(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  OCSP_CERTID * x1;
  int x2;
  int x3;
  ASN1_OCTET_STRING * x4;
  ASN1_OCTET_STRING * x5;
  ASN1_OCTET_STRING * x6;
  Py_ssize_t datasize;
  OCSP_SINGLERESP * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "OCSP_basic_add1_status", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(576), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (OCSP_CERTID *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(576), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(13), arg4) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(13), arg5) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(13), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_basic_add1_status(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(798));
}
#else
#  define _cffi_f_OCSP_basic_add1_status _cffi_d_OCSP_basic_add1_status
#endif

static int _cffi_d_OCSP_basic_sign(OCSP_BASICRESP * x0, X509 * x1, EVP_PKEY * x2, EVP_MD const * x3, Cryptography_STACK_OF_X509 * x4, unsigned long x5)
{
  return OCSP_basic_sign(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_basic_sign(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  X509 * x1;
  EVP_PKEY * x2;
  EVP_MD const * x3;
  Cryptography_STACK_OF_X509 * x4;
  unsigned long x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "OCSP_basic_sign", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(217), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(226), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(210), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, unsigned long);
  if (x5 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_basic_sign(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_basic_sign _cffi_d_OCSP_basic_sign
#endif

static OCSP_CERTID * _cffi_d_OCSP_onereq_get0_id(OCSP_ONEREQ * x0)
{
  return OCSP_onereq_get0_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_onereq_get0_id(PyObject *self, PyObject *arg0)
{
  OCSP_ONEREQ * x0;
  Py_ssize_t datasize;
  OCSP_CERTID * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_ONEREQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(554), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_onereq_get0_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(576));
}
#else
#  define _cffi_f_OCSP_onereq_get0_id _cffi_d_OCSP_onereq_get0_id
#endif

static int _cffi_d_OCSP_request_add1_nonce(OCSP_REQUEST * x0, unsigned char * x1, int x2)
{
  return OCSP_request_add1_nonce(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_request_add1_nonce(PyObject *self, PyObject *args)
{
  OCSP_REQUEST * x0;
  unsigned char * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "OCSP_request_add1_nonce", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(557), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_REQUEST *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(557), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_request_add1_nonce(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_request_add1_nonce _cffi_d_OCSP_request_add1_nonce
#endif

static int _cffi_d_OCSP_request_onereq_count(OCSP_REQUEST * x0)
{
  return OCSP_request_onereq_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_request_onereq_count(PyObject *self, PyObject *arg0)
{
  OCSP_REQUEST * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(557), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_REQUEST *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(557), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_request_onereq_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_request_onereq_count _cffi_d_OCSP_request_onereq_count
#endif

static OCSP_ONEREQ * _cffi_d_OCSP_request_onereq_get0(OCSP_REQUEST * x0, int x1)
{
  return OCSP_request_onereq_get0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_request_onereq_get0(PyObject *self, PyObject *args)
{
  OCSP_REQUEST * x0;
  int x1;
  Py_ssize_t datasize;
  OCSP_ONEREQ * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_request_onereq_get0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(557), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_REQUEST *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(557), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_request_onereq_get0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(554));
}
#else
#  define _cffi_f_OCSP_request_onereq_get0 _cffi_d_OCSP_request_onereq_get0
#endif

static int _cffi_d_OCSP_resp_count(OCSP_BASICRESP * x0)
{
  return OCSP_resp_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_resp_count(PyObject *self, PyObject *arg0)
{
  OCSP_BASICRESP * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_resp_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_resp_count _cffi_d_OCSP_resp_count
#endif

static OCSP_SINGLERESP * _cffi_d_OCSP_resp_get0(OCSP_BASICRESP * x0, int x1)
{
  return OCSP_resp_get0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_resp_get0(PyObject *self, PyObject *args)
{
  OCSP_BASICRESP * x0;
  int x1;
  Py_ssize_t datasize;
  OCSP_SINGLERESP * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_resp_get0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(572), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_resp_get0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(798));
}
#else
#  define _cffi_f_OCSP_resp_get0 _cffi_d_OCSP_resp_get0
#endif

static OCSP_RESPONSE * _cffi_d_OCSP_response_create(int x0, OCSP_BASICRESP * x1)
{
  return OCSP_response_create(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_response_create(PyObject *self, PyObject *args)
{
  int x0;
  OCSP_BASICRESP * x1;
  Py_ssize_t datasize;
  OCSP_RESPONSE * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "OCSP_response_create", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(572), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (OCSP_BASICRESP *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(572), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_response_create(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(549));
}
#else
#  define _cffi_f_OCSP_response_create _cffi_d_OCSP_response_create
#endif

static OCSP_BASICRESP * _cffi_d_OCSP_response_get1_basic(OCSP_RESPONSE * x0)
{
  return OCSP_response_get1_basic(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_response_get1_basic(PyObject *self, PyObject *arg0)
{
  OCSP_RESPONSE * x0;
  Py_ssize_t datasize;
  OCSP_BASICRESP * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(549), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_RESPONSE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(549), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_response_get1_basic(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(572));
}
#else
#  define _cffi_f_OCSP_response_get1_basic _cffi_d_OCSP_response_get1_basic
#endif

static int _cffi_d_OCSP_response_status(OCSP_RESPONSE * x0)
{
  return OCSP_response_status(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_response_status(PyObject *self, PyObject *arg0)
{
  OCSP_RESPONSE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(549), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_RESPONSE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(549), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_response_status(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_response_status _cffi_d_OCSP_response_status
#endif

static int _cffi_d_OCSP_single_get0_status(OCSP_SINGLERESP * x0, int * x1, ASN1_GENERALIZEDTIME * * x2, ASN1_GENERALIZEDTIME * * x3, ASN1_GENERALIZEDTIME * * x4)
{
  return OCSP_single_get0_status(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OCSP_single_get0_status(PyObject *self, PyObject *args)
{
  OCSP_SINGLERESP * x0;
  int * x1;
  ASN1_GENERALIZEDTIME * * x2;
  ASN1_GENERALIZEDTIME * * x3;
  ASN1_GENERALIZEDTIME * * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "OCSP_single_get0_status", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(798), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OCSP_SINGLERESP *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(798), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(14), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (ASN1_GENERALIZEDTIME * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(14), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(14), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (ASN1_GENERALIZEDTIME * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(14), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(14), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (ASN1_GENERALIZEDTIME * *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(14), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OCSP_single_get0_status(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_OCSP_single_get0_status _cffi_d_OCSP_single_get0_status
#endif

static void _cffi_d_OPENSSL_config(char const * x0)
{
  OPENSSL_config(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OPENSSL_config(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OPENSSL_config(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OPENSSL_config _cffi_d_OPENSSL_config
#endif

static void _cffi_d_OPENSSL_free(void * x0)
{
  OPENSSL_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OPENSSL_free(PyObject *self, PyObject *arg0)
{
  void * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(92), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OPENSSL_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OPENSSL_free _cffi_d_OPENSSL_free
#endif

static void * _cffi_d_OPENSSL_malloc(size_t x0)
{
  return OPENSSL_malloc(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OPENSSL_malloc(PyObject *self, PyObject *arg0)
{
  size_t x0;
  void * result;

  x0 = _cffi_to_c_int(arg0, size_t);
  if (x0 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OPENSSL_malloc(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_OPENSSL_malloc _cffi_d_OPENSSL_malloc
#endif

static void _cffi_d_OPENSSL_no_config(void)
{
  OPENSSL_no_config();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OPENSSL_no_config(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OPENSSL_no_config(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OPENSSL_no_config _cffi_d_OPENSSL_no_config
#endif

static void _cffi_d_OTHERNAME_free(OTHERNAME * x0)
{
  OTHERNAME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OTHERNAME_free(PyObject *self, PyObject *arg0)
{
  OTHERNAME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3338), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (OTHERNAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3338), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OTHERNAME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OTHERNAME_free _cffi_d_OTHERNAME_free
#endif

static OTHERNAME * _cffi_d_OTHERNAME_new(void)
{
  return OTHERNAME_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OTHERNAME_new(PyObject *self, PyObject *noarg)
{
  OTHERNAME * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OTHERNAME_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3338));
}
#else
#  define _cffi_f_OTHERNAME_new _cffi_d_OTHERNAME_new
#endif

static void _cffi_d_OpenSSL_add_all_algorithms(void)
{
  OpenSSL_add_all_algorithms();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OpenSSL_add_all_algorithms(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { OpenSSL_add_all_algorithms(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_OpenSSL_add_all_algorithms _cffi_d_OpenSSL_add_all_algorithms
#endif

static char const * _cffi_d_OpenSSL_version(int x0)
{
  return OpenSSL_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OpenSSL_version(PyObject *self, PyObject *arg0)
{
  int x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OpenSSL_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_OpenSSL_version _cffi_d_OpenSSL_version
#endif

static unsigned long _cffi_d_OpenSSL_version_num(void)
{
  return OpenSSL_version_num();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_OpenSSL_version_num(PyObject *self, PyObject *noarg)
{
  unsigned long result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = OpenSSL_version_num(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_OpenSSL_version_num _cffi_d_OpenSSL_version_num
#endif

static DH * _cffi_d_PEM_read_bio_DHparams(BIO * x0, DH * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_DHparams(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_DHparams(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  DH * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_DHparams", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(285), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_DHparams(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_PEM_read_bio_DHparams _cffi_d_PEM_read_bio_DHparams
#endif

static DSA * _cffi_d_PEM_read_bio_DSAPrivateKey(BIO * x0, DSA * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_DSAPrivateKey(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_DSAPrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_DSAPrivateKey", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(319), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_DSAPrivateKey(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_PEM_read_bio_DSAPrivateKey _cffi_d_PEM_read_bio_DSAPrivateKey
#endif

static DSA * _cffi_d_PEM_read_bio_DSA_PUBKEY(BIO * x0, DSA * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_DSA_PUBKEY(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_DSA_PUBKEY(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_DSA_PUBKEY", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(319), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_DSA_PUBKEY(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_PEM_read_bio_DSA_PUBKEY _cffi_d_PEM_read_bio_DSA_PUBKEY
#endif

static PKCS7 * _cffi_d_PEM_read_bio_PKCS7(BIO * x0, PKCS7 * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_PKCS7(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_PKCS7(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS7 * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  PKCS7 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_PKCS7", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(611), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS7 * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(611), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_PKCS7(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(182));
}
#else
#  define _cffi_f_PEM_read_bio_PKCS7 _cffi_d_PEM_read_bio_PKCS7
#endif

static EVP_PKEY * _cffi_d_PEM_read_bio_PUBKEY(BIO * x0, EVP_PKEY * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_PUBKEY(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_PUBKEY(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_PUBKEY", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(478), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_PUBKEY(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_PEM_read_bio_PUBKEY _cffi_d_PEM_read_bio_PUBKEY
#endif

static EVP_PKEY * _cffi_d_PEM_read_bio_PrivateKey(BIO * x0, EVP_PKEY * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_PrivateKey(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_PrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_PrivateKey", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(478), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_PrivateKey(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_PEM_read_bio_PrivateKey _cffi_d_PEM_read_bio_PrivateKey
#endif

static RSA * _cffi_d_PEM_read_bio_RSAPrivateKey(BIO * x0, RSA * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_RSAPrivateKey(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_RSAPrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_RSAPrivateKey", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(655), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_RSAPrivateKey(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_PEM_read_bio_RSAPrivateKey _cffi_d_PEM_read_bio_RSAPrivateKey
#endif

static RSA * _cffi_d_PEM_read_bio_RSAPublicKey(BIO * x0, RSA * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_RSAPublicKey(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_RSAPublicKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_RSAPublicKey", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(655), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_RSAPublicKey(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_PEM_read_bio_RSAPublicKey _cffi_d_PEM_read_bio_RSAPublicKey
#endif

static X509 * _cffi_d_PEM_read_bio_X509(BIO * x0, X509 * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_X509(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_X509(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509 * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  X509 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_X509", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(718), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(718), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_X509(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_PEM_read_bio_X509 _cffi_d_PEM_read_bio_X509
#endif

static X509 * _cffi_d_PEM_read_bio_X509_AUX(BIO * x0, X509 * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_X509_AUX(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_X509_AUX(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509 * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  X509 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_X509_AUX", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(718), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(718), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_X509_AUX(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_PEM_read_bio_X509_AUX _cffi_d_PEM_read_bio_X509_AUX
#endif

static X509_CRL * _cffi_d_PEM_read_bio_X509_CRL(BIO * x0, X509_CRL * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_X509_CRL(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_X509_CRL(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_CRL * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  X509_CRL * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_X509_CRL", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(763), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(763), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_X509_CRL(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(80));
}
#else
#  define _cffi_f_PEM_read_bio_X509_CRL _cffi_d_PEM_read_bio_X509_CRL
#endif

static X509_REQ * _cffi_d_PEM_read_bio_X509_REQ(BIO * x0, X509_REQ * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return PEM_read_bio_X509_REQ(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_read_bio_X509_REQ(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_REQ * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  X509_REQ * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_read_bio_X509_REQ", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(875), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REQ * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(875), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_read_bio_X509_REQ(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(502));
}
#else
#  define _cffi_f_PEM_read_bio_X509_REQ _cffi_d_PEM_read_bio_X509_REQ
#endif

static int _cffi_d_PEM_write_bio_CMS_stream(BIO * x0, CMS_ContentInfo * x1, BIO * x2, int x3)
{
  return PEM_write_bio_CMS_stream(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_CMS_stream(PyObject *self, PyObject *args)
{
  BIO * x0;
  CMS_ContentInfo * x1;
  BIO * x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_CMS_stream", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(168), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIO *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(160), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_CMS_stream(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_CMS_stream _cffi_d_PEM_write_bio_CMS_stream
#endif

static int _cffi_d_PEM_write_bio_DHparams(BIO * x0, DH * x1)
{
  return PEM_write_bio_DHparams(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_DHparams(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_DHparams", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(299), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_DHparams(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_DHparams _cffi_d_PEM_write_bio_DHparams
#endif

static int _cffi_d_PEM_write_bio_DHxparams(BIO * x0, DH * x1)
{
  return PEM_write_bio_DHxparams(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_DHxparams(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_DHxparams", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(299), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_DHxparams(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_DHxparams _cffi_d_PEM_write_bio_DHxparams
#endif

static int _cffi_d_PEM_write_bio_DSAPrivateKey(BIO * x0, DSA * x1, EVP_CIPHER const * x2, unsigned char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return PEM_write_bio_DSAPrivateKey(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_DSAPrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * x1;
  EVP_CIPHER const * x2;
  unsigned char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_DSAPrivateKey", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(333), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_DSAPrivateKey(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_DSAPrivateKey _cffi_d_PEM_write_bio_DSAPrivateKey
#endif

static int _cffi_d_PEM_write_bio_DSA_PUBKEY(BIO * x0, DSA * x1)
{
  return PEM_write_bio_DSA_PUBKEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_DSA_PUBKEY(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_DSA_PUBKEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(333), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_DSA_PUBKEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_DSA_PUBKEY _cffi_d_PEM_write_bio_DSA_PUBKEY
#endif

static int _cffi_d_PEM_write_bio_ECPrivateKey(BIO * x0, EC_KEY * x1, EVP_CIPHER const * x2, unsigned char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return PEM_write_bio_ECPrivateKey(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_ECPrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  EC_KEY * x1;
  EVP_CIPHER const * x2;
  unsigned char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_ECPrivateKey", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_ECPrivateKey(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_ECPrivateKey _cffi_d_PEM_write_bio_ECPrivateKey
#endif

static int _cffi_d_PEM_write_bio_PKCS7(BIO * x0, PKCS7 * x1)
{
  return PEM_write_bio_PKCS7(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_PKCS7(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS7 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_PKCS7", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(182), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_PKCS7(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_PKCS7 _cffi_d_PEM_write_bio_PKCS7
#endif

static int _cffi_d_PEM_write_bio_PKCS8PrivateKey(BIO * x0, EVP_PKEY * x1, EVP_CIPHER const * x2, char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return PEM_write_bio_PKCS8PrivateKey(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_PKCS8PrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  EVP_CIPHER const * x2;
  char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_PKCS8PrivateKey", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(594), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_PKCS8PrivateKey(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_PKCS8PrivateKey _cffi_d_PEM_write_bio_PKCS8PrivateKey
#endif

static int _cffi_d_PEM_write_bio_PKCS8PrivateKey_nid(BIO * x0, EVP_PKEY * x1, int x2, char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return PEM_write_bio_PKCS8PrivateKey_nid(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_PKCS8PrivateKey_nid(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  int x2;
  char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_PKCS8PrivateKey_nid", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(594), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_PKCS8PrivateKey_nid(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_PKCS8PrivateKey_nid _cffi_d_PEM_write_bio_PKCS8PrivateKey_nid
#endif

static int _cffi_d_PEM_write_bio_PUBKEY(BIO * x0, EVP_PKEY * x1)
{
  return PEM_write_bio_PUBKEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_PUBKEY(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_PUBKEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_PUBKEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_PUBKEY _cffi_d_PEM_write_bio_PUBKEY
#endif

static int _cffi_d_PEM_write_bio_PrivateKey(BIO * x0, EVP_PKEY * x1, EVP_CIPHER const * x2, unsigned char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return PEM_write_bio_PrivateKey(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_PrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  EVP_CIPHER const * x2;
  unsigned char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_PrivateKey", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_PrivateKey(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_PrivateKey _cffi_d_PEM_write_bio_PrivateKey
#endif

static int _cffi_d_PEM_write_bio_RSAPrivateKey(BIO * x0, RSA * x1, EVP_CIPHER const * x2, unsigned char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return PEM_write_bio_RSAPrivateKey(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_RSAPrivateKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * x1;
  EVP_CIPHER const * x2;
  unsigned char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_RSAPrivateKey", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(672), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_RSAPrivateKey(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_RSAPrivateKey _cffi_d_PEM_write_bio_RSAPrivateKey
#endif

static int _cffi_d_PEM_write_bio_RSAPublicKey(BIO * x0, RSA const * x1)
{
  return PEM_write_bio_RSAPublicKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_RSAPublicKey(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_RSAPublicKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1267), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_RSAPublicKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_RSAPublicKey _cffi_d_PEM_write_bio_RSAPublicKey
#endif

static int _cffi_d_PEM_write_bio_X509(BIO * x0, X509 * x1)
{
  return PEM_write_bio_X509(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_X509(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_X509", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_X509(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_X509 _cffi_d_PEM_write_bio_X509
#endif

static int _cffi_d_PEM_write_bio_X509_CRL(BIO * x0, X509_CRL * x1)
{
  return PEM_write_bio_X509_CRL(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_X509_CRL(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_CRL * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_X509_CRL", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_X509_CRL(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_X509_CRL _cffi_d_PEM_write_bio_X509_CRL
#endif

static int _cffi_d_PEM_write_bio_X509_REQ(BIO * x0, X509_REQ * x1)
{
  return PEM_write_bio_X509_REQ(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PEM_write_bio_X509_REQ(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_REQ * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PEM_write_bio_X509_REQ", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(502), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PEM_write_bio_X509_REQ(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PEM_write_bio_X509_REQ _cffi_d_PEM_write_bio_X509_REQ
#endif

static PKCS12 * _cffi_d_PKCS12_create(char * x0, char * x1, EVP_PKEY * x2, X509 * x3, Cryptography_STACK_OF_X509 * x4, int x5, int x6, int x7, int x8, int x9)
{
  return PKCS12_create(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS12_create(PyObject *self, PyObject *args)
{
  char * x0;
  char * x1;
  EVP_PKEY * x2;
  X509 * x3;
  Cryptography_STACK_OF_X509 * x4;
  int x5;
  int x6;
  int x7;
  int x8;
  int x9;
  Py_ssize_t datasize;
  PKCS12 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;

  if (!PyArg_UnpackTuple(args, "PKCS12_create", 10, 10, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(594), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(217), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (X509 *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(28), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(210), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  x7 = _cffi_to_c_int(arg7, int);
  if (x7 == (int)-1 && PyErr_Occurred())
    return NULL;

  x8 = _cffi_to_c_int(arg8, int);
  if (x8 == (int)-1 && PyErr_Occurred())
    return NULL;

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS12_create(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1240));
}
#else
#  define _cffi_f_PKCS12_create _cffi_d_PKCS12_create
#endif

static void _cffi_d_PKCS12_free(PKCS12 * x0)
{
  PKCS12_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS12_free(PyObject *self, PyObject *arg0)
{
  PKCS12 * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1240), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS12 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1240), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { PKCS12_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_PKCS12_free _cffi_d_PKCS12_free
#endif

static int _cffi_d_PKCS12_parse(PKCS12 * x0, char const * x1, EVP_PKEY * * x2, X509 * * x3, Cryptography_STACK_OF_X509 * * x4)
{
  return PKCS12_parse(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS12_parse(PyObject *self, PyObject *args)
{
  PKCS12 * x0;
  char const * x1;
  EVP_PKEY * * x2;
  X509 * * x3;
  Cryptography_STACK_OF_X509 * * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "PKCS12_parse", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1240), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS12 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1240), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(478), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(718), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (X509 * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(718), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2086), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (Cryptography_STACK_OF_X509 * *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(2086), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS12_parse(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS12_parse _cffi_d_PKCS12_parse
#endif

static int _cffi_d_PKCS5_PBKDF2_HMAC(char const * x0, int x1, unsigned char const * x2, int x3, int x4, EVP_MD const * x5, int x6, unsigned char * x7)
{
  return PKCS5_PBKDF2_HMAC(x0, x1, x2, x3, x4, x5, x6, x7);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS5_PBKDF2_HMAC(PyObject *self, PyObject *args)
{
  char const * x0;
  int x1;
  unsigned char const * x2;
  int x3;
  int x4;
  EVP_MD const * x5;
  int x6;
  unsigned char * x7;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;

  if (!PyArg_UnpackTuple(args, "PKCS5_PBKDF2_HMAC", 8, 8, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(226), arg5) < 0)
      return NULL;
  }

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(975), arg7) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS5_PBKDF2_HMAC(x0, x1, x2, x3, x4, x5, x6, x7); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS5_PBKDF2_HMAC _cffi_d_PKCS5_PBKDF2_HMAC
#endif

static int _cffi_d_PKCS5_PBKDF2_HMAC_SHA1(char const * x0, int x1, unsigned char const * x2, int x3, int x4, int x5, unsigned char * x6)
{
  return PKCS5_PBKDF2_HMAC_SHA1(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS5_PBKDF2_HMAC_SHA1(PyObject *self, PyObject *args)
{
  char const * x0;
  int x1;
  unsigned char const * x2;
  int x3;
  int x4;
  int x5;
  unsigned char * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "PKCS5_PBKDF2_HMAC_SHA1", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(975), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS5_PBKDF2_HMAC_SHA1(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS5_PBKDF2_HMAC_SHA1 _cffi_d_PKCS5_PBKDF2_HMAC_SHA1
#endif

static BIO * _cffi_d_PKCS7_dataInit(PKCS7 * x0, BIO * x1)
{
  return PKCS7_dataInit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_dataInit(PyObject *self, PyObject *args)
{
  PKCS7 * x0;
  BIO * x1;
  Py_ssize_t datasize;
  BIO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "PKCS7_dataInit", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(160), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_dataInit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_PKCS7_dataInit _cffi_d_PKCS7_dataInit
#endif

static int _cffi_d_PKCS7_decrypt(PKCS7 * x0, EVP_PKEY * x1, X509 * x2, BIO * x3, int x4)
{
  return PKCS7_decrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_decrypt(PyObject *self, PyObject *args)
{
  PKCS7 * x0;
  EVP_PKEY * x1;
  X509 * x2;
  BIO * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "PKCS7_decrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(28), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIO *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(160), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_decrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_decrypt _cffi_d_PKCS7_decrypt
#endif

static PKCS7 * _cffi_d_PKCS7_encrypt(Cryptography_STACK_OF_X509 * x0, BIO * x1, EVP_CIPHER const * x2, int x3)
{
  return PKCS7_encrypt(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_encrypt(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509 * x0;
  BIO * x1;
  EVP_CIPHER const * x2;
  int x3;
  Py_ssize_t datasize;
  PKCS7 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "PKCS7_encrypt", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(160), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_encrypt(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(182));
}
#else
#  define _cffi_f_PKCS7_encrypt _cffi_d_PKCS7_encrypt
#endif

static void _cffi_d_PKCS7_free(PKCS7 * x0)
{
  PKCS7_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_free(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { PKCS7_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_PKCS7_free _cffi_d_PKCS7_free
#endif

static Cryptography_STACK_OF_X509 * _cffi_d_PKCS7_get0_signers(PKCS7 * x0, Cryptography_STACK_OF_X509 * x1, int x2)
{
  return PKCS7_get0_signers(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_get0_signers(PyObject *self, PyObject *args)
{
  PKCS7 * x0;
  Cryptography_STACK_OF_X509 * x1;
  int x2;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "PKCS7_get0_signers", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(210), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_get0_signers(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(210));
}
#else
#  define _cffi_f_PKCS7_get0_signers _cffi_d_PKCS7_get0_signers
#endif

static PKCS7 * _cffi_d_PKCS7_sign(X509 * x0, EVP_PKEY * x1, Cryptography_STACK_OF_X509 * x2, BIO * x3, int x4)
{
  return PKCS7_sign(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_sign(PyObject *self, PyObject *args)
{
  X509 * x0;
  EVP_PKEY * x1;
  Cryptography_STACK_OF_X509 * x2;
  BIO * x3;
  int x4;
  Py_ssize_t datasize;
  PKCS7 * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "PKCS7_sign", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(210), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIO *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(160), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_sign(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(182));
}
#else
#  define _cffi_f_PKCS7_sign _cffi_d_PKCS7_sign
#endif

static int _cffi_d_PKCS7_type_is_data(PKCS7 * x0)
{
  return PKCS7_type_is_data(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_type_is_data(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_type_is_data(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_type_is_data _cffi_d_PKCS7_type_is_data
#endif

static int _cffi_d_PKCS7_type_is_digest(PKCS7 * x0)
{
  return PKCS7_type_is_digest(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_type_is_digest(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_type_is_digest(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_type_is_digest _cffi_d_PKCS7_type_is_digest
#endif

static int _cffi_d_PKCS7_type_is_encrypted(PKCS7 * x0)
{
  return PKCS7_type_is_encrypted(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_type_is_encrypted(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_type_is_encrypted(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_type_is_encrypted _cffi_d_PKCS7_type_is_encrypted
#endif

static int _cffi_d_PKCS7_type_is_enveloped(PKCS7 * x0)
{
  return PKCS7_type_is_enveloped(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_type_is_enveloped(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_type_is_enveloped(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_type_is_enveloped _cffi_d_PKCS7_type_is_enveloped
#endif

static int _cffi_d_PKCS7_type_is_signed(PKCS7 * x0)
{
  return PKCS7_type_is_signed(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_type_is_signed(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_type_is_signed(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_type_is_signed _cffi_d_PKCS7_type_is_signed
#endif

static int _cffi_d_PKCS7_type_is_signedAndEnveloped(PKCS7 * x0)
{
  return PKCS7_type_is_signedAndEnveloped(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_type_is_signedAndEnveloped(PyObject *self, PyObject *arg0)
{
  PKCS7 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_type_is_signedAndEnveloped(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_type_is_signedAndEnveloped _cffi_d_PKCS7_type_is_signedAndEnveloped
#endif

static int _cffi_d_PKCS7_verify(PKCS7 * x0, Cryptography_STACK_OF_X509 * x1, X509_STORE * x2, BIO * x3, BIO * x4, int x5)
{
  return PKCS7_verify(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS7_verify(PyObject *self, PyObject *args)
{
  PKCS7 * x0;
  Cryptography_STACK_OF_X509 * x1;
  X509_STORE * x2;
  BIO * x3;
  BIO * x4;
  int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "PKCS7_verify", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(182), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(210), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(278), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIO *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(160), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (BIO *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(160), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = PKCS7_verify(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_PKCS7_verify _cffi_d_PKCS7_verify
#endif

static void _cffi_d_PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO * x0)
{
  PKCS8_PRIV_KEY_INFO_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_PKCS8_PRIV_KEY_INFO_free(PyObject *self, PyObject *arg0)
{
  PKCS8_PRIV_KEY_INFO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(496), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (PKCS8_PRIV_KEY_INFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(496), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { PKCS8_PRIV_KEY_INFO_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_PKCS8_PRIV_KEY_INFO_free _cffi_d_PKCS8_PRIV_KEY_INFO_free
#endif

static void _cffi_d_POLICYINFO_free(POLICYINFO * x0)
{
  POLICYINFO_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_POLICYINFO_free(PyObject *self, PyObject *arg0)
{
  POLICYINFO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1429), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1429), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { POLICYINFO_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_POLICYINFO_free _cffi_d_POLICYINFO_free
#endif

static POLICYINFO * _cffi_d_POLICYINFO_new(void)
{
  return POLICYINFO_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_POLICYINFO_new(PyObject *self, PyObject *noarg)
{
  POLICYINFO * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = POLICYINFO_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1429));
}
#else
#  define _cffi_f_POLICYINFO_new _cffi_d_POLICYINFO_new
#endif

static void _cffi_d_POLICYQUALINFO_free(POLICYQUALINFO * x0)
{
  POLICYQUALINFO_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_POLICYQUALINFO_free(PyObject *self, PyObject *arg0)
{
  POLICYQUALINFO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1436), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (POLICYQUALINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1436), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { POLICYQUALINFO_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_POLICYQUALINFO_free _cffi_d_POLICYQUALINFO_free
#endif

static POLICYQUALINFO * _cffi_d_POLICYQUALINFO_new(void)
{
  return POLICYQUALINFO_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_POLICYQUALINFO_new(PyObject *self, PyObject *noarg)
{
  POLICYQUALINFO * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = POLICYQUALINFO_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1436));
}
#else
#  define _cffi_f_POLICYQUALINFO_new _cffi_d_POLICYQUALINFO_new
#endif

static void _cffi_d_POLICY_CONSTRAINTS_free(POLICY_CONSTRAINTS * x0)
{
  POLICY_CONSTRAINTS_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_POLICY_CONSTRAINTS_free(PyObject *self, PyObject *arg0)
{
  POLICY_CONSTRAINTS * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3356), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (POLICY_CONSTRAINTS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3356), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { POLICY_CONSTRAINTS_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_POLICY_CONSTRAINTS_free _cffi_d_POLICY_CONSTRAINTS_free
#endif

static POLICY_CONSTRAINTS * _cffi_d_POLICY_CONSTRAINTS_new(void)
{
  return POLICY_CONSTRAINTS_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_POLICY_CONSTRAINTS_new(PyObject *self, PyObject *noarg)
{
  POLICY_CONSTRAINTS * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = POLICY_CONSTRAINTS_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3356));
}
#else
#  define _cffi_f_POLICY_CONSTRAINTS_new _cffi_d_POLICY_CONSTRAINTS_new
#endif

static void _cffi_d_RAND_add(void const * x0, int x1, double x2)
{
  RAND_add(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_add(PyObject *self, PyObject *args)
{
  void const * x0;
  int x1;
  double x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "RAND_add", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1052), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RAND_add(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RAND_add _cffi_d_RAND_add
#endif

static int _cffi_d_RAND_bytes(unsigned char * x0, int x1)
{
  return RAND_bytes(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_bytes(PyObject *self, PyObject *args)
{
  unsigned char * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RAND_bytes", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(975), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_bytes(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_bytes _cffi_d_RAND_bytes
#endif

static void _cffi_d_RAND_cleanup(void)
{
  RAND_cleanup();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_cleanup(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RAND_cleanup(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RAND_cleanup _cffi_d_RAND_cleanup
#endif

static int _cffi_d_RAND_egd(char const * x0)
{
  return RAND_egd(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_egd(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_egd(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_egd _cffi_d_RAND_egd
#endif

static int _cffi_d_RAND_egd_bytes(char const * x0, int x1)
{
  return RAND_egd_bytes(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_egd_bytes(PyObject *self, PyObject *args)
{
  char const * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RAND_egd_bytes", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_egd_bytes(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_egd_bytes _cffi_d_RAND_egd_bytes
#endif

static char const * _cffi_d_RAND_file_name(char * x0, size_t x1)
{
  return RAND_file_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_file_name(PyObject *self, PyObject *args)
{
  char * x0;
  size_t x1;
  Py_ssize_t datasize;
  char const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RAND_file_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(594), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_file_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_RAND_file_name _cffi_d_RAND_file_name
#endif

static int _cffi_d_RAND_load_file(char const * x0, long x1)
{
  return RAND_load_file(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_load_file(PyObject *self, PyObject *args)
{
  char const * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RAND_load_file", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_load_file(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_load_file _cffi_d_RAND_load_file
#endif

static int _cffi_d_RAND_query_egd_bytes(char const * x0, unsigned char * x1, int x2)
{
  return RAND_query_egd_bytes(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_query_egd_bytes(PyObject *self, PyObject *args)
{
  char const * x0;
  unsigned char * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "RAND_query_egd_bytes", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_query_egd_bytes(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_query_egd_bytes _cffi_d_RAND_query_egd_bytes
#endif

static void _cffi_d_RAND_seed(void const * x0, int x1)
{
  RAND_seed(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_seed(PyObject *self, PyObject *args)
{
  void const * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RAND_seed", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1052), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RAND_seed(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RAND_seed _cffi_d_RAND_seed
#endif

static int _cffi_d_RAND_status(void)
{
  return RAND_status();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_status(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_status(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_status _cffi_d_RAND_status
#endif

static int _cffi_d_RAND_write_file(char const * x0)
{
  return RAND_write_file(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RAND_write_file(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RAND_write_file(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RAND_write_file _cffi_d_RAND_write_file
#endif

static RSA * _cffi_d_RSAPublicKey_dup(RSA * x0)
{
  return RSAPublicKey_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSAPublicKey_dup(PyObject *self, PyObject *arg0)
{
  RSA * x0;
  Py_ssize_t datasize;
  RSA * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSAPublicKey_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_RSAPublicKey_dup _cffi_d_RSAPublicKey_dup
#endif

static void _cffi_d_RSA_blinding_off(RSA * x0)
{
  RSA_blinding_off(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_blinding_off(PyObject *self, PyObject *arg0)
{
  RSA * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RSA_blinding_off(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RSA_blinding_off _cffi_d_RSA_blinding_off
#endif

static int _cffi_d_RSA_blinding_on(RSA * x0, BN_CTX * x1)
{
  return RSA_blinding_on(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_blinding_on(PyObject *self, PyObject *args)
{
  RSA * x0;
  BN_CTX * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RSA_blinding_on", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BN_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(132), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_blinding_on(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_blinding_on _cffi_d_RSA_blinding_on
#endif

static int _cffi_d_RSA_check_key(RSA const * x0)
{
  return RSA_check_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_check_key(PyObject *self, PyObject *arg0)
{
  RSA const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1267), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_check_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_check_key _cffi_d_RSA_check_key
#endif

static void _cffi_d_RSA_free(RSA * x0)
{
  RSA_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_free(PyObject *self, PyObject *arg0)
{
  RSA * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RSA_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RSA_free _cffi_d_RSA_free
#endif

static int _cffi_d_RSA_generate_key_ex(RSA * x0, int x1, BIGNUM * x2, BN_GENCB * x3)
{
  return RSA_generate_key_ex(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_generate_key_ex(PyObject *self, PyObject *args)
{
  RSA * x0;
  int x1;
  BIGNUM * x2;
  BN_GENCB * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "RSA_generate_key_ex", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1496), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BN_GENCB *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1496), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_generate_key_ex(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_generate_key_ex _cffi_d_RSA_generate_key_ex
#endif

static void _cffi_d_RSA_get0_crt_params(RSA const * x0, BIGNUM const * * x1, BIGNUM const * * x2, BIGNUM const * * x3)
{
  RSA_get0_crt_params(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_get0_crt_params(PyObject *self, PyObject *args)
{
  RSA const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  BIGNUM const * * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "RSA_get0_crt_params", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1267), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1619), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RSA_get0_crt_params(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RSA_get0_crt_params _cffi_d_RSA_get0_crt_params
#endif

static void _cffi_d_RSA_get0_factors(RSA const * x0, BIGNUM const * * x1, BIGNUM const * * x2)
{
  RSA_get0_factors(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_get0_factors(PyObject *self, PyObject *args)
{
  RSA const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "RSA_get0_factors", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1267), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RSA_get0_factors(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RSA_get0_factors _cffi_d_RSA_get0_factors
#endif

static void _cffi_d_RSA_get0_key(RSA const * x0, BIGNUM const * * x1, BIGNUM const * * x2, BIGNUM const * * x3)
{
  RSA_get0_key(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_get0_key(PyObject *self, PyObject *args)
{
  RSA const * x0;
  BIGNUM const * * x1;
  BIGNUM const * * x2;
  BIGNUM const * * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "RSA_get0_key", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1267), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1619), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1619), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1619), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM const * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1619), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RSA_get0_key(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RSA_get0_key _cffi_d_RSA_get0_key
#endif

static RSA * _cffi_d_RSA_new(void)
{
  return RSA_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_new(PyObject *self, PyObject *noarg)
{
  RSA * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_RSA_new _cffi_d_RSA_new
#endif

static int _cffi_d_RSA_padding_add_PKCS1_OAEP(unsigned char * x0, int x1, unsigned char const * x2, int x3, unsigned char const * x4, int x5)
{
  return RSA_padding_add_PKCS1_OAEP(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_padding_add_PKCS1_OAEP(PyObject *self, PyObject *args)
{
  unsigned char * x0;
  int x1;
  unsigned char const * x2;
  int x3;
  unsigned char const * x4;
  int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "RSA_padding_add_PKCS1_OAEP", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(975), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(148), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_padding_add_PKCS1_OAEP(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_padding_add_PKCS1_OAEP _cffi_d_RSA_padding_add_PKCS1_OAEP
#endif

static int _cffi_d_RSA_padding_add_PKCS1_PSS(RSA * x0, unsigned char * x1, unsigned char const * x2, EVP_MD const * x3, int x4)
{
  return RSA_padding_add_PKCS1_PSS(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_padding_add_PKCS1_PSS(PyObject *self, PyObject *args)
{
  RSA * x0;
  unsigned char * x1;
  unsigned char const * x2;
  EVP_MD const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "RSA_padding_add_PKCS1_PSS", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(226), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_padding_add_PKCS1_PSS(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_padding_add_PKCS1_PSS _cffi_d_RSA_padding_add_PKCS1_PSS
#endif

static int _cffi_d_RSA_padding_check_PKCS1_OAEP(unsigned char * x0, int x1, unsigned char const * x2, int x3, int x4, unsigned char const * x5, int x6)
{
  return RSA_padding_check_PKCS1_OAEP(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_padding_check_PKCS1_OAEP(PyObject *self, PyObject *args)
{
  unsigned char * x0;
  int x1;
  unsigned char const * x2;
  int x3;
  int x4;
  unsigned char const * x5;
  int x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "RSA_padding_check_PKCS1_OAEP", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(975), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(148), arg5) < 0)
      return NULL;
  }

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_padding_check_PKCS1_OAEP(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_padding_check_PKCS1_OAEP _cffi_d_RSA_padding_check_PKCS1_OAEP
#endif

static int _cffi_d_RSA_print(BIO * x0, RSA const * x1, int x2)
{
  return RSA_print(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "RSA_print", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1267), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_print(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_print _cffi_d_RSA_print
#endif

static int _cffi_d_RSA_private_decrypt(int x0, unsigned char const * x1, unsigned char * x2, RSA * x3, int x4)
{
  return RSA_private_decrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_private_decrypt(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  unsigned char * x2;
  RSA * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "RSA_private_decrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (RSA *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(672), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_private_decrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_private_decrypt _cffi_d_RSA_private_decrypt
#endif

static int _cffi_d_RSA_private_encrypt(int x0, unsigned char const * x1, unsigned char * x2, RSA * x3, int x4)
{
  return RSA_private_encrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_private_encrypt(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  unsigned char * x2;
  RSA * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "RSA_private_encrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (RSA *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(672), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_private_encrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_private_encrypt _cffi_d_RSA_private_encrypt
#endif

static int _cffi_d_RSA_public_decrypt(int x0, unsigned char const * x1, unsigned char * x2, RSA * x3, int x4)
{
  return RSA_public_decrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_public_decrypt(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  unsigned char * x2;
  RSA * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "RSA_public_decrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (RSA *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(672), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_public_decrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_public_decrypt _cffi_d_RSA_public_decrypt
#endif

static int _cffi_d_RSA_public_encrypt(int x0, unsigned char const * x1, unsigned char * x2, RSA * x3, int x4)
{
  return RSA_public_encrypt(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_public_encrypt(PyObject *self, PyObject *args)
{
  int x0;
  unsigned char const * x1;
  unsigned char * x2;
  RSA * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "RSA_public_encrypt", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (RSA *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(672), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_public_encrypt(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_public_encrypt _cffi_d_RSA_public_encrypt
#endif

static int _cffi_d_RSA_set0_crt_params(RSA * x0, BIGNUM * x1, BIGNUM * x2, BIGNUM * x3)
{
  return RSA_set0_crt_params(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_set0_crt_params(PyObject *self, PyObject *args)
{
  RSA * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "RSA_set0_crt_params", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_set0_crt_params(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_set0_crt_params _cffi_d_RSA_set0_crt_params
#endif

static int _cffi_d_RSA_set0_factors(RSA * x0, BIGNUM * x1, BIGNUM * x2)
{
  return RSA_set0_factors(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_set0_factors(PyObject *self, PyObject *args)
{
  RSA * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "RSA_set0_factors", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_set0_factors(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_set0_factors _cffi_d_RSA_set0_factors
#endif

static int _cffi_d_RSA_set0_key(RSA * x0, BIGNUM * x1, BIGNUM * x2, BIGNUM * x3)
{
  return RSA_set0_key(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_set0_key(PyObject *self, PyObject *args)
{
  RSA * x0;
  BIGNUM * x1;
  BIGNUM * x2;
  BIGNUM * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "RSA_set0_key", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(20), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (BIGNUM *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_set0_key(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_set0_key _cffi_d_RSA_set0_key
#endif

static int _cffi_d_RSA_size(RSA const * x0)
{
  return RSA_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_size(PyObject *self, PyObject *arg0)
{
  RSA const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1267), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1267), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_size _cffi_d_RSA_size
#endif

static int _cffi_d_RSA_verify_PKCS1_PSS(RSA * x0, unsigned char const * x1, EVP_MD const * x2, unsigned char const * x3, int x4)
{
  return RSA_verify_PKCS1_PSS(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RSA_verify_PKCS1_PSS(PyObject *self, PyObject *args)
{
  RSA * x0;
  unsigned char const * x1;
  EVP_MD const * x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "RSA_verify_PKCS1_PSS", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(226), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RSA_verify_PKCS1_PSS(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_RSA_verify_PKCS1_PSS _cffi_d_RSA_verify_PKCS1_PSS
#endif

static void _cffi_d_SCT_LIST_free(Cryptography_STACK_OF_SCT * x0)
{
  SCT_LIST_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SCT_LIST_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_SCT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_SCT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3210), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SCT_LIST_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SCT_LIST_free _cffi_d_SCT_LIST_free
#endif

static size_t _cffi_d_SCT_get0_log_id(SCT const * x0, unsigned char * * x1)
{
  return SCT_get0_log_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SCT_get0_log_id(PyObject *self, PyObject *args)
{
  SCT const * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SCT_get0_log_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(970), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SCT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(970), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SCT_get0_log_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_SCT_get0_log_id _cffi_d_SCT_get0_log_id
#endif

static ct_log_entry_type_t _cffi_d_SCT_get_log_entry_type(SCT const * x0)
{
  return SCT_get_log_entry_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SCT_get_log_entry_type(PyObject *self, PyObject *arg0)
{
  SCT const * x0;
  Py_ssize_t datasize;
  ct_log_entry_type_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(970), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SCT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(970), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SCT_get_log_entry_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_deref((char *)&result, _cffi_type(3780));
}
#else
#  define _cffi_f_SCT_get_log_entry_type _cffi_d_SCT_get_log_entry_type
#endif

static uint64_t _cffi_d_SCT_get_timestamp(SCT const * x0)
{
  return SCT_get_timestamp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SCT_get_timestamp(PyObject *self, PyObject *arg0)
{
  SCT const * x0;
  Py_ssize_t datasize;
  uint64_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(970), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SCT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(970), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SCT_get_timestamp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, uint64_t);
}
#else
#  define _cffi_f_SCT_get_timestamp _cffi_d_SCT_get_timestamp
#endif

static sct_version_t _cffi_d_SCT_get_version(SCT const * x0)
{
  return SCT_get_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SCT_get_version(PyObject *self, PyObject *arg0)
{
  SCT const * x0;
  Py_ssize_t datasize;
  sct_version_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(970), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SCT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(970), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SCT_get_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_deref((char *)&result, _cffi_type(3783));
}
#else
#  define _cffi_f_SCT_get_version _cffi_d_SCT_get_version
#endif

static int _cffi_d_SCT_set_source(SCT * x0, sct_source_t x1)
{
  return SCT_set_source(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SCT_set_source(PyObject *self, PyObject *args)
{
  SCT * x0;
  sct_source_t x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SCT_set_source", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2149), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SCT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2149), arg0) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2150), arg1) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SCT_set_source(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SCT_set_source _cffi_d_SCT_set_source
#endif

static PKCS7 * _cffi_d_SMIME_read_PKCS7(BIO * x0, BIO * * x1)
{
  return SMIME_read_PKCS7(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SMIME_read_PKCS7(PyObject *self, PyObject *args)
{
  BIO * x0;
  BIO * * x1;
  Py_ssize_t datasize;
  PKCS7 * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SMIME_read_PKCS7", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(607), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(607), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SMIME_read_PKCS7(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(182));
}
#else
#  define _cffi_f_SMIME_read_PKCS7 _cffi_d_SMIME_read_PKCS7
#endif

static int _cffi_d_SMIME_write_PKCS7(BIO * x0, PKCS7 * x1, BIO * x2, int x3)
{
  return SMIME_write_PKCS7(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SMIME_write_PKCS7(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS7 * x1;
  BIO * x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "SMIME_write_PKCS7", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(182), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIO *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(160), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SMIME_write_PKCS7(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SMIME_write_PKCS7 _cffi_d_SMIME_write_PKCS7
#endif

static char * _cffi_d_SSL_CIPHER_description(SSL_CIPHER const * x0, char * x1, int x2)
{
  return SSL_CIPHER_description(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CIPHER_description(PyObject *self, PyObject *args)
{
  SSL_CIPHER const * x0;
  char * x1;
  int x2;
  Py_ssize_t datasize;
  char * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CIPHER_description", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(925), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(925), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CIPHER_description(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_SSL_CIPHER_description _cffi_d_SSL_CIPHER_description
#endif

static int _cffi_d_SSL_CIPHER_get_bits(SSL_CIPHER const * x0, int * x1)
{
  return SSL_CIPHER_get_bits(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CIPHER_get_bits(PyObject *self, PyObject *args)
{
  SSL_CIPHER const * x0;
  int * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CIPHER_get_bits", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(925), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(925), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CIPHER_get_bits(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CIPHER_get_bits _cffi_d_SSL_CIPHER_get_bits
#endif

static char const * _cffi_d_SSL_CIPHER_get_name(SSL_CIPHER const * x0)
{
  return SSL_CIPHER_get_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CIPHER_get_name(PyObject *self, PyObject *arg0)
{
  SSL_CIPHER const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(925), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(925), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CIPHER_get_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_CIPHER_get_name _cffi_d_SSL_CIPHER_get_name
#endif

static char const * _cffi_d_SSL_CIPHER_get_version(SSL_CIPHER const * x0)
{
  return SSL_CIPHER_get_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CIPHER_get_version(PyObject *self, PyObject *arg0)
{
  SSL_CIPHER const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(925), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(925), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CIPHER_get_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_CIPHER_get_version _cffi_d_SSL_CIPHER_get_version
#endif

static char const * _cffi_d_SSL_COMP_get_name(COMP_METHOD const * x0)
{
  return SSL_COMP_get_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_COMP_get_name(PyObject *self, PyObject *arg0)
{
  COMP_METHOD const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(939), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (COMP_METHOD const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(939), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_COMP_get_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_COMP_get_name _cffi_d_SSL_COMP_get_name
#endif

static int _cffi_d_SSL_CTX_add_client_CA(SSL_CTX * x0, X509 * x1)
{
  return SSL_CTX_add_client_CA(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_add_client_CA(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_add_client_CA", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_add_client_CA(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_add_client_CA _cffi_d_SSL_CTX_add_client_CA
#endif

static unsigned long _cffi_d_SSL_CTX_add_extra_chain_cert(SSL_CTX * x0, X509 * x1)
{
  return SSL_CTX_add_extra_chain_cert(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_add_extra_chain_cert(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  X509 * x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_add_extra_chain_cert", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_add_extra_chain_cert(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_add_extra_chain_cert _cffi_d_SSL_CTX_add_extra_chain_cert
#endif

static int _cffi_d_SSL_CTX_check_private_key(SSL_CTX const * x0)
{
  return SSL_CTX_check_private_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_check_private_key(PyObject *self, PyObject *arg0)
{
  SSL_CTX const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_check_private_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_check_private_key _cffi_d_SSL_CTX_check_private_key
#endif

static unsigned long _cffi_d_SSL_CTX_clear_options(SSL_CTX * x0, unsigned long x1)
{
  return SSL_CTX_clear_options(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_clear_options(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_clear_options", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_clear_options(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_clear_options _cffi_d_SSL_CTX_clear_options
#endif

static void _cffi_d_SSL_CTX_free(SSL_CTX * x0)
{
  SSL_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_free(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_free _cffi_d_SSL_CTX_free
#endif

static X509_STORE * _cffi_d_SSL_CTX_get_cert_store(SSL_CTX const * x0)
{
  return SSL_CTX_get_cert_store(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_cert_store(PyObject *self, PyObject *arg0)
{
  SSL_CTX const * x0;
  Py_ssize_t datasize;
  X509_STORE * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_cert_store(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(278));
}
#else
#  define _cffi_f_SSL_CTX_get_cert_store _cffi_d_SSL_CTX_get_cert_store
#endif

static void * _cffi_d_SSL_CTX_get_ex_data(SSL_CTX const * x0, int x1)
{
  return SSL_CTX_get_ex_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_ex_data(PyObject *self, PyObject *args)
{
  SSL_CTX const * x0;
  int x1;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_get_ex_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_ex_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_SSL_CTX_get_ex_data _cffi_d_SSL_CTX_get_ex_data
#endif

static int _cffi_d_SSL_CTX_get_ex_new_index(long x0, void * x1, CRYPTO_EX_new * x2, CRYPTO_EX_dup * x3, CRYPTO_EX_free * x4)
{
  return SSL_CTX_get_ex_new_index(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_ex_new_index(PyObject *self, PyObject *args)
{
  long x0;
  void * x1;
  CRYPTO_EX_new * x2;
  CRYPTO_EX_dup * x3;
  CRYPTO_EX_free * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_get_ex_new_index", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, long);
  if (x0 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2762), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (CRYPTO_EX_new *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(2762), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2763), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (CRYPTO_EX_dup *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(2763), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2764), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (CRYPTO_EX_free *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(2764), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_ex_new_index(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_get_ex_new_index _cffi_d_SSL_CTX_get_ex_new_index
#endif

static void(* _cffi_d_SSL_CTX_get_info_callback(SSL_CTX * x0))(SSL const *, int, int)
{
  return SSL_CTX_get_info_callback(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_info_callback(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  void(* result)(SSL const *, int, int);

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_info_callback(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3400));
}
#else
#  define _cffi_f_SSL_CTX_get_info_callback _cffi_d_SSL_CTX_get_info_callback
#endif

static unsigned long _cffi_d_SSL_CTX_get_mode(SSL_CTX * x0)
{
  return SSL_CTX_get_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_mode(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_get_mode _cffi_d_SSL_CTX_get_mode
#endif

static unsigned long _cffi_d_SSL_CTX_get_options(SSL_CTX * x0)
{
  return SSL_CTX_get_options(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_options(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_options(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_get_options _cffi_d_SSL_CTX_get_options
#endif

static unsigned long _cffi_d_SSL_CTX_get_session_cache_mode(SSL_CTX * x0)
{
  return SSL_CTX_get_session_cache_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_session_cache_mode(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_session_cache_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_get_session_cache_mode _cffi_d_SSL_CTX_get_session_cache_mode
#endif

static SSL_METHOD const * _cffi_d_SSL_CTX_get_ssl_method(SSL_CTX * x0)
{
  return SSL_CTX_get_ssl_method(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_ssl_method(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  SSL_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_ssl_method(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSL_CTX_get_ssl_method _cffi_d_SSL_CTX_get_ssl_method
#endif

static long _cffi_d_SSL_CTX_get_timeout(SSL_CTX const * x0)
{
  return SSL_CTX_get_timeout(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_timeout(PyObject *self, PyObject *arg0)
{
  SSL_CTX const * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_timeout(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_get_timeout _cffi_d_SSL_CTX_get_timeout
#endif

static int(* _cffi_d_SSL_CTX_get_verify_callback(SSL_CTX const * x0))(int, X509_STORE_CTX *)
{
  return SSL_CTX_get_verify_callback(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_verify_callback(PyObject *self, PyObject *arg0)
{
  SSL_CTX const * x0;
  Py_ssize_t datasize;
  int(* result)(int, X509_STORE_CTX *);

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_verify_callback(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3396));
}
#else
#  define _cffi_f_SSL_CTX_get_verify_callback _cffi_d_SSL_CTX_get_verify_callback
#endif

static int _cffi_d_SSL_CTX_get_verify_depth(SSL_CTX const * x0)
{
  return SSL_CTX_get_verify_depth(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_verify_depth(PyObject *self, PyObject *arg0)
{
  SSL_CTX const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_verify_depth(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_get_verify_depth _cffi_d_SSL_CTX_get_verify_depth
#endif

static int _cffi_d_SSL_CTX_get_verify_mode(SSL_CTX const * x0)
{
  return SSL_CTX_get_verify_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_get_verify_mode(PyObject *self, PyObject *arg0)
{
  SSL_CTX const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(895), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(895), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_get_verify_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_get_verify_mode _cffi_d_SSL_CTX_get_verify_mode
#endif

static int _cffi_d_SSL_CTX_load_verify_locations(SSL_CTX * x0, char const * x1, char const * x2)
{
  return SSL_CTX_load_verify_locations(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_load_verify_locations(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  char const * x1;
  char const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_load_verify_locations", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(57), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_load_verify_locations(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_load_verify_locations _cffi_d_SSL_CTX_load_verify_locations
#endif

static SSL_CTX * _cffi_d_SSL_CTX_new(SSL_METHOD * x0)
{
  return SSL_CTX_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_new(PyObject *self, PyObject *arg0)
{
  SSL_METHOD * x0;
  Py_ssize_t datasize;
  SSL_CTX * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(701), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_METHOD *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(701), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(684));
}
#else
#  define _cffi_f_SSL_CTX_new _cffi_d_SSL_CTX_new
#endif

static long _cffi_d_SSL_CTX_sess_accept(SSL_CTX * x0)
{
  return SSL_CTX_sess_accept(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_accept(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_accept(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_accept _cffi_d_SSL_CTX_sess_accept
#endif

static long _cffi_d_SSL_CTX_sess_accept_good(SSL_CTX * x0)
{
  return SSL_CTX_sess_accept_good(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_accept_good(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_accept_good(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_accept_good _cffi_d_SSL_CTX_sess_accept_good
#endif

static long _cffi_d_SSL_CTX_sess_accept_renegotiate(SSL_CTX * x0)
{
  return SSL_CTX_sess_accept_renegotiate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_accept_renegotiate(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_accept_renegotiate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_accept_renegotiate _cffi_d_SSL_CTX_sess_accept_renegotiate
#endif

static long _cffi_d_SSL_CTX_sess_cache_full(SSL_CTX * x0)
{
  return SSL_CTX_sess_cache_full(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_cache_full(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_cache_full(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_cache_full _cffi_d_SSL_CTX_sess_cache_full
#endif

static long _cffi_d_SSL_CTX_sess_cb_hits(SSL_CTX * x0)
{
  return SSL_CTX_sess_cb_hits(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_cb_hits(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_cb_hits(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_cb_hits _cffi_d_SSL_CTX_sess_cb_hits
#endif

static long _cffi_d_SSL_CTX_sess_connect(SSL_CTX * x0)
{
  return SSL_CTX_sess_connect(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_connect(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_connect(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_connect _cffi_d_SSL_CTX_sess_connect
#endif

static long _cffi_d_SSL_CTX_sess_connect_good(SSL_CTX * x0)
{
  return SSL_CTX_sess_connect_good(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_connect_good(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_connect_good(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_connect_good _cffi_d_SSL_CTX_sess_connect_good
#endif

static long _cffi_d_SSL_CTX_sess_connect_renegotiate(SSL_CTX * x0)
{
  return SSL_CTX_sess_connect_renegotiate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_connect_renegotiate(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_connect_renegotiate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_connect_renegotiate _cffi_d_SSL_CTX_sess_connect_renegotiate
#endif

static long _cffi_d_SSL_CTX_sess_hits(SSL_CTX * x0)
{
  return SSL_CTX_sess_hits(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_hits(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_hits(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_hits _cffi_d_SSL_CTX_sess_hits
#endif

static long _cffi_d_SSL_CTX_sess_misses(SSL_CTX * x0)
{
  return SSL_CTX_sess_misses(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_misses(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_misses(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_misses _cffi_d_SSL_CTX_sess_misses
#endif

static long _cffi_d_SSL_CTX_sess_number(SSL_CTX * x0)
{
  return SSL_CTX_sess_number(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_number(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_number(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_number _cffi_d_SSL_CTX_sess_number
#endif

static long _cffi_d_SSL_CTX_sess_timeouts(SSL_CTX * x0)
{
  return SSL_CTX_sess_timeouts(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_sess_timeouts(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_sess_timeouts(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_sess_timeouts _cffi_d_SSL_CTX_sess_timeouts
#endif

static int _cffi_d_SSL_CTX_set_alpn_protos(SSL_CTX * x0, unsigned char const * x1, unsigned int x2)
{
  return SSL_CTX_set_alpn_protos(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_alpn_protos(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  unsigned char const * x1;
  unsigned int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_alpn_protos", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned int);
  if (x2 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_alpn_protos(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_alpn_protos _cffi_d_SSL_CTX_set_alpn_protos
#endif

static void _cffi_d_SSL_CTX_set_alpn_select_cb(SSL_CTX * x0, int(* x1)(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *), void * x2)
{
  SSL_CTX_set_alpn_select_cb(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_alpn_select_cb(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_alpn_select_cb", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *))_cffi_to_c_pointer(arg1, _cffi_type(3430));
  if (x1 == (int(*)(SSL *, unsigned char const * *, unsigned char *, unsigned char const *, unsigned int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_alpn_select_cb(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_alpn_select_cb _cffi_d_SSL_CTX_set_alpn_select_cb
#endif

static void _cffi_d_SSL_CTX_set_cert_cb(SSL_CTX * x0, int(* x1)(SSL *, void *), void * x2)
{
  SSL_CTX_set_cert_cb(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_cert_cb(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(SSL *, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_cert_cb", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL *, void *))_cffi_to_c_pointer(arg1, _cffi_type(2941));
  if (x1 == (int(*)(SSL *, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_cert_cb(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_cert_cb _cffi_d_SSL_CTX_set_cert_cb
#endif

static void _cffi_d_SSL_CTX_set_cert_store(SSL_CTX * x0, X509_STORE * x1)
{
  SSL_CTX_set_cert_store(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_cert_store(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  X509_STORE * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_cert_store", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(278), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_cert_store(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_cert_store _cffi_d_SSL_CTX_set_cert_store
#endif

static void _cffi_d_SSL_CTX_set_cert_verify_callback(SSL_CTX * x0, int(* x1)(X509_STORE_CTX *, void *), void * x2)
{
  SSL_CTX_set_cert_verify_callback(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_cert_verify_callback(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(X509_STORE_CTX *, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_cert_verify_callback", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(X509_STORE_CTX *, void *))_cffi_to_c_pointer(arg1, _cffi_type(3449));
  if (x1 == (int(*)(X509_STORE_CTX *, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_cert_verify_callback(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_cert_verify_callback _cffi_d_SSL_CTX_set_cert_verify_callback
#endif

static int _cffi_d_SSL_CTX_set_cipher_list(SSL_CTX * x0, char const * x1)
{
  return SSL_CTX_set_cipher_list(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_cipher_list(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_cipher_list", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_cipher_list(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_cipher_list _cffi_d_SSL_CTX_set_cipher_list
#endif

static void _cffi_d_SSL_CTX_set_client_CA_list(SSL_CTX * x0, Cryptography_STACK_OF_X509_NAME * x1)
{
  SSL_CTX_set_client_CA_list(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_client_CA_list(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  Cryptography_STACK_OF_X509_NAME * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_client_CA_list", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(837), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(837), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_client_CA_list(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_client_CA_list _cffi_d_SSL_CTX_set_client_CA_list
#endif

static int _cffi_d_SSL_CTX_set_client_cert_engine(SSL_CTX * x0, ENGINE * x1)
{
  return SSL_CTX_set_client_cert_engine(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_client_cert_engine(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  ENGINE * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_client_cert_engine", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(435), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ENGINE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(435), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_client_cert_engine(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_client_cert_engine _cffi_d_SSL_CTX_set_client_cert_engine
#endif

static void _cffi_d_SSL_CTX_set_default_passwd_cb(SSL_CTX * x0, int(* x1)(char *, int, int, void *))
{
  SSL_CTX_set_default_passwd_cb(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_default_passwd_cb(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(char *, int, int, void *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_default_passwd_cb", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg1, _cffi_type(290));
  if (x1 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_default_passwd_cb(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_default_passwd_cb _cffi_d_SSL_CTX_set_default_passwd_cb
#endif

static void _cffi_d_SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX * x0, void * x1)
{
  SSL_CTX_set_default_passwd_cb_userdata(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_default_passwd_cb_userdata(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  void * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_default_passwd_cb_userdata", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_default_passwd_cb_userdata(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_default_passwd_cb_userdata _cffi_d_SSL_CTX_set_default_passwd_cb_userdata
#endif

static int _cffi_d_SSL_CTX_set_default_verify_paths(SSL_CTX * x0)
{
  return SSL_CTX_set_default_verify_paths(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_default_verify_paths(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_default_verify_paths(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_default_verify_paths _cffi_d_SSL_CTX_set_default_verify_paths
#endif

static int _cffi_d_SSL_CTX_set_ecdh_auto(SSL_CTX * x0, int x1)
{
  return SSL_CTX_set_ecdh_auto(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_ecdh_auto(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_ecdh_auto", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_ecdh_auto(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_ecdh_auto _cffi_d_SSL_CTX_set_ecdh_auto
#endif

static int _cffi_d_SSL_CTX_set_ex_data(SSL_CTX * x0, int x1, void * x2)
{
  return SSL_CTX_set_ex_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_ex_data(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int x1;
  void * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_ex_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_ex_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_ex_data _cffi_d_SSL_CTX_set_ex_data
#endif

static void _cffi_d_SSL_CTX_set_info_callback(SSL_CTX * x0, void(* x1)(SSL const *, int, int))
{
  SSL_CTX_set_info_callback(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_info_callback(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  void(* x1)(SSL const *, int, int);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_info_callback", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (void(*)(SSL const *, int, int))_cffi_to_c_pointer(arg1, _cffi_type(3400));
  if (x1 == (void(*)(SSL const *, int, int))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_info_callback(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_info_callback _cffi_d_SSL_CTX_set_info_callback
#endif

static unsigned long _cffi_d_SSL_CTX_set_mode(SSL_CTX * x0, unsigned long x1)
{
  return SSL_CTX_set_mode(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_mode(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_mode", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_mode(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_set_mode _cffi_d_SSL_CTX_set_mode
#endif

static void _cffi_d_SSL_CTX_set_next_proto_select_cb(SSL_CTX * x0, int(* x1)(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *), void * x2)
{
  SSL_CTX_set_next_proto_select_cb(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_next_proto_select_cb(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_next_proto_select_cb", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *))_cffi_to_c_pointer(arg1, _cffi_type(3425));
  if (x1 == (int(*)(SSL *, unsigned char * *, unsigned char *, unsigned char const *, unsigned int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_next_proto_select_cb(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_next_proto_select_cb _cffi_d_SSL_CTX_set_next_proto_select_cb
#endif

static void _cffi_d_SSL_CTX_set_next_protos_advertised_cb(SSL_CTX * x0, int(* x1)(SSL *, unsigned char const * *, unsigned int *, void *), void * x2)
{
  SSL_CTX_set_next_protos_advertised_cb(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_next_protos_advertised_cb(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(SSL *, unsigned char const * *, unsigned int *, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_next_protos_advertised_cb", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL *, unsigned char const * *, unsigned int *, void *))_cffi_to_c_pointer(arg1, _cffi_type(3435));
  if (x1 == (int(*)(SSL *, unsigned char const * *, unsigned int *, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_next_protos_advertised_cb(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_next_protos_advertised_cb _cffi_d_SSL_CTX_set_next_protos_advertised_cb
#endif

static unsigned long _cffi_d_SSL_CTX_set_options(SSL_CTX * x0, unsigned long x1)
{
  return SSL_CTX_set_options(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_options(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_options", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_options(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_set_options _cffi_d_SSL_CTX_set_options
#endif

static unsigned long _cffi_d_SSL_CTX_set_session_cache_mode(SSL_CTX * x0, unsigned long x1)
{
  return SSL_CTX_set_session_cache_mode(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_session_cache_mode(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_session_cache_mode", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_session_cache_mode(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_set_session_cache_mode _cffi_d_SSL_CTX_set_session_cache_mode
#endif

static int _cffi_d_SSL_CTX_set_session_id_context(SSL_CTX * x0, unsigned char const * x1, unsigned int x2)
{
  return SSL_CTX_set_session_id_context(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_session_id_context(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  unsigned char const * x1;
  unsigned int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_session_id_context", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned int);
  if (x2 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_session_id_context(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_set_session_id_context _cffi_d_SSL_CTX_set_session_id_context
#endif

static long _cffi_d_SSL_CTX_set_timeout(SSL_CTX * x0, long x1)
{
  return SSL_CTX_set_timeout(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_timeout(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  long x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_timeout", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_timeout(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_set_timeout _cffi_d_SSL_CTX_set_timeout
#endif

static void _cffi_d_SSL_CTX_set_tlsext_servername_arg(SSL_CTX * x0, void * x1)
{
  SSL_CTX_set_tlsext_servername_arg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_tlsext_servername_arg(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  void * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_tlsext_servername_arg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_tlsext_servername_arg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_tlsext_servername_arg _cffi_d_SSL_CTX_set_tlsext_servername_arg
#endif

static void _cffi_d_SSL_CTX_set_tlsext_servername_callback(SSL_CTX * x0, int(* x1)(SSL const *, int *, void *))
{
  SSL_CTX_set_tlsext_servername_callback(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_tlsext_servername_callback(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(SSL const *, int *, void *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_tlsext_servername_callback", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL const *, int *, void *))_cffi_to_c_pointer(arg1, _cffi_type(3445));
  if (x1 == (int(*)(SSL const *, int *, void *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_tlsext_servername_callback(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_tlsext_servername_callback _cffi_d_SSL_CTX_set_tlsext_servername_callback
#endif

static long _cffi_d_SSL_CTX_set_tlsext_status_arg(SSL_CTX * x0, void * x1)
{
  return SSL_CTX_set_tlsext_status_arg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_tlsext_status_arg(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  void * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_tlsext_status_arg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_tlsext_status_arg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_set_tlsext_status_arg _cffi_d_SSL_CTX_set_tlsext_status_arg
#endif

static long _cffi_d_SSL_CTX_set_tlsext_status_cb(SSL_CTX * x0, int(* x1)(SSL *, void *))
{
  return SSL_CTX_set_tlsext_status_cb(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_tlsext_status_cb(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int(* x1)(SSL *, void *);
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_tlsext_status_cb", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL *, void *))_cffi_to_c_pointer(arg1, _cffi_type(2941));
  if (x1 == (int(*)(SSL *, void *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_tlsext_status_cb(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_CTX_set_tlsext_status_cb _cffi_d_SSL_CTX_set_tlsext_status_cb
#endif

static unsigned long _cffi_d_SSL_CTX_set_tmp_dh(SSL_CTX * x0, DH * x1)
{
  return SSL_CTX_set_tmp_dh(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_tmp_dh(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  DH * x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_tmp_dh", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(299), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_tmp_dh(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_set_tmp_dh _cffi_d_SSL_CTX_set_tmp_dh
#endif

static unsigned long _cffi_d_SSL_CTX_set_tmp_ecdh(SSL_CTX * x0, EC_KEY * x1)
{
  return SSL_CTX_set_tmp_ecdh(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_tmp_ecdh(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  EC_KEY * x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_tmp_ecdh", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_set_tmp_ecdh(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_CTX_set_tmp_ecdh _cffi_d_SSL_CTX_set_tmp_ecdh
#endif

static void _cffi_d_SSL_CTX_set_verify(SSL_CTX * x0, int x1, int(* x2)(int, X509_STORE_CTX *))
{
  SSL_CTX_set_verify(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_verify(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int x1;
  int(* x2)(int, X509_STORE_CTX *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_verify", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = (int(*)(int, X509_STORE_CTX *))_cffi_to_c_pointer(arg2, _cffi_type(3396));
  if (x2 == (int(*)(int, X509_STORE_CTX *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_verify(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_verify _cffi_d_SSL_CTX_set_verify
#endif

static void _cffi_d_SSL_CTX_set_verify_depth(SSL_CTX * x0, int x1)
{
  SSL_CTX_set_verify_depth(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_set_verify_depth(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_set_verify_depth", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_CTX_set_verify_depth(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_CTX_set_verify_depth _cffi_d_SSL_CTX_set_verify_depth
#endif

static int _cffi_d_SSL_CTX_use_PrivateKey(SSL_CTX * x0, EVP_PKEY * x1)
{
  return SSL_CTX_use_PrivateKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_PrivateKey(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_PrivateKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_PrivateKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_PrivateKey _cffi_d_SSL_CTX_use_PrivateKey
#endif

static int _cffi_d_SSL_CTX_use_PrivateKey_ASN1(int x0, SSL_CTX * x1, unsigned char const * x2, long x3)
{
  return SSL_CTX_use_PrivateKey_ASN1(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_PrivateKey_ASN1(PyObject *self, PyObject *args)
{
  int x0;
  SSL_CTX * x1;
  unsigned char const * x2;
  long x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_PrivateKey_ASN1", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(684), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, long);
  if (x3 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_PrivateKey_ASN1(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_PrivateKey_ASN1 _cffi_d_SSL_CTX_use_PrivateKey_ASN1
#endif

static int _cffi_d_SSL_CTX_use_PrivateKey_file(SSL_CTX * x0, char const * x1, int x2)
{
  return SSL_CTX_use_PrivateKey_file(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_PrivateKey_file(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_PrivateKey_file", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_PrivateKey_file(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_PrivateKey_file _cffi_d_SSL_CTX_use_PrivateKey_file
#endif

static int _cffi_d_SSL_CTX_use_certificate(SSL_CTX * x0, X509 * x1)
{
  return SSL_CTX_use_certificate(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_certificate(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_certificate", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_certificate(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_certificate _cffi_d_SSL_CTX_use_certificate
#endif

static int _cffi_d_SSL_CTX_use_certificate_ASN1(SSL_CTX * x0, int x1, unsigned char const * x2)
{
  return SSL_CTX_use_certificate_ASN1(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_certificate_ASN1(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  int x1;
  unsigned char const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_certificate_ASN1", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_certificate_ASN1(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_certificate_ASN1 _cffi_d_SSL_CTX_use_certificate_ASN1
#endif

static int _cffi_d_SSL_CTX_use_certificate_chain_file(SSL_CTX * x0, char const * x1)
{
  return SSL_CTX_use_certificate_chain_file(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_certificate_chain_file(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_certificate_chain_file", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_certificate_chain_file(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_certificate_chain_file _cffi_d_SSL_CTX_use_certificate_chain_file
#endif

static int _cffi_d_SSL_CTX_use_certificate_file(SSL_CTX * x0, char const * x1, int x2)
{
  return SSL_CTX_use_certificate_file(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_CTX_use_certificate_file(PyObject *self, PyObject *args)
{
  SSL_CTX * x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_CTX_use_certificate_file", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_CTX_use_certificate_file(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_CTX_use_certificate_file _cffi_d_SSL_CTX_use_certificate_file
#endif

static void _cffi_d_SSL_SESSION_free(SSL_SESSION * x0)
{
  SSL_SESSION_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_SESSION_free(PyObject *self, PyObject *arg0)
{
  SSL_SESSION * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2161), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_SESSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2161), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_SESSION_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_SESSION_free _cffi_d_SSL_SESSION_free
#endif

static unsigned char const * _cffi_d_SSL_SESSION_get_id(SSL_SESSION const * x0, unsigned int * x1)
{
  return SSL_SESSION_get_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_SESSION_get_id(PyObject *self, PyObject *args)
{
  SSL_SESSION const * x0;
  unsigned int * x1;
  Py_ssize_t datasize;
  unsigned char const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_SESSION_get_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1276), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_SESSION const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1276), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1871), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_SESSION_get_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(148));
}
#else
#  define _cffi_f_SSL_SESSION_get_id _cffi_d_SSL_SESSION_get_id
#endif

static size_t _cffi_d_SSL_SESSION_get_master_key(SSL_SESSION const * x0, unsigned char * x1, size_t x2)
{
  return SSL_SESSION_get_master_key(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_SESSION_get_master_key(PyObject *self, PyObject *args)
{
  SSL_SESSION const * x0;
  unsigned char * x1;
  size_t x2;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_SESSION_get_master_key", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1276), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_SESSION const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1276), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_SESSION_get_master_key(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_SSL_SESSION_get_master_key _cffi_d_SSL_SESSION_get_master_key
#endif

static int _cffi_d_SSL_SESSION_print(BIO * x0, SSL_SESSION const * x1)
{
  return SSL_SESSION_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_SESSION_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  SSL_SESSION const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_SESSION_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1276), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (SSL_SESSION const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1276), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_SESSION_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_SESSION_print _cffi_d_SSL_SESSION_print
#endif

static int _cffi_d_SSL_SESSION_set1_id_context(SSL_SESSION * x0, unsigned char const * x1, unsigned int x2)
{
  return SSL_SESSION_set1_id_context(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_SESSION_set1_id_context(PyObject *self, PyObject *args)
{
  SSL_SESSION * x0;
  unsigned char const * x1;
  unsigned int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_SESSION_set1_id_context", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2161), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_SESSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2161), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned int);
  if (x2 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_SESSION_set1_id_context(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_SESSION_set1_id_context _cffi_d_SSL_SESSION_set1_id_context
#endif

static int _cffi_d_SSL_check_private_key(SSL const * x0)
{
  return SSL_check_private_key(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_check_private_key(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_check_private_key(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_check_private_key _cffi_d_SSL_check_private_key
#endif

static int _cffi_d_SSL_do_handshake(SSL * x0)
{
  return SSL_do_handshake(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_do_handshake(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_do_handshake(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_do_handshake _cffi_d_SSL_do_handshake
#endif

static void _cffi_d_SSL_free(SSL * x0)
{
  SSL_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_free(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_free _cffi_d_SSL_free
#endif

static void _cffi_d_SSL_get0_alpn_selected(SSL const * x0, unsigned char const * * x1, unsigned int * x2)
{
  SSL_get0_alpn_selected(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get0_alpn_selected(PyObject *self, PyObject *args)
{
  SSL const * x0;
  unsigned char const * * x1;
  unsigned int * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_get0_alpn_selected", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1871), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_get0_alpn_selected(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_get0_alpn_selected _cffi_d_SSL_get0_alpn_selected
#endif

static void _cffi_d_SSL_get0_next_proto_negotiated(SSL const * x0, unsigned char const * * x1, unsigned int * x2)
{
  SSL_get0_next_proto_negotiated(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get0_next_proto_negotiated(PyObject *self, PyObject *args)
{
  SSL const * x0;
  unsigned char const * * x1;
  unsigned int * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_get0_next_proto_negotiated", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1871), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_get0_next_proto_negotiated(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_get0_next_proto_negotiated _cffi_d_SSL_get0_next_proto_negotiated
#endif

static SSL_SESSION * _cffi_d_SSL_get1_session(SSL * x0)
{
  return SSL_get1_session(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get1_session(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  SSL_SESSION * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get1_session(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(2161));
}
#else
#  define _cffi_f_SSL_get1_session _cffi_d_SSL_get1_session
#endif

static SSL_CTX * _cffi_d_SSL_get_SSL_CTX(SSL const * x0)
{
  return SSL_get_SSL_CTX(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_SSL_CTX(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  SSL_CTX * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_SSL_CTX(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(684));
}
#else
#  define _cffi_f_SSL_get_SSL_CTX _cffi_d_SSL_get_SSL_CTX
#endif

static char * _cffi_d_SSL_get_app_data(SSL * x0)
{
  return SSL_get_app_data(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_app_data(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  char * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_app_data(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_SSL_get_app_data _cffi_d_SSL_get_app_data
#endif

static char const * _cffi_d_SSL_get_cipher_list(SSL const * x0, int x1)
{
  return SSL_get_cipher_list(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_cipher_list(PyObject *self, PyObject *args)
{
  SSL const * x0;
  int x1;
  Py_ssize_t datasize;
  char const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_get_cipher_list", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_cipher_list(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_get_cipher_list _cffi_d_SSL_get_cipher_list
#endif

static Cryptography_STACK_OF_SSL_CIPHER * _cffi_d_SSL_get_ciphers(SSL const * x0)
{
  return SSL_get_ciphers(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_ciphers(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_SSL_CIPHER * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_ciphers(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(687));
}
#else
#  define _cffi_f_SSL_get_ciphers _cffi_d_SSL_get_ciphers
#endif

static Cryptography_STACK_OF_X509_NAME * _cffi_d_SSL_get_client_CA_list(SSL const * x0)
{
  return SSL_get_client_CA_list(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_client_CA_list(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_client_CA_list(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(837));
}
#else
#  define _cffi_f_SSL_get_client_CA_list _cffi_d_SSL_get_client_CA_list
#endif

static size_t _cffi_d_SSL_get_client_random(SSL const * x0, unsigned char * x1, size_t x2)
{
  return SSL_get_client_random(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_client_random(PyObject *self, PyObject *args)
{
  SSL const * x0;
  unsigned char * x1;
  size_t x2;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_get_client_random", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_client_random(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_SSL_get_client_random _cffi_d_SSL_get_client_random
#endif

static SSL_CIPHER const * _cffi_d_SSL_get_current_cipher(SSL const * x0)
{
  return SSL_get_current_cipher(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_current_cipher(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  SSL_CIPHER const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_current_cipher(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(925));
}
#else
#  define _cffi_f_SSL_get_current_cipher _cffi_d_SSL_get_current_cipher
#endif

static COMP_METHOD const * _cffi_d_SSL_get_current_compression(SSL * x0)
{
  return SSL_get_current_compression(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_current_compression(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  COMP_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_current_compression(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(939));
}
#else
#  define _cffi_f_SSL_get_current_compression _cffi_d_SSL_get_current_compression
#endif

static COMP_METHOD const * _cffi_d_SSL_get_current_expansion(SSL * x0)
{
  return SSL_get_current_expansion(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_current_expansion(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  COMP_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_current_expansion(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(939));
}
#else
#  define _cffi_f_SSL_get_current_expansion _cffi_d_SSL_get_current_expansion
#endif

static int _cffi_d_SSL_get_error(SSL const * x0, int x1)
{
  return SSL_get_error(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_error(PyObject *self, PyObject *args)
{
  SSL const * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_get_error", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_error(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_get_error _cffi_d_SSL_get_error
#endif

static void * _cffi_d_SSL_get_ex_data(SSL const * x0, int x1)
{
  return SSL_get_ex_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_ex_data(PyObject *self, PyObject *args)
{
  SSL const * x0;
  int x1;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_get_ex_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_ex_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_SSL_get_ex_data _cffi_d_SSL_get_ex_data
#endif

static int _cffi_d_SSL_get_ex_data_X509_STORE_CTX_idx(void)
{
  return SSL_get_ex_data_X509_STORE_CTX_idx();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_ex_data_X509_STORE_CTX_idx(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_ex_data_X509_STORE_CTX_idx(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_get_ex_data_X509_STORE_CTX_idx _cffi_d_SSL_get_ex_data_X509_STORE_CTX_idx
#endif

static int _cffi_d_SSL_get_ex_new_index(long x0, void * x1, CRYPTO_EX_new * x2, CRYPTO_EX_dup * x3, CRYPTO_EX_free * x4)
{
  return SSL_get_ex_new_index(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_ex_new_index(PyObject *self, PyObject *args)
{
  long x0;
  void * x1;
  CRYPTO_EX_new * x2;
  CRYPTO_EX_dup * x3;
  CRYPTO_EX_free * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "SSL_get_ex_new_index", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, long);
  if (x0 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2762), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (CRYPTO_EX_new *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(2762), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2763), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (CRYPTO_EX_dup *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(2763), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2764), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (CRYPTO_EX_free *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(2764), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_ex_new_index(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_get_ex_new_index _cffi_d_SSL_get_ex_new_index
#endif

static size_t _cffi_d_SSL_get_finished(SSL const * x0, void * x1, size_t x2)
{
  return SSL_get_finished(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_finished(PyObject *self, PyObject *args)
{
  SSL const * x0;
  void * x1;
  size_t x2;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_get_finished", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_finished(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_SSL_get_finished _cffi_d_SSL_get_finished
#endif

static void(* _cffi_d_SSL_get_info_callback(SSL const * x0))(SSL const *, int, int)
{
  return SSL_get_info_callback(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_info_callback(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  void(* result)(SSL const *, int, int);

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_info_callback(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3400));
}
#else
#  define _cffi_f_SSL_get_info_callback _cffi_d_SSL_get_info_callback
#endif

static unsigned long _cffi_d_SSL_get_mode(SSL * x0)
{
  return SSL_get_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_mode(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_get_mode _cffi_d_SSL_get_mode
#endif

static unsigned long _cffi_d_SSL_get_options(SSL * x0)
{
  return SSL_get_options(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_options(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_options(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_get_options _cffi_d_SSL_get_options
#endif

static Cryptography_STACK_OF_X509 * _cffi_d_SSL_get_peer_cert_chain(SSL const * x0)
{
  return SSL_get_peer_cert_chain(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_peer_cert_chain(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_peer_cert_chain(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(210));
}
#else
#  define _cffi_f_SSL_get_peer_cert_chain _cffi_d_SSL_get_peer_cert_chain
#endif

static X509 * _cffi_d_SSL_get_peer_certificate(SSL const * x0)
{
  return SSL_get_peer_certificate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_peer_certificate(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_peer_certificate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_SSL_get_peer_certificate _cffi_d_SSL_get_peer_certificate
#endif

static size_t _cffi_d_SSL_get_peer_finished(SSL const * x0, void * x1, size_t x2)
{
  return SSL_get_peer_finished(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_peer_finished(PyObject *self, PyObject *args)
{
  SSL const * x0;
  void * x1;
  size_t x2;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_get_peer_finished", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_peer_finished(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_SSL_get_peer_finished _cffi_d_SSL_get_peer_finished
#endif

static BIO * _cffi_d_SSL_get_rbio(SSL const * x0)
{
  return SSL_get_rbio(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_rbio(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  BIO * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_rbio(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_SSL_get_rbio _cffi_d_SSL_get_rbio
#endif

static long _cffi_d_SSL_get_secure_renegotiation_support(SSL * x0)
{
  return SSL_get_secure_renegotiation_support(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_secure_renegotiation_support(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_secure_renegotiation_support(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_get_secure_renegotiation_support _cffi_d_SSL_get_secure_renegotiation_support
#endif

static size_t _cffi_d_SSL_get_server_random(SSL const * x0, unsigned char * x1, size_t x2)
{
  return SSL_get_server_random(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_server_random(PyObject *self, PyObject *args)
{
  SSL const * x0;
  unsigned char * x1;
  size_t x2;
  Py_ssize_t datasize;
  size_t result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_get_server_random", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_server_random(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_SSL_get_server_random _cffi_d_SSL_get_server_random
#endif

static long _cffi_d_SSL_get_server_tmp_key(SSL * x0, EVP_PKEY * * x1)
{
  return SSL_get_server_tmp_key(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_server_tmp_key(PyObject *self, PyObject *args)
{
  SSL * x0;
  EVP_PKEY * * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_get_server_tmp_key", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(478), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_server_tmp_key(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_get_server_tmp_key _cffi_d_SSL_get_server_tmp_key
#endif

static char const * _cffi_d_SSL_get_servername(SSL const * x0, int x1)
{
  return SSL_get_servername(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_servername(PyObject *self, PyObject *args)
{
  SSL const * x0;
  int x1;
  Py_ssize_t datasize;
  char const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_get_servername", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_servername(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_get_servername _cffi_d_SSL_get_servername
#endif

static SSL_SESSION * _cffi_d_SSL_get_session(SSL const * x0)
{
  return SSL_get_session(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_session(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  SSL_SESSION * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_session(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(2161));
}
#else
#  define _cffi_f_SSL_get_session _cffi_d_SSL_get_session
#endif

static int _cffi_d_SSL_get_shutdown(SSL const * x0)
{
  return SSL_get_shutdown(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_shutdown(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_shutdown(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_get_shutdown _cffi_d_SSL_get_shutdown
#endif

static long _cffi_d_SSL_get_tlsext_status_ocsp_resp(SSL * x0, unsigned char const * * x1)
{
  return SSL_get_tlsext_status_ocsp_resp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_tlsext_status_ocsp_resp(PyObject *self, PyObject *args)
{
  SSL * x0;
  unsigned char const * * x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_get_tlsext_status_ocsp_resp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_tlsext_status_ocsp_resp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_get_tlsext_status_ocsp_resp _cffi_d_SSL_get_tlsext_status_ocsp_resp
#endif

static int(* _cffi_d_SSL_get_verify_callback(SSL const * x0))(int, X509_STORE_CTX *)
{
  return SSL_get_verify_callback(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_verify_callback(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int(* result)(int, X509_STORE_CTX *);

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_verify_callback(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3396));
}
#else
#  define _cffi_f_SSL_get_verify_callback _cffi_d_SSL_get_verify_callback
#endif

static int _cffi_d_SSL_get_verify_depth(SSL const * x0)
{
  return SSL_get_verify_depth(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_verify_depth(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_verify_depth(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_get_verify_depth _cffi_d_SSL_get_verify_depth
#endif

static int _cffi_d_SSL_get_verify_mode(SSL const * x0)
{
  return SSL_get_verify_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_verify_mode(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_verify_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_get_verify_mode _cffi_d_SSL_get_verify_mode
#endif

static char const * _cffi_d_SSL_get_version(SSL const * x0)
{
  return SSL_get_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_version(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_get_version _cffi_d_SSL_get_version
#endif

static BIO * _cffi_d_SSL_get_wbio(SSL const * x0)
{
  return SSL_get_wbio(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_get_wbio(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  BIO * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_get_wbio(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(160));
}
#else
#  define _cffi_f_SSL_get_wbio _cffi_d_SSL_get_wbio
#endif

static int _cffi_d_SSL_library_init(void)
{
  return SSL_library_init();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_library_init(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_library_init(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_library_init _cffi_d_SSL_library_init
#endif

static Cryptography_STACK_OF_X509_NAME * _cffi_d_SSL_load_client_CA_file(char const * x0)
{
  return SSL_load_client_CA_file(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_load_client_CA_file(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(57), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_load_client_CA_file(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(837));
}
#else
#  define _cffi_f_SSL_load_client_CA_file _cffi_d_SSL_load_client_CA_file
#endif

static void _cffi_d_SSL_load_error_strings(void)
{
  SSL_load_error_strings();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_load_error_strings(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_load_error_strings(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_load_error_strings _cffi_d_SSL_load_error_strings
#endif

static SSL * _cffi_d_SSL_new(SSL_CTX * x0)
{
  return SSL_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_new(PyObject *self, PyObject *arg0)
{
  SSL_CTX * x0;
  Py_ssize_t datasize;
  SSL * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(684), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(230));
}
#else
#  define _cffi_f_SSL_new _cffi_d_SSL_new
#endif

static int _cffi_d_SSL_peek(SSL * x0, void * x1, int x2)
{
  return SSL_peek(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_peek(PyObject *self, PyObject *args)
{
  SSL * x0;
  void * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_peek", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_peek(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_peek _cffi_d_SSL_peek
#endif

static int _cffi_d_SSL_pending(SSL const * x0)
{
  return SSL_pending(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_pending(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_pending(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_pending _cffi_d_SSL_pending
#endif

static int _cffi_d_SSL_read(SSL * x0, void * x1, int x2)
{
  return SSL_read(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_read(PyObject *self, PyObject *args)
{
  SSL * x0;
  void * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_read", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_read(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_read _cffi_d_SSL_read
#endif

static int _cffi_d_SSL_renegotiate(SSL * x0)
{
  return SSL_renegotiate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_renegotiate(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_renegotiate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_renegotiate _cffi_d_SSL_renegotiate
#endif

static int _cffi_d_SSL_renegotiate_pending(SSL * x0)
{
  return SSL_renegotiate_pending(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_renegotiate_pending(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_renegotiate_pending(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_renegotiate_pending _cffi_d_SSL_renegotiate_pending
#endif

static int _cffi_d_SSL_select_next_proto(unsigned char * * x0, unsigned char * x1, unsigned char const * x2, unsigned int x3, unsigned char const * x4, unsigned int x5)
{
  return SSL_select_next_proto(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_select_next_proto(PyObject *self, PyObject *args)
{
  unsigned char * * x0;
  unsigned char * x1;
  unsigned char const * x2;
  unsigned int x3;
  unsigned char const * x4;
  unsigned int x5;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "SSL_select_next_proto", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(985), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, unsigned int);
  if (x3 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(148), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, unsigned int);
  if (x5 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_select_next_proto(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_select_next_proto _cffi_d_SSL_select_next_proto
#endif

static long _cffi_d_SSL_session_reused(SSL * x0)
{
  return SSL_session_reused(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_session_reused(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_session_reused(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_session_reused _cffi_d_SSL_session_reused
#endif

static SSL_CTX * _cffi_d_SSL_set_SSL_CTX(SSL * x0, SSL_CTX * x1)
{
  return SSL_set_SSL_CTX(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_SSL_CTX(PyObject *self, PyObject *args)
{
  SSL * x0;
  SSL_CTX * x1;
  Py_ssize_t datasize;
  SSL_CTX * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_SSL_CTX", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(684), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (SSL_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(684), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_SSL_CTX(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(684));
}
#else
#  define _cffi_f_SSL_set_SSL_CTX _cffi_d_SSL_set_SSL_CTX
#endif

static void _cffi_d_SSL_set_accept_state(SSL * x0)
{
  SSL_set_accept_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_accept_state(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_accept_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_accept_state _cffi_d_SSL_set_accept_state
#endif

static int _cffi_d_SSL_set_alpn_protos(SSL * x0, unsigned char const * x1, unsigned int x2)
{
  return SSL_set_alpn_protos(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_alpn_protos(PyObject *self, PyObject *args)
{
  SSL * x0;
  unsigned char const * x1;
  unsigned int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_set_alpn_protos", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned int);
  if (x2 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_alpn_protos(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_set_alpn_protos _cffi_d_SSL_set_alpn_protos
#endif

static void _cffi_d_SSL_set_app_data(SSL * x0, char * x1)
{
  SSL_set_app_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_app_data(PyObject *self, PyObject *args)
{
  SSL * x0;
  char * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_app_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_app_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_app_data _cffi_d_SSL_set_app_data
#endif

static void _cffi_d_SSL_set_bio(SSL * x0, BIO * x1, BIO * x2)
{
  SSL_set_bio(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_bio(PyObject *self, PyObject *args)
{
  SSL * x0;
  BIO * x1;
  BIO * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_set_bio", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (BIO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(160), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIO *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(160), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_bio(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_bio _cffi_d_SSL_set_bio
#endif

static void _cffi_d_SSL_set_cert_cb(SSL * x0, int(* x1)(SSL *, void *), void * x2)
{
  SSL_set_cert_cb(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_cert_cb(PyObject *self, PyObject *args)
{
  SSL * x0;
  int(* x1)(SSL *, void *);
  void * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_set_cert_cb", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(SSL *, void *))_cffi_to_c_pointer(arg1, _cffi_type(2941));
  if (x1 == (int(*)(SSL *, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_cert_cb(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_cert_cb _cffi_d_SSL_set_cert_cb
#endif

static void _cffi_d_SSL_set_connect_state(SSL * x0)
{
  SSL_set_connect_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_connect_state(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_connect_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_connect_state _cffi_d_SSL_set_connect_state
#endif

static int _cffi_d_SSL_set_ex_data(SSL * x0, int x1, void * x2)
{
  return SSL_set_ex_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_ex_data(PyObject *self, PyObject *args)
{
  SSL * x0;
  int x1;
  void * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_set_ex_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_ex_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_set_ex_data _cffi_d_SSL_set_ex_data
#endif

static int _cffi_d_SSL_set_fd(SSL * x0, int x1)
{
  return SSL_set_fd(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_fd(PyObject *self, PyObject *args)
{
  SSL * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_fd", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_fd(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_set_fd _cffi_d_SSL_set_fd
#endif

static void _cffi_d_SSL_set_info_callback(SSL * x0, void(* x1)(SSL const *, int, int))
{
  SSL_set_info_callback(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_info_callback(PyObject *self, PyObject *args)
{
  SSL * x0;
  void(* x1)(SSL const *, int, int);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_info_callback", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = (void(*)(SSL const *, int, int))_cffi_to_c_pointer(arg1, _cffi_type(3400));
  if (x1 == (void(*)(SSL const *, int, int))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_info_callback(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_info_callback _cffi_d_SSL_set_info_callback
#endif

static unsigned long _cffi_d_SSL_set_mode(SSL * x0, unsigned long x1)
{
  return SSL_set_mode(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_mode(PyObject *self, PyObject *args)
{
  SSL * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_mode", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_mode(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_set_mode _cffi_d_SSL_set_mode
#endif

static unsigned long _cffi_d_SSL_set_options(SSL * x0, unsigned long x1)
{
  return SSL_set_options(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_options(PyObject *self, PyObject *args)
{
  SSL * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  unsigned long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_options", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_options(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSL_set_options _cffi_d_SSL_set_options
#endif

static void _cffi_d_SSL_set_read_ahead(SSL * x0, int x1)
{
  SSL_set_read_ahead(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_read_ahead(PyObject *self, PyObject *args)
{
  SSL * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_read_ahead", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_read_ahead(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_read_ahead _cffi_d_SSL_set_read_ahead
#endif

static int _cffi_d_SSL_set_session(SSL * x0, SSL_SESSION * x1)
{
  return SSL_set_session(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_session(PyObject *self, PyObject *args)
{
  SSL * x0;
  SSL_SESSION * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_session", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2161), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (SSL_SESSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2161), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_session(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_set_session _cffi_d_SSL_set_session
#endif

static void _cffi_d_SSL_set_shutdown(SSL * x0, int x1)
{
  SSL_set_shutdown(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_shutdown(PyObject *self, PyObject *args)
{
  SSL * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_shutdown", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_shutdown(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_shutdown _cffi_d_SSL_set_shutdown
#endif

static void _cffi_d_SSL_set_tlsext_host_name(SSL * x0, char * x1)
{
  SSL_set_tlsext_host_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_tlsext_host_name(PyObject *self, PyObject *args)
{
  SSL * x0;
  char * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_tlsext_host_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_tlsext_host_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_tlsext_host_name _cffi_d_SSL_set_tlsext_host_name
#endif

static long _cffi_d_SSL_set_tlsext_status_ocsp_resp(SSL * x0, unsigned char * x1, int x2)
{
  return SSL_set_tlsext_status_ocsp_resp(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_tlsext_status_ocsp_resp(PyObject *self, PyObject *args)
{
  SSL * x0;
  unsigned char * x1;
  int x2;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_set_tlsext_status_ocsp_resp", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(975), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_tlsext_status_ocsp_resp(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_set_tlsext_status_ocsp_resp _cffi_d_SSL_set_tlsext_status_ocsp_resp
#endif

static long _cffi_d_SSL_set_tlsext_status_type(SSL * x0, long x1)
{
  return SSL_set_tlsext_status_type(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_tlsext_status_type(PyObject *self, PyObject *args)
{
  SSL * x0;
  long x1;
  Py_ssize_t datasize;
  long result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_tlsext_status_type", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_set_tlsext_status_type(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_set_tlsext_status_type _cffi_d_SSL_set_tlsext_status_type
#endif

static void _cffi_d_SSL_set_verify(SSL * x0, int x1, int(* x2)(int, X509_STORE_CTX *))
{
  SSL_set_verify(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_verify(PyObject *self, PyObject *args)
{
  SSL * x0;
  int x1;
  int(* x2)(int, X509_STORE_CTX *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_set_verify", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = (int(*)(int, X509_STORE_CTX *))_cffi_to_c_pointer(arg2, _cffi_type(3396));
  if (x2 == (int(*)(int, X509_STORE_CTX *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_verify(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_verify _cffi_d_SSL_set_verify
#endif

static void _cffi_d_SSL_set_verify_depth(SSL * x0, int x1)
{
  SSL_set_verify_depth(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_set_verify_depth(PyObject *self, PyObject *args)
{
  SSL * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_set_verify_depth", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SSL_set_verify_depth(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SSL_set_verify_depth _cffi_d_SSL_set_verify_depth
#endif

static int _cffi_d_SSL_shutdown(SSL * x0)
{
  return SSL_shutdown(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_shutdown(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_shutdown(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_shutdown _cffi_d_SSL_shutdown
#endif

static char const * _cffi_d_SSL_state_string_long(SSL const * x0)
{
  return SSL_state_string_long(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_state_string_long(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_state_string_long(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSL_state_string_long _cffi_d_SSL_state_string_long
#endif

static long _cffi_d_SSL_total_renegotiations(SSL * x0)
{
  return SSL_total_renegotiations(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_total_renegotiations(PyObject *self, PyObject *arg0)
{
  SSL * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_total_renegotiations(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_SSL_total_renegotiations _cffi_d_SSL_total_renegotiations
#endif

static int _cffi_d_SSL_use_PrivateKey(SSL * x0, EVP_PKEY * x1)
{
  return SSL_use_PrivateKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_use_PrivateKey(PyObject *self, PyObject *args)
{
  SSL * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_use_PrivateKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_use_PrivateKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_use_PrivateKey _cffi_d_SSL_use_PrivateKey
#endif

static int _cffi_d_SSL_use_PrivateKey_ASN1(int x0, SSL * x1, unsigned char const * x2, long x3)
{
  return SSL_use_PrivateKey_ASN1(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_use_PrivateKey_ASN1(PyObject *self, PyObject *args)
{
  int x0;
  SSL * x1;
  unsigned char const * x2;
  long x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "SSL_use_PrivateKey_ASN1", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (SSL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(230), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(148), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, long);
  if (x3 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_use_PrivateKey_ASN1(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_use_PrivateKey_ASN1 _cffi_d_SSL_use_PrivateKey_ASN1
#endif

static int _cffi_d_SSL_use_PrivateKey_file(SSL * x0, char const * x1, int x2)
{
  return SSL_use_PrivateKey_file(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_use_PrivateKey_file(PyObject *self, PyObject *args)
{
  SSL * x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_use_PrivateKey_file", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_use_PrivateKey_file(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_use_PrivateKey_file _cffi_d_SSL_use_PrivateKey_file
#endif

static int _cffi_d_SSL_use_certificate(SSL * x0, X509 * x1)
{
  return SSL_use_certificate(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_use_certificate(PyObject *self, PyObject *args)
{
  SSL * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SSL_use_certificate", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_use_certificate(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_use_certificate _cffi_d_SSL_use_certificate
#endif

static int _cffi_d_SSL_use_certificate_ASN1(SSL * x0, unsigned char const * x1, int x2)
{
  return SSL_use_certificate_ASN1(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_use_certificate_ASN1(PyObject *self, PyObject *args)
{
  SSL * x0;
  unsigned char const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_use_certificate_ASN1", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_use_certificate_ASN1(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_use_certificate_ASN1 _cffi_d_SSL_use_certificate_ASN1
#endif

static int _cffi_d_SSL_use_certificate_file(SSL * x0, char const * x1, int x2)
{
  return SSL_use_certificate_file(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_use_certificate_file(PyObject *self, PyObject *args)
{
  SSL * x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_use_certificate_file", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_use_certificate_file(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_use_certificate_file _cffi_d_SSL_use_certificate_file
#endif

static int _cffi_d_SSL_version(SSL const * x0)
{
  return SSL_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_version(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_version _cffi_d_SSL_version
#endif

static int _cffi_d_SSL_want_read(SSL const * x0)
{
  return SSL_want_read(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_want_read(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_want_read(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_want_read _cffi_d_SSL_want_read
#endif

static int _cffi_d_SSL_want_write(SSL const * x0)
{
  return SSL_want_write(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_want_write(PyObject *self, PyObject *arg0)
{
  SSL const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(186), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(186), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_want_write(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_want_write _cffi_d_SSL_want_write
#endif

static int _cffi_d_SSL_write(SSL * x0, void const * x1, int x2)
{
  return SSL_write(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSL_write(PyObject *self, PyObject *args)
{
  SSL * x0;
  void const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SSL_write", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(230), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (SSL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(230), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1052), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1052), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSL_write(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_SSL_write _cffi_d_SSL_write
#endif

static unsigned long _cffi_d_SSLeay(void)
{
  return SSLeay();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLeay(PyObject *self, PyObject *noarg)
{
  unsigned long result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLeay(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_SSLeay _cffi_d_SSLeay
#endif

static char const * _cffi_d_SSLeay_version(int x0)
{
  return SSLeay_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLeay_version(PyObject *self, PyObject *arg0)
{
  int x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLeay_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_SSLeay_version _cffi_d_SSLeay_version
#endif

static SSL_METHOD const * _cffi_d_SSLv23_client_method(void)
{
  return SSLv23_client_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLv23_client_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLv23_client_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSLv23_client_method _cffi_d_SSLv23_client_method
#endif

static SSL_METHOD const * _cffi_d_SSLv23_method(void)
{
  return SSLv23_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLv23_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLv23_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSLv23_method _cffi_d_SSLv23_method
#endif

static SSL_METHOD const * _cffi_d_SSLv23_server_method(void)
{
  return SSLv23_server_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLv23_server_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLv23_server_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSLv23_server_method _cffi_d_SSLv23_server_method
#endif

static SSL_METHOD const * _cffi_d_SSLv3_client_method(void)
{
  return SSLv3_client_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLv3_client_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLv3_client_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSLv3_client_method _cffi_d_SSLv3_client_method
#endif

static SSL_METHOD const * _cffi_d_SSLv3_method(void)
{
  return SSLv3_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLv3_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLv3_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSLv3_method _cffi_d_SSLv3_method
#endif

static SSL_METHOD const * _cffi_d_SSLv3_server_method(void)
{
  return SSLv3_server_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SSLv3_server_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SSLv3_server_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_SSLv3_server_method _cffi_d_SSLv3_server_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_1_client_method(void)
{
  return TLSv1_1_client_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_1_client_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_1_client_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_1_client_method _cffi_d_TLSv1_1_client_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_1_method(void)
{
  return TLSv1_1_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_1_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_1_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_1_method _cffi_d_TLSv1_1_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_1_server_method(void)
{
  return TLSv1_1_server_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_1_server_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_1_server_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_1_server_method _cffi_d_TLSv1_1_server_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_2_client_method(void)
{
  return TLSv1_2_client_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_2_client_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_2_client_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_2_client_method _cffi_d_TLSv1_2_client_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_2_method(void)
{
  return TLSv1_2_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_2_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_2_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_2_method _cffi_d_TLSv1_2_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_2_server_method(void)
{
  return TLSv1_2_server_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_2_server_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_2_server_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_2_server_method _cffi_d_TLSv1_2_server_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_client_method(void)
{
  return TLSv1_client_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_client_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_client_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_client_method _cffi_d_TLSv1_client_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_method(void)
{
  return TLSv1_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_method _cffi_d_TLSv1_method
#endif

static SSL_METHOD const * _cffi_d_TLSv1_server_method(void)
{
  return TLSv1_server_method();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TLSv1_server_method(PyObject *self, PyObject *noarg)
{
  SSL_METHOD const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TLSv1_server_method(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3751));
}
#else
#  define _cffi_f_TLSv1_server_method _cffi_d_TLSv1_server_method
#endif

static void _cffi_d_USERNOTICE_free(USERNOTICE * x0)
{
  USERNOTICE_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_USERNOTICE_free(PyObject *self, PyObject *arg0)
{
  USERNOTICE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3477), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (USERNOTICE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3477), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { USERNOTICE_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_USERNOTICE_free _cffi_d_USERNOTICE_free
#endif

static USERNOTICE * _cffi_d_USERNOTICE_new(void)
{
  return USERNOTICE_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_USERNOTICE_new(PyObject *self, PyObject *noarg)
{
  USERNOTICE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = USERNOTICE_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3477));
}
#else
#  define _cffi_f_USERNOTICE_new _cffi_d_USERNOTICE_new
#endif

static int _cffi_d_X509V3_EXT_add_alias(int x0, int x1)
{
  return X509V3_EXT_add_alias(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_add_alias(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509V3_EXT_add_alias", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_add_alias(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509V3_EXT_add_alias _cffi_d_X509V3_EXT_add_alias
#endif

static X509_EXTENSION * _cffi_d_X509V3_EXT_conf_nid(Cryptography_LHASH_OF_CONF_VALUE * x0, X509V3_CTX * x1, int x2, char * x3)
{
  return X509V3_EXT_conf_nid(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_conf_nid(PyObject *self, PyObject *args)
{
  Cryptography_LHASH_OF_CONF_VALUE * x0;
  X509V3_CTX * x1;
  int x2;
  char * x3;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509V3_EXT_conf_nid", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(784), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_LHASH_OF_CONF_VALUE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(784), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(779), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509V3_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(779), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(594), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_conf_nid(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509V3_EXT_conf_nid _cffi_d_X509V3_EXT_conf_nid
#endif

static void * _cffi_d_X509V3_EXT_d2i(X509_EXTENSION * x0)
{
  return X509V3_EXT_d2i(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_d2i(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;
  void * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_d2i(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_X509V3_EXT_d2i _cffi_d_X509V3_EXT_d2i
#endif

static X509V3_EXT_METHOD const * _cffi_d_X509V3_EXT_get(X509_EXTENSION * x0)
{
  return X509V3_EXT_get(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_get(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;
  X509V3_EXT_METHOD const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_get(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3758));
}
#else
#  define _cffi_f_X509V3_EXT_get _cffi_d_X509V3_EXT_get
#endif

static X509V3_EXT_METHOD const * _cffi_d_X509V3_EXT_get_nid(int x0)
{
  return X509V3_EXT_get_nid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_get_nid(PyObject *self, PyObject *arg0)
{
  int x0;
  X509V3_EXT_METHOD const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_get_nid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3758));
}
#else
#  define _cffi_f_X509V3_EXT_get_nid _cffi_d_X509V3_EXT_get_nid
#endif

static X509_EXTENSION * _cffi_d_X509V3_EXT_i2d(int x0, int x1, void * x2)
{
  return X509V3_EXT_i2d(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_i2d(PyObject *self, PyObject *args)
{
  int x0;
  int x1;
  void * x2;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509V3_EXT_i2d", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_i2d(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509V3_EXT_i2d _cffi_d_X509V3_EXT_i2d
#endif

static X509_EXTENSION * _cffi_d_X509V3_EXT_nconf(CONF * x0, X509V3_CTX * x1, char * x2, char * x3)
{
  return X509V3_EXT_nconf(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_nconf(PyObject *self, PyObject *args)
{
  CONF * x0;
  X509V3_CTX * x1;
  char * x2;
  char * x3;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509V3_EXT_nconf", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(778), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CONF *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(778), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(779), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509V3_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(779), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(594), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(594), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_nconf(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509V3_EXT_nconf _cffi_d_X509V3_EXT_nconf
#endif

static int _cffi_d_X509V3_EXT_print(BIO * x0, X509_EXTENSION * x1, unsigned long x2, int x3)
{
  return X509V3_EXT_print(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_EXT_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_EXTENSION * x1;
  unsigned long x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509V3_EXT_print", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(51), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned long);
  if (x2 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_EXT_print(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509V3_EXT_print _cffi_d_X509V3_EXT_print
#endif

static void _cffi_d_X509V3_set_ctx(X509V3_CTX * x0, X509 * x1, X509 * x2, X509_REQ * x3, X509_CRL * x4, int x5)
{
  X509V3_set_ctx(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_set_ctx(PyObject *self, PyObject *args)
{
  X509V3_CTX * x0;
  X509 * x1;
  X509 * x2;
  X509_REQ * x3;
  X509_CRL * x4;
  int x5;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "X509V3_set_ctx", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(779), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509V3_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(779), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(28), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(502), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(80), arg4) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509V3_set_ctx(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509V3_set_ctx _cffi_d_X509V3_set_ctx
#endif

static void * _cffi_d_X509V3_set_ctx_nodb(X509V3_CTX * x0)
{
  return X509V3_set_ctx_nodb(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509V3_set_ctx_nodb(PyObject *self, PyObject *arg0)
{
  X509V3_CTX * x0;
  Py_ssize_t datasize;
  void * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(779), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509V3_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(779), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509V3_set_ctx_nodb(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_X509V3_set_ctx_nodb _cffi_d_X509V3_set_ctx_nodb
#endif

static int _cffi_d_X509_CRL_add0_revoked(X509_CRL * x0, X509_REVOKED * x1)
{
  return X509_CRL_add0_revoked(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_add0_revoked(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  X509_REVOKED * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_add0_revoked", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(823), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_add0_revoked(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_add0_revoked _cffi_d_X509_CRL_add0_revoked
#endif

static int _cffi_d_X509_CRL_add_ext(X509_CRL * x0, X509_EXTENSION * x1, int x2)
{
  return X509_CRL_add_ext(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_add_ext(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  X509_EXTENSION * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_CRL_add_ext", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(51), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_add_ext(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_add_ext _cffi_d_X509_CRL_add_ext
#endif

static int _cffi_d_X509_CRL_cmp(X509_CRL const * x0, X509_CRL const * x1)
{
  return X509_CRL_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_cmp(PyObject *self, PyObject *args)
{
  X509_CRL const * x0;
  X509_CRL const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2406), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2406), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2406), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2406), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_cmp _cffi_d_X509_CRL_cmp
#endif

static void _cffi_d_X509_CRL_free(X509_CRL * x0)
{
  X509_CRL_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_free(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_CRL_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_CRL_free _cffi_d_X509_CRL_free
#endif

static void _cffi_d_X509_CRL_get0_signature(X509_CRL const * x0, ASN1_OCTET_STRING const * * x1, X509_ALGOR const * * x2)
{
  X509_CRL_get0_signature(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get0_signature(PyObject *self, PyObject *args)
{
  X509_CRL const * x0;
  ASN1_OCTET_STRING const * * x1;
  X509_ALGOR const * * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_CRL_get0_signature", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2406), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2406), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3495), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(3495), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3496), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509_ALGOR const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(3496), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_CRL_get0_signature(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_CRL_get0_signature _cffi_d_X509_CRL_get0_signature
#endif

static Cryptography_STACK_OF_X509_REVOKED * _cffi_d_X509_CRL_get_REVOKED(X509_CRL * x0)
{
  return X509_CRL_get_REVOKED(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_REVOKED(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509_REVOKED * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_REVOKED(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(886));
}
#else
#  define _cffi_f_X509_CRL_get_REVOKED _cffi_d_X509_CRL_get_REVOKED
#endif

static X509_EXTENSION * _cffi_d_X509_CRL_get_ext(X509_CRL * x0, int x1)
{
  return X509_CRL_get_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_ext(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_get_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_CRL_get_ext _cffi_d_X509_CRL_get_ext
#endif

static int _cffi_d_X509_CRL_get_ext_count(X509_CRL * x0)
{
  return X509_CRL_get_ext_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_ext_count(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_ext_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_get_ext_count _cffi_d_X509_CRL_get_ext_count
#endif

static X509_NAME * _cffi_d_X509_CRL_get_issuer(X509_CRL * x0)
{
  return X509_CRL_get_issuer(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_issuer(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_issuer(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_X509_CRL_get_issuer _cffi_d_X509_CRL_get_issuer
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_CRL_get_lastUpdate(X509_CRL * x0)
{
  return X509_CRL_get_lastUpdate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_lastUpdate(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_lastUpdate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_CRL_get_lastUpdate _cffi_d_X509_CRL_get_lastUpdate
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_CRL_get_nextUpdate(X509_CRL * x0)
{
  return X509_CRL_get_nextUpdate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_nextUpdate(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_nextUpdate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_CRL_get_nextUpdate _cffi_d_X509_CRL_get_nextUpdate
#endif

static int _cffi_d_X509_CRL_get_version(X509_CRL * x0)
{
  return X509_CRL_get_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_get_version(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_get_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_get_version _cffi_d_X509_CRL_get_version
#endif

static X509_CRL * _cffi_d_X509_CRL_new(void)
{
  return X509_CRL_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_new(PyObject *self, PyObject *noarg)
{
  X509_CRL * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(80));
}
#else
#  define _cffi_f_X509_CRL_new _cffi_d_X509_CRL_new
#endif

static int _cffi_d_X509_CRL_print(BIO * x0, X509_CRL * x1)
{
  return X509_CRL_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_CRL * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_print _cffi_d_X509_CRL_print
#endif

static int _cffi_d_X509_CRL_set_issuer_name(X509_CRL * x0, X509_NAME * x1)
{
  return X509_CRL_set_issuer_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_set_issuer_name(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  X509_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_set_issuer_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(847), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_set_issuer_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_set_issuer_name _cffi_d_X509_CRL_set_issuer_name
#endif

static int _cffi_d_X509_CRL_set_lastUpdate(X509_CRL * x0, ASN1_OCTET_STRING * x1)
{
  return X509_CRL_set_lastUpdate(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_set_lastUpdate(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_set_lastUpdate", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_set_lastUpdate(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_set_lastUpdate _cffi_d_X509_CRL_set_lastUpdate
#endif

static int _cffi_d_X509_CRL_set_nextUpdate(X509_CRL * x0, ASN1_OCTET_STRING * x1)
{
  return X509_CRL_set_nextUpdate(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_set_nextUpdate(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_set_nextUpdate", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_set_nextUpdate(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_set_nextUpdate _cffi_d_X509_CRL_set_nextUpdate
#endif

static int _cffi_d_X509_CRL_set_version(X509_CRL * x0, long x1)
{
  return X509_CRL_set_version(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_set_version(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_set_version", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_set_version(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_set_version _cffi_d_X509_CRL_set_version
#endif

static int _cffi_d_X509_CRL_sign(X509_CRL * x0, EVP_PKEY * x1, EVP_MD const * x2)
{
  return X509_CRL_sign(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_sign(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  EVP_PKEY * x1;
  EVP_MD const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_CRL_sign", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(226), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_sign(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_sign _cffi_d_X509_CRL_sign
#endif

static int _cffi_d_X509_CRL_sort(X509_CRL * x0)
{
  return X509_CRL_sort(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_sort(PyObject *self, PyObject *arg0)
{
  X509_CRL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_sort(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_sort _cffi_d_X509_CRL_sort
#endif

static int _cffi_d_X509_CRL_verify(X509_CRL * x0, EVP_PKEY * x1)
{
  return X509_CRL_verify(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_CRL_verify(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_CRL_verify", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_CRL_verify(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_CRL_verify _cffi_d_X509_CRL_verify
#endif

static X509_EXTENSION * _cffi_d_X509_EXTENSION_create_by_OBJ(X509_EXTENSION * * x0, ASN1_OBJECT * x1, int x2, ASN1_OCTET_STRING * x3)
{
  return X509_EXTENSION_create_by_OBJ(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_EXTENSION_create_by_OBJ(PyObject *self, PyObject *args)
{
  X509_EXTENSION * * x0;
  ASN1_OBJECT * x1;
  int x2;
  ASN1_OCTET_STRING * x3;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_EXTENSION_create_by_OBJ", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(810), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(810), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(811), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(13), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_EXTENSION_create_by_OBJ(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_EXTENSION_create_by_OBJ _cffi_d_X509_EXTENSION_create_by_OBJ
#endif

static X509_EXTENSION * _cffi_d_X509_EXTENSION_dup(X509_EXTENSION * x0)
{
  return X509_EXTENSION_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_EXTENSION_dup(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;
  X509_EXTENSION * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_EXTENSION_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_EXTENSION_dup _cffi_d_X509_EXTENSION_dup
#endif

static void _cffi_d_X509_EXTENSION_free(X509_EXTENSION * x0)
{
  X509_EXTENSION_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_EXTENSION_free(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_EXTENSION_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_EXTENSION_free _cffi_d_X509_EXTENSION_free
#endif

static int _cffi_d_X509_EXTENSION_get_critical(X509_EXTENSION * x0)
{
  return X509_EXTENSION_get_critical(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_EXTENSION_get_critical(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_EXTENSION_get_critical(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_EXTENSION_get_critical _cffi_d_X509_EXTENSION_get_critical
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_EXTENSION_get_data(X509_EXTENSION * x0)
{
  return X509_EXTENSION_get_data(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_EXTENSION_get_data(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_EXTENSION_get_data(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_EXTENSION_get_data _cffi_d_X509_EXTENSION_get_data
#endif

static ASN1_OBJECT * _cffi_d_X509_EXTENSION_get_object(X509_EXTENSION * x0)
{
  return X509_EXTENSION_get_object(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_EXTENSION_get_object(PyObject *self, PyObject *arg0)
{
  X509_EXTENSION * x0;
  Py_ssize_t datasize;
  ASN1_OBJECT * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(51), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_EXTENSION_get_object(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_X509_EXTENSION_get_object _cffi_d_X509_EXTENSION_get_object
#endif

static X509_NAME_ENTRY * _cffi_d_X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY * * x0, ASN1_OBJECT * x1, int x2, unsigned char const * x3, int x4)
{
  return X509_NAME_ENTRY_create_by_OBJ(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_ENTRY_create_by_OBJ(PyObject *self, PyObject *args)
{
  X509_NAME_ENTRY * * x0;
  ASN1_OBJECT * x1;
  int x2;
  unsigned char const * x3;
  int x4;
  Py_ssize_t datasize;
  X509_NAME_ENTRY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "X509_NAME_ENTRY_create_by_OBJ", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(863), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME_ENTRY * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(863), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(811), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_ENTRY_create_by_OBJ(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(54));
}
#else
#  define _cffi_f_X509_NAME_ENTRY_create_by_OBJ _cffi_d_X509_NAME_ENTRY_create_by_OBJ
#endif

static void _cffi_d_X509_NAME_ENTRY_free(X509_NAME_ENTRY * x0)
{
  X509_NAME_ENTRY_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_ENTRY_free(PyObject *self, PyObject *arg0)
{
  X509_NAME_ENTRY * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(54), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(54), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_NAME_ENTRY_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_NAME_ENTRY_free _cffi_d_X509_NAME_ENTRY_free
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_NAME_ENTRY_get_data(X509_NAME_ENTRY * x0)
{
  return X509_NAME_ENTRY_get_data(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_ENTRY_get_data(PyObject *self, PyObject *arg0)
{
  X509_NAME_ENTRY * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(54), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(54), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_ENTRY_get_data(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_NAME_ENTRY_get_data _cffi_d_X509_NAME_ENTRY_get_data
#endif

static ASN1_OBJECT * _cffi_d_X509_NAME_ENTRY_get_object(X509_NAME_ENTRY * x0)
{
  return X509_NAME_ENTRY_get_object(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_ENTRY_get_object(PyObject *self, PyObject *arg0)
{
  X509_NAME_ENTRY * x0;
  Py_ssize_t datasize;
  ASN1_OBJECT * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(54), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(54), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_ENTRY_get_object(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_X509_NAME_ENTRY_get_object _cffi_d_X509_NAME_ENTRY_get_object
#endif

static int _cffi_d_X509_NAME_add_entry(X509_NAME * x0, X509_NAME_ENTRY * x1, int x2, int x3)
{
  return X509_NAME_add_entry(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_add_entry(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  X509_NAME_ENTRY * x1;
  int x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_NAME_add_entry", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(54), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(54), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_add_entry(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_add_entry _cffi_d_X509_NAME_add_entry
#endif

static int _cffi_d_X509_NAME_add_entry_by_NID(X509_NAME * x0, int x1, int x2, unsigned char * x3, int x4, int x5, int x6)
{
  return X509_NAME_add_entry_by_NID(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_add_entry_by_NID(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  int x1;
  int x2;
  unsigned char * x3;
  int x4;
  int x5;
  int x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "X509_NAME_add_entry_by_NID", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_add_entry_by_NID(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_add_entry_by_NID _cffi_d_X509_NAME_add_entry_by_NID
#endif

static int _cffi_d_X509_NAME_add_entry_by_OBJ(X509_NAME * x0, ASN1_OBJECT * x1, int x2, unsigned char * x3, int x4, int x5, int x6)
{
  return X509_NAME_add_entry_by_OBJ(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_add_entry_by_OBJ(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  ASN1_OBJECT * x1;
  int x2;
  unsigned char * x3;
  int x4;
  int x5;
  int x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "X509_NAME_add_entry_by_OBJ", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(811), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(975), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_add_entry_by_OBJ(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_add_entry_by_OBJ _cffi_d_X509_NAME_add_entry_by_OBJ
#endif

static int _cffi_d_X509_NAME_add_entry_by_txt(X509_NAME * x0, char const * x1, int x2, unsigned char const * x3, int x4, int x5, int x6)
{
  return X509_NAME_add_entry_by_txt(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_add_entry_by_txt(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  char const * x1;
  int x2;
  unsigned char const * x3;
  int x4;
  int x5;
  int x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "X509_NAME_add_entry_by_txt", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(148), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_add_entry_by_txt(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_add_entry_by_txt _cffi_d_X509_NAME_add_entry_by_txt
#endif

static int _cffi_d_X509_NAME_cmp(X509_NAME const * x0, X509_NAME const * x1)
{
  return X509_NAME_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_cmp(PyObject *self, PyObject *args)
{
  X509_NAME const * x0;
  X509_NAME const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_NAME_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2474), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2474), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2474), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2474), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_cmp _cffi_d_X509_NAME_cmp
#endif

static X509_NAME_ENTRY * _cffi_d_X509_NAME_delete_entry(X509_NAME * x0, int x1)
{
  return X509_NAME_delete_entry(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_delete_entry(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  int x1;
  Py_ssize_t datasize;
  X509_NAME_ENTRY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_NAME_delete_entry", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_delete_entry(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(54));
}
#else
#  define _cffi_f_X509_NAME_delete_entry _cffi_d_X509_NAME_delete_entry
#endif

static X509_NAME * _cffi_d_X509_NAME_dup(X509_NAME * x0)
{
  return X509_NAME_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_dup(PyObject *self, PyObject *arg0)
{
  X509_NAME * x0;
  Py_ssize_t datasize;
  X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_X509_NAME_dup _cffi_d_X509_NAME_dup
#endif

static int _cffi_d_X509_NAME_entry_count(X509_NAME * x0)
{
  return X509_NAME_entry_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_entry_count(PyObject *self, PyObject *arg0)
{
  X509_NAME * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_entry_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_entry_count _cffi_d_X509_NAME_entry_count
#endif

static void _cffi_d_X509_NAME_free(X509_NAME * x0)
{
  X509_NAME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_free(PyObject *self, PyObject *arg0)
{
  X509_NAME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_NAME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_NAME_free _cffi_d_X509_NAME_free
#endif

static X509_NAME_ENTRY * _cffi_d_X509_NAME_get_entry(X509_NAME * x0, int x1)
{
  return X509_NAME_get_entry(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_get_entry(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  int x1;
  Py_ssize_t datasize;
  X509_NAME_ENTRY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_NAME_get_entry", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_get_entry(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(54));
}
#else
#  define _cffi_f_X509_NAME_get_entry _cffi_d_X509_NAME_get_entry
#endif

static int _cffi_d_X509_NAME_get_index_by_NID(X509_NAME * x0, int x1, int x2)
{
  return X509_NAME_get_index_by_NID(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_get_index_by_NID(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  int x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_NAME_get_index_by_NID", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_get_index_by_NID(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_NAME_get_index_by_NID _cffi_d_X509_NAME_get_index_by_NID
#endif

static unsigned long _cffi_d_X509_NAME_hash(X509_NAME * x0)
{
  return X509_NAME_hash(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_hash(PyObject *self, PyObject *arg0)
{
  X509_NAME * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_hash(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_X509_NAME_hash _cffi_d_X509_NAME_hash
#endif

static X509_NAME * _cffi_d_X509_NAME_new(void)
{
  return X509_NAME_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_new(PyObject *self, PyObject *noarg)
{
  X509_NAME * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_X509_NAME_new _cffi_d_X509_NAME_new
#endif

static char * _cffi_d_X509_NAME_oneline(X509_NAME * x0, char * x1, int x2)
{
  return X509_NAME_oneline(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_NAME_oneline(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  char * x1;
  int x2;
  Py_ssize_t datasize;
  char * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_NAME_oneline", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(594), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_NAME_oneline(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(594));
}
#else
#  define _cffi_f_X509_NAME_oneline _cffi_d_X509_NAME_oneline
#endif

static X509 * _cffi_d_X509_OBJECT_get0_X509(X509_OBJECT * x0)
{
  return X509_OBJECT_get0_X509(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_OBJECT_get0_X509(PyObject *self, PyObject *arg0)
{
  X509_OBJECT * x0;
  Py_ssize_t datasize;
  X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(737), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(737), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_OBJECT_get0_X509(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_X509_OBJECT_get0_X509 _cffi_d_X509_OBJECT_get0_X509
#endif

static int _cffi_d_X509_OBJECT_get_type(X509_OBJECT const * x0)
{
  return X509_OBJECT_get_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_OBJECT_get_type(PyObject *self, PyObject *arg0)
{
  X509_OBJECT const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2481), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_OBJECT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2481), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_OBJECT_get_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_OBJECT_get_type _cffi_d_X509_OBJECT_get_type
#endif

static int _cffi_d_X509_REQ_add_extensions(X509_REQ * x0, X509_EXTENSIONS * x1)
{
  return X509_REQ_add_extensions(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_add_extensions(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  X509_EXTENSIONS * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REQ_add_extensions", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(819), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_add_extensions(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_add_extensions _cffi_d_X509_REQ_add_extensions
#endif

static int _cffi_d_X509_REQ_digest(X509_REQ const * x0, EVP_MD const * x1, unsigned char * x2, unsigned int * x3)
{
  return X509_REQ_digest(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_digest(PyObject *self, PyObject *args)
{
  X509_REQ const * x0;
  EVP_MD const * x1;
  unsigned char * x2;
  unsigned int * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_REQ_digest", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2509), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2509), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(226), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1871), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_digest(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_digest _cffi_d_X509_REQ_digest
#endif

static void _cffi_d_X509_REQ_free(X509_REQ * x0)
{
  X509_REQ_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_free(PyObject *self, PyObject *arg0)
{
  X509_REQ * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_REQ_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_REQ_free _cffi_d_X509_REQ_free
#endif

static void _cffi_d_X509_REQ_get0_signature(X509_REQ const * x0, ASN1_OCTET_STRING const * * x1, X509_ALGOR const * * x2)
{
  X509_REQ_get0_signature(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_get0_signature(PyObject *self, PyObject *args)
{
  X509_REQ const * x0;
  ASN1_OCTET_STRING const * * x1;
  X509_ALGOR const * * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_REQ_get0_signature", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2509), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2509), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3495), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(3495), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3496), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509_ALGOR const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(3496), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_REQ_get0_signature(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_REQ_get0_signature _cffi_d_X509_REQ_get0_signature
#endif

static X509_EXTENSIONS * _cffi_d_X509_REQ_get_extensions(X509_REQ * x0)
{
  return X509_REQ_get_extensions(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_get_extensions(PyObject *self, PyObject *arg0)
{
  X509_REQ * x0;
  Py_ssize_t datasize;
  X509_EXTENSIONS * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_get_extensions(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(819));
}
#else
#  define _cffi_f_X509_REQ_get_extensions _cffi_d_X509_REQ_get_extensions
#endif

static EVP_PKEY * _cffi_d_X509_REQ_get_pubkey(X509_REQ * x0)
{
  return X509_REQ_get_pubkey(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_get_pubkey(PyObject *self, PyObject *arg0)
{
  X509_REQ * x0;
  Py_ssize_t datasize;
  EVP_PKEY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_get_pubkey(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_X509_REQ_get_pubkey _cffi_d_X509_REQ_get_pubkey
#endif

static X509_NAME * _cffi_d_X509_REQ_get_subject_name(X509_REQ * x0)
{
  return X509_REQ_get_subject_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_get_subject_name(PyObject *self, PyObject *arg0)
{
  X509_REQ * x0;
  Py_ssize_t datasize;
  X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_get_subject_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_X509_REQ_get_subject_name _cffi_d_X509_REQ_get_subject_name
#endif

static long _cffi_d_X509_REQ_get_version(X509_REQ * x0)
{
  return X509_REQ_get_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_get_version(PyObject *self, PyObject *arg0)
{
  X509_REQ * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_get_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_X509_REQ_get_version _cffi_d_X509_REQ_get_version
#endif

static X509_REQ * _cffi_d_X509_REQ_new(void)
{
  return X509_REQ_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_new(PyObject *self, PyObject *noarg)
{
  X509_REQ * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(502));
}
#else
#  define _cffi_f_X509_REQ_new _cffi_d_X509_REQ_new
#endif

static int _cffi_d_X509_REQ_print(BIO * x0, X509_REQ * x1)
{
  return X509_REQ_print(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_print(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_REQ * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REQ_print", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(502), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_print(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_print _cffi_d_X509_REQ_print
#endif

static int _cffi_d_X509_REQ_print_ex(BIO * x0, X509_REQ * x1, unsigned long x2, unsigned long x3)
{
  return X509_REQ_print_ex(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_print_ex(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_REQ * x1;
  unsigned long x2;
  unsigned long x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_REQ_print_ex", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(502), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned long);
  if (x2 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, unsigned long);
  if (x3 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_print_ex(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_print_ex _cffi_d_X509_REQ_print_ex
#endif

static int _cffi_d_X509_REQ_set_pubkey(X509_REQ * x0, EVP_PKEY * x1)
{
  return X509_REQ_set_pubkey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_set_pubkey(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REQ_set_pubkey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_set_pubkey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_set_pubkey _cffi_d_X509_REQ_set_pubkey
#endif

static int _cffi_d_X509_REQ_set_subject_name(X509_REQ * x0, X509_NAME * x1)
{
  return X509_REQ_set_subject_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_set_subject_name(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  X509_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REQ_set_subject_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(847), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_set_subject_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_set_subject_name _cffi_d_X509_REQ_set_subject_name
#endif

static int _cffi_d_X509_REQ_set_version(X509_REQ * x0, long x1)
{
  return X509_REQ_set_version(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_set_version(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REQ_set_version", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_set_version(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_set_version _cffi_d_X509_REQ_set_version
#endif

static int _cffi_d_X509_REQ_sign(X509_REQ * x0, EVP_PKEY * x1, EVP_MD const * x2)
{
  return X509_REQ_sign(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_sign(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  EVP_PKEY * x1;
  EVP_MD const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_REQ_sign", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(226), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_sign(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_sign _cffi_d_X509_REQ_sign
#endif

static int _cffi_d_X509_REQ_verify(X509_REQ * x0, EVP_PKEY * x1)
{
  return X509_REQ_verify(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REQ_verify(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REQ_verify", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REQ_verify(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REQ_verify _cffi_d_X509_REQ_verify
#endif

static int _cffi_d_X509_REVOKED_add1_ext_i2d(X509_REVOKED * x0, int x1, void * x2, int x3, unsigned long x4)
{
  return X509_REVOKED_add1_ext_i2d(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_add1_ext_i2d(PyObject *self, PyObject *args)
{
  X509_REVOKED * x0;
  int x1;
  void * x2;
  int x3;
  unsigned long x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "X509_REVOKED_add1_ext_i2d", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, unsigned long);
  if (x4 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_add1_ext_i2d(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REVOKED_add1_ext_i2d _cffi_d_X509_REVOKED_add1_ext_i2d
#endif

static int _cffi_d_X509_REVOKED_add_ext(X509_REVOKED * x0, X509_EXTENSION * x1, int x2)
{
  return X509_REVOKED_add_ext(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_add_ext(PyObject *self, PyObject *args)
{
  X509_REVOKED * x0;
  X509_EXTENSION * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_REVOKED_add_ext", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(51), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_add_ext(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REVOKED_add_ext _cffi_d_X509_REVOKED_add_ext
#endif

static X509_EXTENSION * _cffi_d_X509_REVOKED_delete_ext(X509_REVOKED * x0, int x1)
{
  return X509_REVOKED_delete_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_delete_ext(PyObject *self, PyObject *args)
{
  X509_REVOKED * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REVOKED_delete_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_delete_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_REVOKED_delete_ext _cffi_d_X509_REVOKED_delete_ext
#endif

static void _cffi_d_X509_REVOKED_free(X509_REVOKED * x0)
{
  X509_REVOKED_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_free(PyObject *self, PyObject *arg0)
{
  X509_REVOKED * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_REVOKED_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_REVOKED_free _cffi_d_X509_REVOKED_free
#endif

static ASN1_OCTET_STRING const * _cffi_d_X509_REVOKED_get0_revocationDate(X509_REVOKED const * x0)
{
  return X509_REVOKED_get0_revocationDate(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_get0_revocationDate(PyObject *self, PyObject *arg0)
{
  X509_REVOKED const * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(33), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_get0_revocationDate(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3641));
}
#else
#  define _cffi_f_X509_REVOKED_get0_revocationDate _cffi_d_X509_REVOKED_get0_revocationDate
#endif

static ASN1_INTEGER const * _cffi_d_X509_REVOKED_get0_serialNumber(X509_REVOKED const * x0)
{
  return X509_REVOKED_get0_serialNumber(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_get0_serialNumber(PyObject *self, PyObject *arg0)
{
  X509_REVOKED const * x0;
  Py_ssize_t datasize;
  ASN1_INTEGER const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(33), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_get0_serialNumber(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3636));
}
#else
#  define _cffi_f_X509_REVOKED_get0_serialNumber _cffi_d_X509_REVOKED_get0_serialNumber
#endif

static X509_EXTENSION * _cffi_d_X509_REVOKED_get_ext(X509_REVOKED * x0, int x1)
{
  return X509_REVOKED_get_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_get_ext(PyObject *self, PyObject *args)
{
  X509_REVOKED * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REVOKED_get_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_get_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_REVOKED_get_ext _cffi_d_X509_REVOKED_get_ext
#endif

static int _cffi_d_X509_REVOKED_get_ext_count(X509_REVOKED * x0)
{
  return X509_REVOKED_get_ext_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_get_ext_count(PyObject *self, PyObject *arg0)
{
  X509_REVOKED * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_get_ext_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REVOKED_get_ext_count _cffi_d_X509_REVOKED_get_ext_count
#endif

static X509_REVOKED * _cffi_d_X509_REVOKED_new(void)
{
  return X509_REVOKED_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_new(PyObject *self, PyObject *noarg)
{
  X509_REVOKED * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(823));
}
#else
#  define _cffi_f_X509_REVOKED_new _cffi_d_X509_REVOKED_new
#endif

static int _cffi_d_X509_REVOKED_set_revocationDate(X509_REVOKED * x0, ASN1_OCTET_STRING * x1)
{
  return X509_REVOKED_set_revocationDate(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_set_revocationDate(PyObject *self, PyObject *args)
{
  X509_REVOKED * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REVOKED_set_revocationDate", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_set_revocationDate(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REVOKED_set_revocationDate _cffi_d_X509_REVOKED_set_revocationDate
#endif

static int _cffi_d_X509_REVOKED_set_serialNumber(X509_REVOKED * x0, ASN1_INTEGER * x1)
{
  return X509_REVOKED_set_serialNumber(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_REVOKED_set_serialNumber(PyObject *self, PyObject *args)
{
  X509_REVOKED * x0;
  ASN1_INTEGER * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_REVOKED_set_serialNumber", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(823), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(823), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(17), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_REVOKED_set_serialNumber(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_REVOKED_set_serialNumber _cffi_d_X509_REVOKED_set_serialNumber
#endif

static void _cffi_d_X509_STORE_CTX_cleanup(X509_STORE_CTX * x0)
{
  X509_STORE_CTX_cleanup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_cleanup(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_cleanup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_cleanup _cffi_d_X509_STORE_CTX_cleanup
#endif

static void _cffi_d_X509_STORE_CTX_free(X509_STORE_CTX * x0)
{
  X509_STORE_CTX_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_free(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_free _cffi_d_X509_STORE_CTX_free
#endif

static X509 * _cffi_d_X509_STORE_CTX_get0_cert(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get0_cert(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get0_cert(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get0_cert(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_X509_STORE_CTX_get0_cert _cffi_d_X509_STORE_CTX_get0_cert
#endif

static X509_VERIFY_PARAM * _cffi_d_X509_STORE_CTX_get0_param(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get0_param(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get0_param(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  X509_VERIFY_PARAM * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get0_param(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(2554));
}
#else
#  define _cffi_f_X509_STORE_CTX_get0_param _cffi_d_X509_STORE_CTX_get0_param
#endif

static Cryptography_STACK_OF_X509 * _cffi_d_X509_STORE_CTX_get1_chain(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get1_chain(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get1_chain(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get1_chain(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(210));
}
#else
#  define _cffi_f_X509_STORE_CTX_get1_chain _cffi_d_X509_STORE_CTX_get1_chain
#endif

static int _cffi_d_X509_STORE_CTX_get1_issuer(X509 * * x0, X509_STORE_CTX * x1, X509 * x2)
{
  return X509_STORE_CTX_get1_issuer(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get1_issuer(PyObject *self, PyObject *args)
{
  X509 * * x0;
  X509_STORE_CTX * x1;
  X509 * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_get1_issuer", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(718), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(718), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(258), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(28), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get1_issuer(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_get1_issuer _cffi_d_X509_STORE_CTX_get1_issuer
#endif

static Cryptography_STACK_OF_X509 * _cffi_d_X509_STORE_CTX_get_chain(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get_chain(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get_chain(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get_chain(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(210));
}
#else
#  define _cffi_f_X509_STORE_CTX_get_chain _cffi_d_X509_STORE_CTX_get_chain
#endif

static X509 * _cffi_d_X509_STORE_CTX_get_current_cert(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get_current_cert(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get_current_cert(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get_current_cert(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_X509_STORE_CTX_get_current_cert _cffi_d_X509_STORE_CTX_get_current_cert
#endif

static int _cffi_d_X509_STORE_CTX_get_error(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get_error(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get_error(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get_error(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_get_error _cffi_d_X509_STORE_CTX_get_error
#endif

static int _cffi_d_X509_STORE_CTX_get_error_depth(X509_STORE_CTX * x0)
{
  return X509_STORE_CTX_get_error_depth(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get_error_depth(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get_error_depth(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_get_error_depth _cffi_d_X509_STORE_CTX_get_error_depth
#endif

static void * _cffi_d_X509_STORE_CTX_get_ex_data(X509_STORE_CTX * x0, int x1)
{
  return X509_STORE_CTX_get_ex_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get_ex_data(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_get_ex_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get_ex_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_X509_STORE_CTX_get_ex_data _cffi_d_X509_STORE_CTX_get_ex_data
#endif

static int _cffi_d_X509_STORE_CTX_get_ex_new_index(long x0, void * x1, CRYPTO_EX_new * x2, CRYPTO_EX_dup * x3, CRYPTO_EX_free * x4)
{
  return X509_STORE_CTX_get_ex_new_index(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_get_ex_new_index(PyObject *self, PyObject *args)
{
  long x0;
  void * x1;
  CRYPTO_EX_new * x2;
  CRYPTO_EX_dup * x3;
  CRYPTO_EX_free * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_get_ex_new_index", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, long);
  if (x0 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2762), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (CRYPTO_EX_new *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(2762), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2763), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (CRYPTO_EX_dup *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(2763), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2764), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (CRYPTO_EX_free *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(2764), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_get_ex_new_index(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_get_ex_new_index _cffi_d_X509_STORE_CTX_get_ex_new_index
#endif

static int _cffi_d_X509_STORE_CTX_init(X509_STORE_CTX * x0, X509_STORE * x1, X509 * x2, Cryptography_STACK_OF_X509 * x3)
{
  return X509_STORE_CTX_init(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_init(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  X509_STORE * x1;
  X509 * x2;
  Cryptography_STACK_OF_X509 * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_init", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(278), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(28), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(210), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_init(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_init _cffi_d_X509_STORE_CTX_init
#endif

static X509_STORE_CTX * _cffi_d_X509_STORE_CTX_new(void)
{
  return X509_STORE_CTX_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_new(PyObject *self, PyObject *noarg)
{
  X509_STORE_CTX * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(258));
}
#else
#  define _cffi_f_X509_STORE_CTX_new _cffi_d_X509_STORE_CTX_new
#endif

static void _cffi_d_X509_STORE_CTX_set0_crls(X509_STORE_CTX * x0, Cryptography_STACK_OF_X509_CRL * x1)
{
  X509_STORE_CTX_set0_crls(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set0_crls(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  Cryptography_STACK_OF_X509_CRL * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set0_crls", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(772), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509_CRL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(772), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_set0_crls(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_set0_crls _cffi_d_X509_STORE_CTX_set0_crls
#endif

static void _cffi_d_X509_STORE_CTX_set0_param(X509_STORE_CTX * x0, X509_VERIFY_PARAM * x1)
{
  X509_STORE_CTX_set0_param(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set0_param(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  X509_VERIFY_PARAM * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set0_param", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2554), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_set0_param(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_set0_param _cffi_d_X509_STORE_CTX_set0_param
#endif

static void _cffi_d_X509_STORE_CTX_set_cert(X509_STORE_CTX * x0, X509 * x1)
{
  X509_STORE_CTX_set_cert(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set_cert(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  X509 * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set_cert", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_set_cert(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_set_cert _cffi_d_X509_STORE_CTX_set_cert
#endif

static void _cffi_d_X509_STORE_CTX_set_chain(X509_STORE_CTX * x0, Cryptography_STACK_OF_X509 * x1)
{
  X509_STORE_CTX_set_chain(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set_chain(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  Cryptography_STACK_OF_X509 * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set_chain", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(210), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_set_chain(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_set_chain _cffi_d_X509_STORE_CTX_set_chain
#endif

static int _cffi_d_X509_STORE_CTX_set_default(X509_STORE_CTX * x0, char const * x1)
{
  return X509_STORE_CTX_set_default(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set_default(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set_default", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_set_default(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_set_default _cffi_d_X509_STORE_CTX_set_default
#endif

static void _cffi_d_X509_STORE_CTX_set_error(X509_STORE_CTX * x0, int x1)
{
  X509_STORE_CTX_set_error(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set_error(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set_error", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_set_error(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_set_error _cffi_d_X509_STORE_CTX_set_error
#endif

static int _cffi_d_X509_STORE_CTX_set_ex_data(X509_STORE_CTX * x0, int x1, void * x2)
{
  return X509_STORE_CTX_set_ex_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set_ex_data(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  int x1;
  void * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set_ex_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_CTX_set_ex_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_CTX_set_ex_data _cffi_d_X509_STORE_CTX_set_ex_data
#endif

static void _cffi_d_X509_STORE_CTX_set_verify_cb(X509_STORE_CTX * x0, int(* x1)(int, X509_STORE_CTX *))
{
  X509_STORE_CTX_set_verify_cb(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_set_verify_cb(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  int(* x1)(int, X509_STORE_CTX *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_set_verify_cb", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(int, X509_STORE_CTX *))_cffi_to_c_pointer(arg1, _cffi_type(3396));
  if (x1 == (int(*)(int, X509_STORE_CTX *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_set_verify_cb(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_set_verify_cb _cffi_d_X509_STORE_CTX_set_verify_cb
#endif

static void _cffi_d_X509_STORE_CTX_trusted_stack(X509_STORE_CTX * x0, Cryptography_STACK_OF_X509 * x1)
{
  X509_STORE_CTX_trusted_stack(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_CTX_trusted_stack(PyObject *self, PyObject *args)
{
  X509_STORE_CTX * x0;
  Cryptography_STACK_OF_X509 * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_CTX_trusted_stack", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(210), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_CTX_trusted_stack(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_CTX_trusted_stack _cffi_d_X509_STORE_CTX_trusted_stack
#endif

static int _cffi_d_X509_STORE_add_cert(X509_STORE * x0, X509 * x1)
{
  return X509_STORE_add_cert(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_add_cert(PyObject *self, PyObject *args)
{
  X509_STORE * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_add_cert", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_add_cert(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_add_cert _cffi_d_X509_STORE_add_cert
#endif

static int _cffi_d_X509_STORE_add_crl(X509_STORE * x0, X509_CRL * x1)
{
  return X509_STORE_add_crl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_add_crl(PyObject *self, PyObject *args)
{
  X509_STORE * x0;
  X509_CRL * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_add_crl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_add_crl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_add_crl _cffi_d_X509_STORE_add_crl
#endif

static void _cffi_d_X509_STORE_free(X509_STORE * x0)
{
  X509_STORE_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_free(PyObject *self, PyObject *arg0)
{
  X509_STORE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_free _cffi_d_X509_STORE_free
#endif

static Cryptography_STACK_OF_X509_OBJECT * _cffi_d_X509_STORE_get0_objects(X509_STORE * x0)
{
  return X509_STORE_get0_objects(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_get0_objects(PyObject *self, PyObject *arg0)
{
  X509_STORE * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509_OBJECT * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_get0_objects(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(870));
}
#else
#  define _cffi_f_X509_STORE_get0_objects _cffi_d_X509_STORE_get0_objects
#endif

static X509_VERIFY_PARAM * _cffi_d_X509_STORE_get0_param(X509_STORE * x0)
{
  return X509_STORE_get0_param(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_get0_param(PyObject *self, PyObject *arg0)
{
  X509_STORE * x0;
  Py_ssize_t datasize;
  X509_VERIFY_PARAM * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_get0_param(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(2554));
}
#else
#  define _cffi_f_X509_STORE_get0_param _cffi_d_X509_STORE_get0_param
#endif

static int(* _cffi_d_X509_STORE_get_get_issuer(X509_STORE * x0))(X509 * *, X509_STORE_CTX *, X509 *)
{
  return X509_STORE_get_get_issuer(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_get_get_issuer(PyObject *self, PyObject *arg0)
{
  X509_STORE * x0;
  Py_ssize_t datasize;
  int(* result)(X509 * *, X509_STORE_CTX *, X509 *);

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_get_get_issuer(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3526));
}
#else
#  define _cffi_f_X509_STORE_get_get_issuer _cffi_d_X509_STORE_get_get_issuer
#endif

static int _cffi_d_X509_STORE_load_locations(X509_STORE * x0, char const * x1, char const * x2)
{
  return X509_STORE_load_locations(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_load_locations(PyObject *self, PyObject *args)
{
  X509_STORE * x0;
  char const * x1;
  char const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_STORE_load_locations", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(57), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_load_locations(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_load_locations _cffi_d_X509_STORE_load_locations
#endif

static X509_STORE * _cffi_d_X509_STORE_new(void)
{
  return X509_STORE_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_new(PyObject *self, PyObject *noarg)
{
  X509_STORE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(278));
}
#else
#  define _cffi_f_X509_STORE_new _cffi_d_X509_STORE_new
#endif

static int _cffi_d_X509_STORE_set1_param(X509_STORE * x0, X509_VERIFY_PARAM * x1)
{
  return X509_STORE_set1_param(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_set1_param(PyObject *self, PyObject *args)
{
  X509_STORE * x0;
  X509_VERIFY_PARAM * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_set1_param", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2554), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_set1_param(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_set1_param _cffi_d_X509_STORE_set1_param
#endif

static int _cffi_d_X509_STORE_set_default_paths(X509_STORE * x0)
{
  return X509_STORE_set_default_paths(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_set_default_paths(PyObject *self, PyObject *arg0)
{
  X509_STORE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_set_default_paths(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_set_default_paths _cffi_d_X509_STORE_set_default_paths
#endif

static int _cffi_d_X509_STORE_set_flags(X509_STORE * x0, unsigned long x1)
{
  return X509_STORE_set_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_set_flags(PyObject *self, PyObject *args)
{
  X509_STORE * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_set_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_STORE_set_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_STORE_set_flags _cffi_d_X509_STORE_set_flags
#endif

static void _cffi_d_X509_STORE_set_get_issuer(X509_STORE * x0, int(* x1)(X509 * *, X509_STORE_CTX *, X509 *))
{
  X509_STORE_set_get_issuer(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_STORE_set_get_issuer(PyObject *self, PyObject *args)
{
  X509_STORE * x0;
  int(* x1)(X509 * *, X509_STORE_CTX *, X509 *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_STORE_set_get_issuer", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(278), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(278), arg0) < 0)
      return NULL;
  }

  x1 = (int(*)(X509 * *, X509_STORE_CTX *, X509 *))_cffi_to_c_pointer(arg1, _cffi_type(3526));
  if (x1 == (int(*)(X509 * *, X509_STORE_CTX *, X509 *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_STORE_set_get_issuer(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_STORE_set_get_issuer _cffi_d_X509_STORE_set_get_issuer
#endif

static int _cffi_d_X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM * x0, ASN1_OBJECT * x1)
{
  return X509_VERIFY_PARAM_add0_policy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_add0_policy(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  ASN1_OBJECT * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_add0_policy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(811), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_add0_policy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_add0_policy _cffi_d_X509_VERIFY_PARAM_add0_policy
#endif

static int _cffi_d_X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM * x0, unsigned long x1)
{
  return X509_VERIFY_PARAM_clear_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_clear_flags(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_clear_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_clear_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_clear_flags _cffi_d_X509_VERIFY_PARAM_clear_flags
#endif

static void _cffi_d_X509_VERIFY_PARAM_free(X509_VERIFY_PARAM * x0)
{
  X509_VERIFY_PARAM_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_free(PyObject *self, PyObject *arg0)
{
  X509_VERIFY_PARAM * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_VERIFY_PARAM_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_free _cffi_d_X509_VERIFY_PARAM_free
#endif

static int _cffi_d_X509_VERIFY_PARAM_get_depth(X509_VERIFY_PARAM const * x0)
{
  return X509_VERIFY_PARAM_get_depth(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_get_depth(PyObject *self, PyObject *arg0)
{
  X509_VERIFY_PARAM const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2618), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2618), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_get_depth(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_get_depth _cffi_d_X509_VERIFY_PARAM_get_depth
#endif

static unsigned long _cffi_d_X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM * x0)
{
  return X509_VERIFY_PARAM_get_flags(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_get_flags(PyObject *self, PyObject *arg0)
{
  X509_VERIFY_PARAM * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_get_flags(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_get_flags _cffi_d_X509_VERIFY_PARAM_get_flags
#endif

static X509_VERIFY_PARAM * _cffi_d_X509_VERIFY_PARAM_new(void)
{
  return X509_VERIFY_PARAM_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_new(PyObject *self, PyObject *noarg)
{
  X509_VERIFY_PARAM * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(2554));
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_new _cffi_d_X509_VERIFY_PARAM_new
#endif

static int _cffi_d_X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM * x0, char const * x1, size_t x2)
{
  return X509_VERIFY_PARAM_set1_email(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set1_email(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  char const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set1_email", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set1_email(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set1_email _cffi_d_X509_VERIFY_PARAM_set1_email
#endif

static int _cffi_d_X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM * x0, char const * x1, size_t x2)
{
  return X509_VERIFY_PARAM_set1_host(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set1_host(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  char const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set1_host", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set1_host(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set1_host _cffi_d_X509_VERIFY_PARAM_set1_host
#endif

static int _cffi_d_X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM * x0, unsigned char const * x1, size_t x2)
{
  return X509_VERIFY_PARAM_set1_ip(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set1_ip(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  unsigned char const * x1;
  size_t x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set1_ip", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(148), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set1_ip(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set1_ip _cffi_d_X509_VERIFY_PARAM_set1_ip
#endif

static int _cffi_d_X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM * x0, char const * x1)
{
  return X509_VERIFY_PARAM_set1_ip_asc(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set1_ip_asc(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  char const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set1_ip_asc", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(57), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set1_ip_asc(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set1_ip_asc _cffi_d_X509_VERIFY_PARAM_set1_ip_asc
#endif

static int _cffi_d_X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM * x0, Cryptography_STACK_OF_ASN1_OBJECT * x1)
{
  return X509_VERIFY_PARAM_set1_policies(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set1_policies(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  Cryptography_STACK_OF_ASN1_OBJECT * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set1_policies", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(47), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (Cryptography_STACK_OF_ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(47), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set1_policies(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set1_policies _cffi_d_X509_VERIFY_PARAM_set1_policies
#endif

static void _cffi_d_X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM * x0, int x1)
{
  X509_VERIFY_PARAM_set_depth(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set_depth(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set_depth", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_VERIFY_PARAM_set_depth(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set_depth _cffi_d_X509_VERIFY_PARAM_set_depth
#endif

static int _cffi_d_X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM * x0, unsigned long x1)
{
  return X509_VERIFY_PARAM_set_flags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set_flags(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  unsigned long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set_flags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned long);
  if (x1 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set_flags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set_flags _cffi_d_X509_VERIFY_PARAM_set_flags
#endif

static void _cffi_d_X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM * x0, unsigned int x1)
{
  X509_VERIFY_PARAM_set_hostflags(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set_hostflags(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  unsigned int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set_hostflags", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned int);
  if (x1 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_VERIFY_PARAM_set_hostflags(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set_hostflags _cffi_d_X509_VERIFY_PARAM_set_hostflags
#endif

static int _cffi_d_X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM * x0, int x1)
{
  return X509_VERIFY_PARAM_set_purpose(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set_purpose(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set_purpose", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set_purpose(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set_purpose _cffi_d_X509_VERIFY_PARAM_set_purpose
#endif

static void _cffi_d_X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM * x0, time_t x1)
{
  X509_VERIFY_PARAM_set_time(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set_time(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  time_t x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set_time", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, time_t);
  if (x1 == (time_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_VERIFY_PARAM_set_time(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set_time _cffi_d_X509_VERIFY_PARAM_set_time
#endif

static int _cffi_d_X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM * x0, int x1)
{
  return X509_VERIFY_PARAM_set_trust(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_VERIFY_PARAM_set_trust(PyObject *self, PyObject *args)
{
  X509_VERIFY_PARAM * x0;
  int x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_VERIFY_PARAM_set_trust", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2554), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_VERIFY_PARAM *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2554), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_VERIFY_PARAM_set_trust(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_VERIFY_PARAM_set_trust _cffi_d_X509_VERIFY_PARAM_set_trust
#endif

static int _cffi_d_X509_add_ext(X509 * x0, X509_EXTENSION * x1, int x2)
{
  return X509_add_ext(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_add_ext(PyObject *self, PyObject *args)
{
  X509 * x0;
  X509_EXTENSION * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_add_ext", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(51), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_add_ext(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_add_ext _cffi_d_X509_add_ext
#endif

static unsigned char * _cffi_d_X509_alias_get0(X509 * x0, int * x1)
{
  return X509_alias_get0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_alias_get0(PyObject *self, PyObject *args)
{
  X509 * x0;
  int * x1;
  Py_ssize_t datasize;
  unsigned char * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_alias_get0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (int *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1509), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_alias_get0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(975));
}
#else
#  define _cffi_f_X509_alias_get0 _cffi_d_X509_alias_get0
#endif

static int _cffi_d_X509_check_ca(X509 * x0)
{
  return X509_check_ca(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_check_ca(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_check_ca(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_check_ca _cffi_d_X509_check_ca
#endif

static int _cffi_d_X509_cmp(X509 const * x0, X509 const * x1)
{
  return X509_cmp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_cmp(PyObject *self, PyObject *args)
{
  X509 const * x0;
  X509 const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_cmp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(751), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(751), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(751), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(751), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_cmp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_cmp _cffi_d_X509_cmp
#endif

static X509_EXTENSION * _cffi_d_X509_delete_ext(X509 * x0, int x1)
{
  return X509_delete_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_delete_ext(PyObject *self, PyObject *args)
{
  X509 * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_delete_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_delete_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_delete_ext _cffi_d_X509_delete_ext
#endif

static int _cffi_d_X509_digest(X509 const * x0, EVP_MD const * x1, unsigned char * x2, unsigned int * x3)
{
  return X509_digest(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_digest(PyObject *self, PyObject *args)
{
  X509 const * x0;
  EVP_MD const * x1;
  unsigned char * x2;
  unsigned int * x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_digest", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(751), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(751), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(226), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(975), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned char *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(975), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1871), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (unsigned int *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1871), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_digest(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_digest _cffi_d_X509_digest
#endif

static X509 * _cffi_d_X509_dup(X509 * x0)
{
  return X509_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_dup(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  X509 * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_X509_dup _cffi_d_X509_dup
#endif

static void _cffi_d_X509_free(X509 * x0)
{
  X509_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_free(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_free _cffi_d_X509_free
#endif

static void _cffi_d_X509_get0_signature(ASN1_OCTET_STRING * * x0, X509_ALGOR * * x1, X509 * x2)
{
  X509_get0_signature(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get0_signature(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * * x0;
  X509_ALGOR * * x1;
  X509 * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_get0_signature", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3144), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(3144), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(3145), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_ALGOR * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(3145), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (X509 *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(28), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { X509_get0_signature(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_X509_get0_signature _cffi_d_X509_get0_signature
#endif

static X509_ALGOR const * _cffi_d_X509_get0_tbs_sigalg(X509 const * x0)
{
  return X509_get0_tbs_sigalg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get0_tbs_sigalg(PyObject *self, PyObject *arg0)
{
  X509 const * x0;
  Py_ssize_t datasize;
  X509_ALGOR const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(751), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(751), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get0_tbs_sigalg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3761));
}
#else
#  define _cffi_f_X509_get0_tbs_sigalg _cffi_d_X509_get0_tbs_sigalg
#endif

static char const * _cffi_d_X509_get_default_cert_area(void)
{
  return X509_get_default_cert_area();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_default_cert_area(PyObject *self, PyObject *noarg)
{
  char const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_default_cert_area(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_get_default_cert_area _cffi_d_X509_get_default_cert_area
#endif

static char const * _cffi_d_X509_get_default_cert_dir(void)
{
  return X509_get_default_cert_dir();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_default_cert_dir(PyObject *self, PyObject *noarg)
{
  char const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_default_cert_dir(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_get_default_cert_dir _cffi_d_X509_get_default_cert_dir
#endif

static char const * _cffi_d_X509_get_default_cert_dir_env(void)
{
  return X509_get_default_cert_dir_env();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_default_cert_dir_env(PyObject *self, PyObject *noarg)
{
  char const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_default_cert_dir_env(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_get_default_cert_dir_env _cffi_d_X509_get_default_cert_dir_env
#endif

static char const * _cffi_d_X509_get_default_cert_file(void)
{
  return X509_get_default_cert_file();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_default_cert_file(PyObject *self, PyObject *noarg)
{
  char const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_default_cert_file(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_get_default_cert_file _cffi_d_X509_get_default_cert_file
#endif

static char const * _cffi_d_X509_get_default_cert_file_env(void)
{
  return X509_get_default_cert_file_env();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_default_cert_file_env(PyObject *self, PyObject *noarg)
{
  char const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_default_cert_file_env(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_get_default_cert_file_env _cffi_d_X509_get_default_cert_file_env
#endif

static char const * _cffi_d_X509_get_default_private_dir(void)
{
  return X509_get_default_private_dir();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_default_private_dir(PyObject *self, PyObject *noarg)
{
  char const * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_default_private_dir(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_get_default_private_dir _cffi_d_X509_get_default_private_dir
#endif

static void * _cffi_d_X509_get_ex_data(X509 * x0, int x1)
{
  return X509_get_ex_data(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_ex_data(PyObject *self, PyObject *args)
{
  X509 * x0;
  int x1;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_get_ex_data", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_ex_data(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_X509_get_ex_data _cffi_d_X509_get_ex_data
#endif

static int _cffi_d_X509_get_ex_new_index(long x0, void * x1, CRYPTO_EX_new * x2, CRYPTO_EX_dup * x3, CRYPTO_EX_free * x4)
{
  return X509_get_ex_new_index(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_ex_new_index(PyObject *self, PyObject *args)
{
  long x0;
  void * x1;
  CRYPTO_EX_new * x2;
  CRYPTO_EX_dup * x3;
  CRYPTO_EX_free * x4;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "X509_get_ex_new_index", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  x0 = _cffi_to_c_int(arg0, long);
  if (x0 == (long)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(92), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2762), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (CRYPTO_EX_new *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(2762), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2763), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (CRYPTO_EX_dup *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(2763), arg3) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2764), arg4, (char **)&x4);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x4 = (CRYPTO_EX_free *)alloca((size_t)datasize);
    memset((void *)x4, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x4, _cffi_type(2764), arg4) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_ex_new_index(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_get_ex_new_index _cffi_d_X509_get_ex_new_index
#endif

static X509_EXTENSION * _cffi_d_X509_get_ext(X509 * x0, int x1)
{
  return X509_get_ext(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_ext(PyObject *self, PyObject *args)
{
  X509 * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_get_ext", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_ext(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_X509_get_ext _cffi_d_X509_get_ext
#endif

static int _cffi_d_X509_get_ext_by_NID(X509 * x0, int x1, int x2)
{
  return X509_get_ext_by_NID(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_ext_by_NID(PyObject *self, PyObject *args)
{
  X509 * x0;
  int x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_get_ext_by_NID", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_ext_by_NID(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_get_ext_by_NID _cffi_d_X509_get_ext_by_NID
#endif

static int _cffi_d_X509_get_ext_count(X509 * x0)
{
  return X509_get_ext_count(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_ext_count(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_ext_count(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_get_ext_count _cffi_d_X509_get_ext_count
#endif

static void * _cffi_d_X509_get_ext_d2i(X509 * x0, int x1, int * x2, int * x3)
{
  return X509_get_ext_d2i(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_ext_d2i(PyObject *self, PyObject *args)
{
  X509 * x0;
  int x1;
  int * x2;
  int * x3;
  Py_ssize_t datasize;
  void * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_get_ext_d2i", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(1509), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1509), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (int *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(1509), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_ext_d2i(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(92));
}
#else
#  define _cffi_f_X509_get_ext_d2i _cffi_d_X509_get_ext_d2i
#endif

static X509_NAME * _cffi_d_X509_get_issuer_name(X509 * x0)
{
  return X509_get_issuer_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_issuer_name(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_issuer_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_X509_get_issuer_name _cffi_d_X509_get_issuer_name
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_get_notAfter(X509 * x0)
{
  return X509_get_notAfter(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_notAfter(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_notAfter(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_get_notAfter _cffi_d_X509_get_notAfter
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_get_notBefore(X509 * x0)
{
  return X509_get_notBefore(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_notBefore(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_notBefore(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_get_notBefore _cffi_d_X509_get_notBefore
#endif

static EVP_PKEY * _cffi_d_X509_get_pubkey(X509 * x0)
{
  return X509_get_pubkey(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_pubkey(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  EVP_PKEY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_pubkey(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_X509_get_pubkey _cffi_d_X509_get_pubkey
#endif

static ASN1_INTEGER * _cffi_d_X509_get_serialNumber(X509 * x0)
{
  return X509_get_serialNumber(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_serialNumber(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  ASN1_INTEGER * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_serialNumber(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(17));
}
#else
#  define _cffi_f_X509_get_serialNumber _cffi_d_X509_get_serialNumber
#endif

static int _cffi_d_X509_get_signature_nid(X509 const * x0)
{
  return X509_get_signature_nid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_signature_nid(PyObject *self, PyObject *arg0)
{
  X509 const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(751), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(751), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_signature_nid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_get_signature_nid _cffi_d_X509_get_signature_nid
#endif

static X509_NAME * _cffi_d_X509_get_subject_name(X509 * x0)
{
  return X509_get_subject_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_subject_name(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  X509_NAME * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_subject_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_X509_get_subject_name _cffi_d_X509_get_subject_name
#endif

static long _cffi_d_X509_get_version(X509 * x0)
{
  return X509_get_version(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_get_version(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_get_version(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long);
}
#else
#  define _cffi_f_X509_get_version _cffi_d_X509_get_version
#endif

static ASN1_OCTET_STRING * _cffi_d_X509_gmtime_adj(ASN1_OCTET_STRING * x0, long x1)
{
  return X509_gmtime_adj(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_gmtime_adj(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  long x1;
  Py_ssize_t datasize;
  ASN1_OCTET_STRING * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_gmtime_adj", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_gmtime_adj(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(13));
}
#else
#  define _cffi_f_X509_gmtime_adj _cffi_d_X509_gmtime_adj
#endif

static X509 * _cffi_d_X509_new(void)
{
  return X509_new();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_new(PyObject *self, PyObject *noarg)
{
  X509 * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_new(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_X509_new _cffi_d_X509_new
#endif

static int _cffi_d_X509_print_ex(BIO * x0, X509 * x1, unsigned long x2, unsigned long x3)
{
  return X509_print_ex(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_print_ex(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509 * x1;
  unsigned long x2;
  unsigned long x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "X509_print_ex", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, unsigned long);
  if (x2 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, unsigned long);
  if (x3 == (unsigned long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_print_ex(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_print_ex _cffi_d_X509_print_ex
#endif

static int _cffi_d_X509_set_ex_data(X509 * x0, int x1, void * x2)
{
  return X509_set_ex_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_ex_data(PyObject *self, PyObject *args)
{
  X509 * x0;
  int x1;
  void * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_set_ex_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(92), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_ex_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_ex_data _cffi_d_X509_set_ex_data
#endif

static int _cffi_d_X509_set_issuer_name(X509 * x0, X509_NAME * x1)
{
  return X509_set_issuer_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_issuer_name(PyObject *self, PyObject *args)
{
  X509 * x0;
  X509_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_issuer_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(847), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_issuer_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_issuer_name _cffi_d_X509_set_issuer_name
#endif

static int _cffi_d_X509_set_notAfter(X509 * x0, ASN1_OCTET_STRING * x1)
{
  return X509_set_notAfter(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_notAfter(PyObject *self, PyObject *args)
{
  X509 * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_notAfter", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_notAfter(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_notAfter _cffi_d_X509_set_notAfter
#endif

static int _cffi_d_X509_set_notBefore(X509 * x0, ASN1_OCTET_STRING * x1)
{
  return X509_set_notBefore(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_notBefore(PyObject *self, PyObject *args)
{
  X509 * x0;
  ASN1_OCTET_STRING * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_notBefore", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(13), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_notBefore(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_notBefore _cffi_d_X509_set_notBefore
#endif

static int _cffi_d_X509_set_pubkey(X509 * x0, EVP_PKEY * x1)
{
  return X509_set_pubkey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_pubkey(PyObject *self, PyObject *args)
{
  X509 * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_pubkey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_pubkey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_pubkey _cffi_d_X509_set_pubkey
#endif

static int _cffi_d_X509_set_serialNumber(X509 * x0, ASN1_INTEGER * x1)
{
  return X509_set_serialNumber(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_serialNumber(PyObject *self, PyObject *args)
{
  X509 * x0;
  ASN1_INTEGER * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_serialNumber", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(17), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_serialNumber(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_serialNumber _cffi_d_X509_set_serialNumber
#endif

static int _cffi_d_X509_set_subject_name(X509 * x0, X509_NAME * x1)
{
  return X509_set_subject_name(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_subject_name(PyObject *self, PyObject *args)
{
  X509 * x0;
  X509_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_subject_name", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(847), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_subject_name(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_subject_name _cffi_d_X509_set_subject_name
#endif

static int _cffi_d_X509_set_version(X509 * x0, long x1)
{
  return X509_set_version(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_set_version(PyObject *self, PyObject *args)
{
  X509 * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "X509_set_version", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_set_version(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_set_version _cffi_d_X509_set_version
#endif

static int _cffi_d_X509_sign(X509 * x0, EVP_PKEY * x1, EVP_MD const * x2)
{
  return X509_sign(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_sign(PyObject *self, PyObject *args)
{
  X509 * x0;
  EVP_PKEY * x1;
  EVP_MD const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "X509_sign", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(226), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_MD const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(226), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_sign(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_sign _cffi_d_X509_sign
#endif

static unsigned long _cffi_d_X509_subject_name_hash(X509 * x0)
{
  return X509_subject_name_hash(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_subject_name_hash(PyObject *self, PyObject *arg0)
{
  X509 * x0;
  Py_ssize_t datasize;
  unsigned long result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_subject_name_hash(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned long);
}
#else
#  define _cffi_f_X509_subject_name_hash _cffi_d_X509_subject_name_hash
#endif

static int _cffi_d_X509_verify_cert(X509_STORE_CTX * x0)
{
  return X509_verify_cert(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_verify_cert(PyObject *self, PyObject *arg0)
{
  X509_STORE_CTX * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(258), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_STORE_CTX *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(258), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_verify_cert(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_X509_verify_cert _cffi_d_X509_verify_cert
#endif

static char const * _cffi_d_X509_verify_cert_error_string(long x0)
{
  return X509_verify_cert_error_string(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_X509_verify_cert_error_string(PyObject *self, PyObject *arg0)
{
  long x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, long);
  if (x0 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = X509_verify_cert_error_string(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(57));
}
#else
#  define _cffi_f_X509_verify_cert_error_string _cffi_d_X509_verify_cert_error_string
#endif

static int _cffi_d__setup_ssl_threads(void)
{
  return _setup_ssl_threads();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f__setup_ssl_threads(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = _setup_ssl_threads(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f__setup_ssl_threads _cffi_d__setup_ssl_threads
#endif

static ASN1_OBJECT * _cffi_d_d2i_ASN1_OBJECT(ASN1_OBJECT * * x0, unsigned char const * * x1, long x2)
{
  return d2i_ASN1_OBJECT(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_ASN1_OBJECT(PyObject *self, PyObject *args)
{
  ASN1_OBJECT * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  ASN1_OBJECT * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_ASN1_OBJECT", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(39), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OBJECT * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(39), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_ASN1_OBJECT(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_d2i_ASN1_OBJECT _cffi_d_d2i_ASN1_OBJECT
#endif

static ASN1_TYPE * _cffi_d_d2i_ASN1_TYPE(ASN1_TYPE * * x0, unsigned char const * * x1, long x2)
{
  return d2i_ASN1_TYPE(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_ASN1_TYPE(PyObject *self, PyObject *args)
{
  ASN1_TYPE * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  ASN1_TYPE * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_ASN1_TYPE", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(100), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_TYPE * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(100), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_ASN1_TYPE(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1056));
}
#else
#  define _cffi_f_d2i_ASN1_TYPE _cffi_d_d2i_ASN1_TYPE
#endif

static DH * _cffi_d_d2i_DHparams(DH * * x0, unsigned char const * * x1, long x2)
{
  return d2i_DHparams(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DHparams(PyObject *self, PyObject *args)
{
  DH * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  DH * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_DHparams", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(285), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DHparams(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_d2i_DHparams _cffi_d_d2i_DHparams
#endif

static DH * _cffi_d_d2i_DHparams_bio(BIO * x0, DH * * x1)
{
  return d2i_DHparams_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DHparams_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * * x1;
  Py_ssize_t datasize;
  DH * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_DHparams_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(285), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DHparams_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(299));
}
#else
#  define _cffi_f_d2i_DHparams_bio _cffi_d_d2i_DHparams_bio
#endif

static DSA * _cffi_d_d2i_DSAPrivateKey(DSA * * x0, unsigned char const * * x1, long x2)
{
  return d2i_DSAPrivateKey(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DSAPrivateKey(PyObject *self, PyObject *args)
{
  DSA * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_DSAPrivateKey", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(319), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DSAPrivateKey(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_d2i_DSAPrivateKey _cffi_d_d2i_DSAPrivateKey
#endif

static DSA * _cffi_d_d2i_DSAPrivateKey_bio(BIO * x0, DSA * * x1)
{
  return d2i_DSAPrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DSAPrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * * x1;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_DSAPrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(319), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DSAPrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_d2i_DSAPrivateKey_bio _cffi_d_d2i_DSAPrivateKey_bio
#endif

static DSA * _cffi_d_d2i_DSAPublicKey(DSA * * x0, unsigned char const * * x1, long x2)
{
  return d2i_DSAPublicKey(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DSAPublicKey(PyObject *self, PyObject *args)
{
  DSA * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_DSAPublicKey", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(319), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DSAPublicKey(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_d2i_DSAPublicKey _cffi_d_d2i_DSAPublicKey
#endif

static DSA * _cffi_d_d2i_DSA_PUBKEY(DSA * * x0, unsigned char const * * x1, long x2)
{
  return d2i_DSA_PUBKEY(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DSA_PUBKEY(PyObject *self, PyObject *args)
{
  DSA * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_DSA_PUBKEY", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(319), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DSA_PUBKEY(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_d2i_DSA_PUBKEY _cffi_d_d2i_DSA_PUBKEY
#endif

static DSA * _cffi_d_d2i_DSA_PUBKEY_bio(BIO * x0, DSA * * x1)
{
  return d2i_DSA_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_DSA_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * * x1;
  Py_ssize_t datasize;
  DSA * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_DSA_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(319), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(319), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_DSA_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(333));
}
#else
#  define _cffi_f_d2i_DSA_PUBKEY_bio _cffi_d_d2i_DSA_PUBKEY_bio
#endif

static ECDSA_SIG * _cffi_d_d2i_ECDSA_SIG(ECDSA_SIG * * x0, unsigned char const * * x1, long x2)
{
  return d2i_ECDSA_SIG(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_ECDSA_SIG(PyObject *self, PyObject *args)
{
  ECDSA_SIG * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  ECDSA_SIG * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_ECDSA_SIG", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(344), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ECDSA_SIG * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(344), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_ECDSA_SIG(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(3256));
}
#else
#  define _cffi_f_d2i_ECDSA_SIG _cffi_d_d2i_ECDSA_SIG
#endif

static EC_KEY * _cffi_d_d2i_ECPrivateKey(EC_KEY * * x0, unsigned char const * * x1, long x2)
{
  return d2i_ECPrivateKey(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_ECPrivateKey(PyObject *self, PyObject *args)
{
  EC_KEY * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  EC_KEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_ECPrivateKey", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(379), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(379), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_ECPrivateKey(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_d2i_ECPrivateKey _cffi_d_d2i_ECPrivateKey
#endif

static EC_KEY * _cffi_d_d2i_ECPrivateKey_bio(BIO * x0, EC_KEY * * x1)
{
  return d2i_ECPrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_ECPrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EC_KEY * * x1;
  Py_ssize_t datasize;
  EC_KEY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_ECPrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(379), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(379), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_ECPrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_d2i_ECPrivateKey_bio _cffi_d_d2i_ECPrivateKey_bio
#endif

static EC_KEY * _cffi_d_d2i_EC_PUBKEY(EC_KEY * * x0, unsigned char const * * x1, long x2)
{
  return d2i_EC_PUBKEY(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_EC_PUBKEY(PyObject *self, PyObject *args)
{
  EC_KEY * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  EC_KEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_EC_PUBKEY", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(379), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(379), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_EC_PUBKEY(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_d2i_EC_PUBKEY _cffi_d_d2i_EC_PUBKEY
#endif

static EC_KEY * _cffi_d_d2i_EC_PUBKEY_bio(BIO * x0, EC_KEY * * x1)
{
  return d2i_EC_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_EC_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EC_KEY * * x1;
  Py_ssize_t datasize;
  EC_KEY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_EC_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(379), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(379), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_EC_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_d2i_EC_PUBKEY_bio _cffi_d_d2i_EC_PUBKEY_bio
#endif

static GENERAL_NAMES * _cffi_d_d2i_GENERAL_NAMES(GENERAL_NAMES * * x0, unsigned char const * * x1, long x2)
{
  return d2i_GENERAL_NAMES(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_GENERAL_NAMES(PyObject *self, PyObject *args)
{
  GENERAL_NAMES * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  GENERAL_NAMES * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_GENERAL_NAMES", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(524), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(524), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_GENERAL_NAMES(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(518));
}
#else
#  define _cffi_f_d2i_GENERAL_NAMES _cffi_d_d2i_GENERAL_NAMES
#endif

static OCSP_REQUEST * _cffi_d_d2i_OCSP_REQUEST_bio(BIO * x0, OCSP_REQUEST * * x1)
{
  return d2i_OCSP_REQUEST_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_OCSP_REQUEST_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  OCSP_REQUEST * * x1;
  Py_ssize_t datasize;
  OCSP_REQUEST * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_OCSP_REQUEST_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(562), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (OCSP_REQUEST * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(562), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_OCSP_REQUEST_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(557));
}
#else
#  define _cffi_f_d2i_OCSP_REQUEST_bio _cffi_d_d2i_OCSP_REQUEST_bio
#endif

static OCSP_RESPONSE * _cffi_d_d2i_OCSP_RESPONSE_bio(BIO * x0, OCSP_RESPONSE * * x1)
{
  return d2i_OCSP_RESPONSE_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_OCSP_RESPONSE_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  OCSP_RESPONSE * * x1;
  Py_ssize_t datasize;
  OCSP_RESPONSE * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_OCSP_RESPONSE_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(568), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (OCSP_RESPONSE * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(568), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_OCSP_RESPONSE_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(549));
}
#else
#  define _cffi_f_d2i_OCSP_RESPONSE_bio _cffi_d_d2i_OCSP_RESPONSE_bio
#endif

static PKCS12 * _cffi_d_d2i_PKCS12_bio(BIO * x0, PKCS12 * * x1)
{
  return d2i_PKCS12_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_PKCS12_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS12 * * x1;
  Py_ssize_t datasize;
  PKCS12 * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_PKCS12_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(591), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS12 * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(591), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_PKCS12_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1240));
}
#else
#  define _cffi_f_d2i_PKCS12_bio _cffi_d_d2i_PKCS12_bio
#endif

static PKCS7 * _cffi_d_d2i_PKCS7_bio(BIO * x0, PKCS7 * * x1)
{
  return d2i_PKCS7_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_PKCS7_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS7 * * x1;
  Py_ssize_t datasize;
  PKCS7 * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_PKCS7_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(611), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS7 * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(611), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_PKCS7_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(182));
}
#else
#  define _cffi_f_d2i_PKCS7_bio _cffi_d_d2i_PKCS7_bio
#endif

static EVP_PKEY * _cffi_d_d2i_PKCS8PrivateKey_bio(BIO * x0, EVP_PKEY * * x1, int(* x2)(char *, int, int, void *), void * x3)
{
  return d2i_PKCS8PrivateKey_bio(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_PKCS8PrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * * x1;
  int(* x2)(char *, int, int, void *);
  void * x3;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "d2i_PKCS8PrivateKey_bio", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(478), arg1) < 0)
      return NULL;
  }

  x2 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg2, _cffi_type(290));
  if (x2 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(92), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_PKCS8PrivateKey_bio(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_d2i_PKCS8PrivateKey_bio _cffi_d_d2i_PKCS8PrivateKey_bio
#endif

static PKCS8_PRIV_KEY_INFO * _cffi_d_d2i_PKCS8_PRIV_KEY_INFO_bio(BIO * x0, PKCS8_PRIV_KEY_INFO * * x1)
{
  return d2i_PKCS8_PRIV_KEY_INFO_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_PKCS8_PRIV_KEY_INFO_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS8_PRIV_KEY_INFO * * x1;
  Py_ssize_t datasize;
  PKCS8_PRIV_KEY_INFO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_PKCS8_PRIV_KEY_INFO_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(634), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS8_PRIV_KEY_INFO * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(634), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_PKCS8_PRIV_KEY_INFO_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(496));
}
#else
#  define _cffi_f_d2i_PKCS8_PRIV_KEY_INFO_bio _cffi_d_d2i_PKCS8_PRIV_KEY_INFO_bio
#endif

static EVP_PKEY * _cffi_d_d2i_PUBKEY_bio(BIO * x0, EVP_PKEY * * x1)
{
  return d2i_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * * x1;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(478), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_d2i_PUBKEY_bio _cffi_d_d2i_PUBKEY_bio
#endif

static EVP_PKEY * _cffi_d_d2i_PrivateKey_bio(BIO * x0, EVP_PKEY * * x1)
{
  return d2i_PrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_PrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * * x1;
  Py_ssize_t datasize;
  EVP_PKEY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_PrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(478), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(478), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_PrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(217));
}
#else
#  define _cffi_f_d2i_PrivateKey_bio _cffi_d_d2i_PrivateKey_bio
#endif

static RSA * _cffi_d_d2i_RSAPrivateKey(RSA * * x0, unsigned char const * * x1, long x2)
{
  return d2i_RSAPrivateKey(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_RSAPrivateKey(PyObject *self, PyObject *args)
{
  RSA * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_RSAPrivateKey", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(655), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_RSAPrivateKey(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_d2i_RSAPrivateKey _cffi_d_d2i_RSAPrivateKey
#endif

static RSA * _cffi_d_d2i_RSAPrivateKey_bio(BIO * x0, RSA * * x1)
{
  return d2i_RSAPrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_RSAPrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * * x1;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_RSAPrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(655), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_RSAPrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_d2i_RSAPrivateKey_bio _cffi_d_d2i_RSAPrivateKey_bio
#endif

static RSA * _cffi_d_d2i_RSAPublicKey(RSA * * x0, unsigned char const * * x1, long x2)
{
  return d2i_RSAPublicKey(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_RSAPublicKey(PyObject *self, PyObject *args)
{
  RSA * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_RSAPublicKey", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(655), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_RSAPublicKey(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_d2i_RSAPublicKey _cffi_d_d2i_RSAPublicKey
#endif

static RSA * _cffi_d_d2i_RSAPublicKey_bio(BIO * x0, RSA * * x1)
{
  return d2i_RSAPublicKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_RSAPublicKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * * x1;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_RSAPublicKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(655), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_RSAPublicKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_d2i_RSAPublicKey_bio _cffi_d_d2i_RSAPublicKey_bio
#endif

static RSA * _cffi_d_d2i_RSA_PUBKEY(RSA * * x0, unsigned char const * * x1, long x2)
{
  return d2i_RSA_PUBKEY(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_RSA_PUBKEY(PyObject *self, PyObject *args)
{
  RSA * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "d2i_RSA_PUBKEY", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(655), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_RSA_PUBKEY(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_d2i_RSA_PUBKEY _cffi_d_d2i_RSA_PUBKEY
#endif

static RSA * _cffi_d_d2i_RSA_PUBKEY_bio(BIO * x0, RSA * * x1)
{
  return d2i_RSA_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_RSA_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * * x1;
  Py_ssize_t datasize;
  RSA * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_RSA_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(655), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(655), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_RSA_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(672));
}
#else
#  define _cffi_f_d2i_RSA_PUBKEY_bio _cffi_d_d2i_RSA_PUBKEY_bio
#endif

static X509_CRL * _cffi_d_d2i_X509_CRL_bio(BIO * x0, X509_CRL * * x1)
{
  return d2i_X509_CRL_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_X509_CRL_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_CRL * * x1;
  Py_ssize_t datasize;
  X509_CRL * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_X509_CRL_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(763), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(763), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_X509_CRL_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(80));
}
#else
#  define _cffi_f_d2i_X509_CRL_bio _cffi_d_d2i_X509_CRL_bio
#endif

static X509_REQ * _cffi_d_d2i_X509_REQ_bio(BIO * x0, X509_REQ * * x1)
{
  return d2i_X509_REQ_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_X509_REQ_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_REQ * * x1;
  Py_ssize_t datasize;
  X509_REQ * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_X509_REQ_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(875), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REQ * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(875), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_X509_REQ_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(502));
}
#else
#  define _cffi_f_d2i_X509_REQ_bio _cffi_d_d2i_X509_REQ_bio
#endif

static X509 * _cffi_d_d2i_X509_bio(BIO * x0, X509 * * x1)
{
  return d2i_X509_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_d2i_X509_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509 * * x1;
  Py_ssize_t datasize;
  X509 * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "d2i_X509_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(718), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(718), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = d2i_X509_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_d2i_X509_bio _cffi_d_d2i_X509_bio
#endif

static int _cffi_d_i2a_ASN1_INTEGER(BIO * x0, ASN1_INTEGER * x1)
{
  return i2a_ASN1_INTEGER(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2a_ASN1_INTEGER(PyObject *self, PyObject *args)
{
  BIO * x0;
  ASN1_INTEGER * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2a_ASN1_INTEGER", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(17), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2a_ASN1_INTEGER(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2a_ASN1_INTEGER _cffi_d_i2a_ASN1_INTEGER
#endif

static int _cffi_d_i2d_ASN1_BIT_STRING(ASN1_OCTET_STRING * x0, unsigned char * * x1)
{
  return i2d_ASN1_BIT_STRING(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_BIT_STRING(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_BIT_STRING", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_BIT_STRING(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_BIT_STRING _cffi_d_i2d_ASN1_BIT_STRING
#endif

static int _cffi_d_i2d_ASN1_ENUMERATED(ASN1_ENUMERATED * x0, unsigned char * * x1)
{
  return i2d_ASN1_ENUMERATED(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_ENUMERATED(PyObject *self, PyObject *args)
{
  ASN1_ENUMERATED * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_ENUMERATED", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(980), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_ENUMERATED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(980), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_ENUMERATED(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_ENUMERATED _cffi_d_i2d_ASN1_ENUMERATED
#endif

static int _cffi_d_i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME * x0, unsigned char * * x1)
{
  return i2d_ASN1_GENERALIZEDTIME(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_GENERALIZEDTIME(PyObject *self, PyObject *args)
{
  ASN1_GENERALIZEDTIME * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_GENERALIZEDTIME", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_GENERALIZEDTIME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(9), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_GENERALIZEDTIME(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_GENERALIZEDTIME _cffi_d_i2d_ASN1_GENERALIZEDTIME
#endif

static int _cffi_d_i2d_ASN1_INTEGER(ASN1_INTEGER * x0, unsigned char * * x1)
{
  return i2d_ASN1_INTEGER(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_INTEGER(PyObject *self, PyObject *args)
{
  ASN1_INTEGER * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_INTEGER", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(17), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_INTEGER(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_INTEGER _cffi_d_i2d_ASN1_INTEGER
#endif

static int _cffi_d_i2d_ASN1_OBJECT(ASN1_OBJECT * x0, unsigned char * * x1)
{
  return i2d_ASN1_OBJECT(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_OBJECT(PyObject *self, PyObject *args)
{
  ASN1_OBJECT * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_OBJECT", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(811), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_OBJECT(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_OBJECT _cffi_d_i2d_ASN1_OBJECT
#endif

static int _cffi_d_i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING * x0, unsigned char * * x1)
{
  return i2d_ASN1_OCTET_STRING(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_OCTET_STRING(PyObject *self, PyObject *args)
{
  ASN1_OCTET_STRING * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_OCTET_STRING", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_OCTET_STRING *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_OCTET_STRING(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_OCTET_STRING _cffi_d_i2d_ASN1_OCTET_STRING
#endif

static int _cffi_d_i2d_ASN1_TYPE(ASN1_TYPE * x0, unsigned char * * x1)
{
  return i2d_ASN1_TYPE(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ASN1_TYPE(PyObject *self, PyObject *args)
{
  ASN1_TYPE * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ASN1_TYPE", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1056), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ASN1_TYPE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1056), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ASN1_TYPE(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ASN1_TYPE _cffi_d_i2d_ASN1_TYPE
#endif

static int _cffi_d_i2d_CMS_bio_stream(BIO * x0, CMS_ContentInfo * x1, BIO * x2, int x3)
{
  return i2d_CMS_bio_stream(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_CMS_bio_stream(PyObject *self, PyObject *args)
{
  BIO * x0;
  CMS_ContentInfo * x1;
  BIO * x2;
  int x3;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "i2d_CMS_bio_stream", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (CMS_ContentInfo *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(168), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (BIO *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(160), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_CMS_bio_stream(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_CMS_bio_stream _cffi_d_i2d_CMS_bio_stream
#endif

static int _cffi_d_i2d_DHparams(DH const * x0, unsigned char * * x1)
{
  return i2d_DHparams(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DHparams(PyObject *self, PyObject *args)
{
  DH const * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DHparams", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1167), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DH const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1167), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DHparams(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DHparams _cffi_d_i2d_DHparams
#endif

static int _cffi_d_i2d_DHparams_bio(BIO * x0, DH * x1)
{
  return i2d_DHparams_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DHparams_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DH * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DHparams_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(299), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DH *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(299), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DHparams_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DHparams_bio _cffi_d_i2d_DHparams_bio
#endif

static int _cffi_d_i2d_DSAPrivateKey(DSA * x0, unsigned char * * x1)
{
  return i2d_DSAPrivateKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DSAPrivateKey(PyObject *self, PyObject *args)
{
  DSA * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DSAPrivateKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DSAPrivateKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DSAPrivateKey _cffi_d_i2d_DSAPrivateKey
#endif

static int _cffi_d_i2d_DSAPrivateKey_bio(BIO * x0, DSA * x1)
{
  return i2d_DSAPrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DSAPrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DSAPrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(333), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DSAPrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DSAPrivateKey_bio _cffi_d_i2d_DSAPrivateKey_bio
#endif

static int _cffi_d_i2d_DSAPublicKey(DSA * x0, unsigned char * * x1)
{
  return i2d_DSAPublicKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DSAPublicKey(PyObject *self, PyObject *args)
{
  DSA * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DSAPublicKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DSAPublicKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DSAPublicKey _cffi_d_i2d_DSAPublicKey
#endif

static int _cffi_d_i2d_DSA_PUBKEY(DSA * x0, unsigned char * * x1)
{
  return i2d_DSA_PUBKEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DSA_PUBKEY(PyObject *self, PyObject *args)
{
  DSA * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DSA_PUBKEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (DSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(333), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DSA_PUBKEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DSA_PUBKEY _cffi_d_i2d_DSA_PUBKEY
#endif

static int _cffi_d_i2d_DSA_PUBKEY_bio(BIO * x0, DSA * x1)
{
  return i2d_DSA_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_DSA_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  DSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_DSA_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(333), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(333), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_DSA_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_DSA_PUBKEY_bio _cffi_d_i2d_DSA_PUBKEY_bio
#endif

static int _cffi_d_i2d_ECDSA_SIG(ECDSA_SIG const * x0, unsigned char * * x1)
{
  return i2d_ECDSA_SIG(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ECDSA_SIG(PyObject *self, PyObject *args)
{
  ECDSA_SIG const * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ECDSA_SIG", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1550), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (ECDSA_SIG const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1550), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ECDSA_SIG(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ECDSA_SIG _cffi_d_i2d_ECDSA_SIG
#endif

static int _cffi_d_i2d_ECPrivateKey(EC_KEY * x0, unsigned char * * x1)
{
  return i2d_ECPrivateKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ECPrivateKey(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ECPrivateKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ECPrivateKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ECPrivateKey _cffi_d_i2d_ECPrivateKey
#endif

static int _cffi_d_i2d_ECPrivateKey_bio(BIO * x0, EC_KEY * x1)
{
  return i2d_ECPrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_ECPrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EC_KEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_ECPrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_ECPrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_ECPrivateKey_bio _cffi_d_i2d_ECPrivateKey_bio
#endif

static int _cffi_d_i2d_EC_PUBKEY(EC_KEY * x0, unsigned char * * x1)
{
  return i2d_EC_PUBKEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_EC_PUBKEY(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_EC_PUBKEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_EC_PUBKEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_EC_PUBKEY _cffi_d_i2d_EC_PUBKEY
#endif

static int _cffi_d_i2d_EC_PUBKEY_bio(BIO * x0, EC_KEY * x1)
{
  return i2d_EC_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_EC_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EC_KEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_EC_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(353), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_EC_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_EC_PUBKEY_bio _cffi_d_i2d_EC_PUBKEY_bio
#endif

static int _cffi_d_i2d_GENERAL_NAMES(GENERAL_NAMES * x0, unsigned char * * x1)
{
  return i2d_GENERAL_NAMES(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_GENERAL_NAMES(PyObject *self, PyObject *args)
{
  GENERAL_NAMES * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_GENERAL_NAMES", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(518), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(518), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_GENERAL_NAMES(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_GENERAL_NAMES _cffi_d_i2d_GENERAL_NAMES
#endif

static int _cffi_d_i2d_OCSP_REQUEST_bio(BIO * x0, OCSP_REQUEST * x1)
{
  return i2d_OCSP_REQUEST_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_OCSP_REQUEST_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  OCSP_REQUEST * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_OCSP_REQUEST_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(557), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (OCSP_REQUEST *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(557), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_OCSP_REQUEST_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_OCSP_REQUEST_bio _cffi_d_i2d_OCSP_REQUEST_bio
#endif

static int _cffi_d_i2d_OCSP_RESPONSE_bio(BIO * x0, OCSP_RESPONSE * x1)
{
  return i2d_OCSP_RESPONSE_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_OCSP_RESPONSE_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  OCSP_RESPONSE * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_OCSP_RESPONSE_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(549), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (OCSP_RESPONSE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(549), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_OCSP_RESPONSE_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_OCSP_RESPONSE_bio _cffi_d_i2d_OCSP_RESPONSE_bio
#endif

static int _cffi_d_i2d_PKCS12_bio(BIO * x0, PKCS12 * x1)
{
  return i2d_PKCS12_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_PKCS12_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS12 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_PKCS12_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1240), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS12 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1240), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_PKCS12_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_PKCS12_bio _cffi_d_i2d_PKCS12_bio
#endif

static int _cffi_d_i2d_PKCS7_bio(BIO * x0, PKCS7 * x1)
{
  return i2d_PKCS7_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_PKCS7_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  PKCS7 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_PKCS7_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(182), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PKCS7 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(182), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_PKCS7_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_PKCS7_bio _cffi_d_i2d_PKCS7_bio
#endif

static int _cffi_d_i2d_PKCS8PrivateKey_bio(BIO * x0, EVP_PKEY * x1, EVP_CIPHER const * x2, char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return i2d_PKCS8PrivateKey_bio(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_PKCS8PrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  EVP_CIPHER const * x2;
  char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "i2d_PKCS8PrivateKey_bio", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (EVP_CIPHER const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(594), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_PKCS8PrivateKey_bio(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_PKCS8PrivateKey_bio _cffi_d_i2d_PKCS8PrivateKey_bio
#endif

static int _cffi_d_i2d_PKCS8PrivateKey_nid_bio(BIO * x0, EVP_PKEY * x1, int x2, char * x3, int x4, int(* x5)(char *, int, int, void *), void * x6)
{
  return i2d_PKCS8PrivateKey_nid_bio(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_PKCS8PrivateKey_nid_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  int x2;
  char * x3;
  int x4;
  int(* x5)(char *, int, int, void *);
  void * x6;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "i2d_PKCS8PrivateKey_nid_bio", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(594), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(594), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (int(*)(char *, int, int, void *))_cffi_to_c_pointer(arg5, _cffi_type(290));
  if (x5 == (int(*)(char *, int, int, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(92), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(92), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_PKCS8PrivateKey_nid_bio(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_PKCS8PrivateKey_nid_bio _cffi_d_i2d_PKCS8PrivateKey_nid_bio
#endif

static int _cffi_d_i2d_PUBKEY_bio(BIO * x0, EVP_PKEY * x1)
{
  return i2d_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_PUBKEY_bio _cffi_d_i2d_PUBKEY_bio
#endif

static int _cffi_d_i2d_PrivateKey_bio(BIO * x0, EVP_PKEY * x1)
{
  return i2d_PrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_PrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  EVP_PKEY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_PrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(217), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (EVP_PKEY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(217), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_PrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_PrivateKey_bio _cffi_d_i2d_PrivateKey_bio
#endif

static int _cffi_d_i2d_RSAPrivateKey(RSA * x0, unsigned char * * x1)
{
  return i2d_RSAPrivateKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_RSAPrivateKey(PyObject *self, PyObject *args)
{
  RSA * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_RSAPrivateKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_RSAPrivateKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_RSAPrivateKey _cffi_d_i2d_RSAPrivateKey
#endif

static int _cffi_d_i2d_RSAPrivateKey_bio(BIO * x0, RSA * x1)
{
  return i2d_RSAPrivateKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_RSAPrivateKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_RSAPrivateKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(672), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_RSAPrivateKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_RSAPrivateKey_bio _cffi_d_i2d_RSAPrivateKey_bio
#endif

static int _cffi_d_i2d_RSAPublicKey(RSA * x0, unsigned char * * x1)
{
  return i2d_RSAPublicKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_RSAPublicKey(PyObject *self, PyObject *args)
{
  RSA * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_RSAPublicKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_RSAPublicKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_RSAPublicKey _cffi_d_i2d_RSAPublicKey
#endif

static int _cffi_d_i2d_RSAPublicKey_bio(BIO * x0, RSA * x1)
{
  return i2d_RSAPublicKey_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_RSAPublicKey_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_RSAPublicKey_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(672), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_RSAPublicKey_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_RSAPublicKey_bio _cffi_d_i2d_RSAPublicKey_bio
#endif

static int _cffi_d_i2d_RSA_PUBKEY(RSA * x0, unsigned char * * x1)
{
  return i2d_RSA_PUBKEY(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_RSA_PUBKEY(PyObject *self, PyObject *args)
{
  RSA * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_RSA_PUBKEY", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (RSA *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(672), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_RSA_PUBKEY(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_RSA_PUBKEY _cffi_d_i2d_RSA_PUBKEY
#endif

static int _cffi_d_i2d_RSA_PUBKEY_bio(BIO * x0, RSA * x1)
{
  return i2d_RSA_PUBKEY_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_RSA_PUBKEY_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  RSA * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_RSA_PUBKEY_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(672), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (RSA *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(672), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_RSA_PUBKEY_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_RSA_PUBKEY_bio _cffi_d_i2d_RSA_PUBKEY_bio
#endif

static int _cffi_d_i2d_X509(X509 * x0, unsigned char * * x1)
{
  return i2d_X509(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509(PyObject *self, PyObject *args)
{
  X509 * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509 _cffi_d_i2d_X509
#endif

static int _cffi_d_i2d_X509_CINF(X509_CINF * x0, unsigned char * * x1)
{
  return i2d_X509_CINF(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_CINF(PyObject *self, PyObject *args)
{
  X509_CINF * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_CINF", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2365), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CINF *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2365), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_CINF(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_CINF _cffi_d_i2d_X509_CINF
#endif

static int _cffi_d_i2d_X509_CRL_INFO(X509_CRL_INFO * x0, unsigned char * * x1)
{
  return i2d_X509_CRL_INFO(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_CRL_INFO(PyObject *self, PyObject *args)
{
  X509_CRL_INFO * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_CRL_INFO", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2410), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL_INFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2410), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_CRL_INFO(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_CRL_INFO _cffi_d_i2d_X509_CRL_INFO
#endif

static int _cffi_d_i2d_X509_CRL_bio(BIO * x0, X509_CRL * x1)
{
  return i2d_X509_CRL_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_CRL_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_CRL * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_CRL_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_CRL_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_CRL_bio _cffi_d_i2d_X509_CRL_bio
#endif

static int _cffi_d_i2d_X509_NAME(X509_NAME * x0, unsigned char * * x1)
{
  return i2d_X509_NAME(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_NAME(PyObject *self, PyObject *args)
{
  X509_NAME * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_NAME", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(847), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_NAME(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_NAME _cffi_d_i2d_X509_NAME
#endif

static int _cffi_d_i2d_X509_REQ_INFO(X509_REQ_INFO * x0, unsigned char * * x1)
{
  return i2d_X509_REQ_INFO(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_REQ_INFO(PyObject *self, PyObject *args)
{
  X509_REQ_INFO * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_REQ_INFO", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2515), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ_INFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(2515), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_REQ_INFO(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_REQ_INFO _cffi_d_i2d_X509_REQ_INFO
#endif

static int _cffi_d_i2d_X509_REQ_bio(BIO * x0, X509_REQ * x1)
{
  return i2d_X509_REQ_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_REQ_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509_REQ * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_REQ_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(502), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_REQ_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_REQ_bio _cffi_d_i2d_X509_REQ_bio
#endif

static int _cffi_d_i2d_X509_bio(BIO * x0, X509 * x1)
{
  return i2d_X509_bio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_X509_bio(PyObject *self, PyObject *args)
{
  BIO * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_X509_bio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(160), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (BIO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(160), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_X509_bio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_X509_bio _cffi_d_i2d_X509_bio
#endif

static int _cffi_d_i2d_re_X509_CRL_tbs(X509_CRL * x0, unsigned char * * x1)
{
  return i2d_re_X509_CRL_tbs(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_re_X509_CRL_tbs(PyObject *self, PyObject *args)
{
  X509_CRL * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_re_X509_CRL_tbs", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_re_X509_CRL_tbs(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_re_X509_CRL_tbs _cffi_d_i2d_re_X509_CRL_tbs
#endif

static int _cffi_d_i2d_re_X509_REQ_tbs(X509_REQ * x0, unsigned char * * x1)
{
  return i2d_re_X509_REQ_tbs(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_re_X509_REQ_tbs(PyObject *self, PyObject *args)
{
  X509_REQ * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_re_X509_REQ_tbs", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(502), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_REQ *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(502), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_re_X509_REQ_tbs(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_re_X509_REQ_tbs _cffi_d_i2d_re_X509_REQ_tbs
#endif

static int _cffi_d_i2d_re_X509_tbs(X509 * x0, unsigned char * * x1)
{
  return i2d_re_X509_tbs(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2d_re_X509_tbs(PyObject *self, PyObject *args)
{
  X509 * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2d_re_X509_tbs", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(28), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2d_re_X509_tbs(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2d_re_X509_tbs _cffi_d_i2d_re_X509_tbs
#endif

static int _cffi_d_i2o_ECPublicKey(EC_KEY * x0, unsigned char * * x1)
{
  return i2o_ECPublicKey(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_i2o_ECPublicKey(PyObject *self, PyObject *args)
{
  EC_KEY * x0;
  unsigned char * * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "i2o_ECPublicKey", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(353), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(353), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(985), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(985), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = i2o_ECPublicKey(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_i2o_ECPublicKey _cffi_d_i2o_ECPublicKey
#endif

static EC_KEY * _cffi_d_o2i_ECPublicKey(EC_KEY * * x0, unsigned char const * * x1, long x2)
{
  return o2i_ECPublicKey(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_o2i_ECPublicKey(PyObject *self, PyObject *args)
{
  EC_KEY * * x0;
  unsigned char const * * x1;
  long x2;
  Py_ssize_t datasize;
  EC_KEY * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "o2i_ECPublicKey", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(379), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (EC_KEY * *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(379), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (unsigned char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(40), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, long);
  if (x2 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = o2i_ECPublicKey(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(353));
}
#else
#  define _cffi_f_o2i_ECPublicKey _cffi_d_o2i_ECPublicKey
#endif

static void _cffi_d_sk_ACCESS_DESCRIPTION_free(Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0)
{
  sk_ACCESS_DESCRIPTION_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ACCESS_DESCRIPTION_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ACCESS_DESCRIPTION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_ACCESS_DESCRIPTION_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_ACCESS_DESCRIPTION_free _cffi_d_sk_ACCESS_DESCRIPTION_free
#endif

static Cryptography_STACK_OF_ACCESS_DESCRIPTION * _cffi_d_sk_ACCESS_DESCRIPTION_new_null(void)
{
  return sk_ACCESS_DESCRIPTION_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ACCESS_DESCRIPTION_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_ACCESS_DESCRIPTION * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ACCESS_DESCRIPTION_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1));
}
#else
#  define _cffi_f_sk_ACCESS_DESCRIPTION_new_null _cffi_d_sk_ACCESS_DESCRIPTION_new_null
#endif

static int _cffi_d_sk_ACCESS_DESCRIPTION_num(Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0)
{
  return sk_ACCESS_DESCRIPTION_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ACCESS_DESCRIPTION_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ACCESS_DESCRIPTION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ACCESS_DESCRIPTION_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_ACCESS_DESCRIPTION_num _cffi_d_sk_ACCESS_DESCRIPTION_num
#endif

static int _cffi_d_sk_ACCESS_DESCRIPTION_push(Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0, ACCESS_DESCRIPTION * x1)
{
  return sk_ACCESS_DESCRIPTION_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ACCESS_DESCRIPTION_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0;
  ACCESS_DESCRIPTION * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_ACCESS_DESCRIPTION_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ACCESS_DESCRIPTION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1394), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ACCESS_DESCRIPTION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1394), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ACCESS_DESCRIPTION_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_ACCESS_DESCRIPTION_push _cffi_d_sk_ACCESS_DESCRIPTION_push
#endif

static ACCESS_DESCRIPTION * _cffi_d_sk_ACCESS_DESCRIPTION_value(Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0, int x1)
{
  return sk_ACCESS_DESCRIPTION_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ACCESS_DESCRIPTION_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_ACCESS_DESCRIPTION * x0;
  int x1;
  Py_ssize_t datasize;
  ACCESS_DESCRIPTION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_ACCESS_DESCRIPTION_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ACCESS_DESCRIPTION *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ACCESS_DESCRIPTION_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1394));
}
#else
#  define _cffi_f_sk_ACCESS_DESCRIPTION_value _cffi_d_sk_ACCESS_DESCRIPTION_value
#endif

static void _cffi_d_sk_ASN1_INTEGER_free(Cryptography_STACK_OF_ASN1_INTEGER * x0)
{
  sk_ASN1_INTEGER_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_INTEGER_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_ASN1_INTEGER * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(24), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(24), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_ASN1_INTEGER_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_ASN1_INTEGER_free _cffi_d_sk_ASN1_INTEGER_free
#endif

static Cryptography_STACK_OF_ASN1_INTEGER * _cffi_d_sk_ASN1_INTEGER_new_null(void)
{
  return sk_ASN1_INTEGER_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_INTEGER_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_ASN1_INTEGER * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_INTEGER_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(24));
}
#else
#  define _cffi_f_sk_ASN1_INTEGER_new_null _cffi_d_sk_ASN1_INTEGER_new_null
#endif

static int _cffi_d_sk_ASN1_INTEGER_num(Cryptography_STACK_OF_ASN1_INTEGER * x0)
{
  return sk_ASN1_INTEGER_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_INTEGER_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_ASN1_INTEGER * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(24), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(24), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_INTEGER_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_ASN1_INTEGER_num _cffi_d_sk_ASN1_INTEGER_num
#endif

static int _cffi_d_sk_ASN1_INTEGER_push(Cryptography_STACK_OF_ASN1_INTEGER * x0, ASN1_INTEGER * x1)
{
  return sk_ASN1_INTEGER_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_INTEGER_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_ASN1_INTEGER * x0;
  ASN1_INTEGER * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_ASN1_INTEGER_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(24), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(24), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(17), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(17), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_INTEGER_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_ASN1_INTEGER_push _cffi_d_sk_ASN1_INTEGER_push
#endif

static ASN1_INTEGER * _cffi_d_sk_ASN1_INTEGER_value(Cryptography_STACK_OF_ASN1_INTEGER * x0, int x1)
{
  return sk_ASN1_INTEGER_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_INTEGER_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_ASN1_INTEGER * x0;
  int x1;
  Py_ssize_t datasize;
  ASN1_INTEGER * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_ASN1_INTEGER_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(24), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_INTEGER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(24), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_INTEGER_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(17));
}
#else
#  define _cffi_f_sk_ASN1_INTEGER_value _cffi_d_sk_ASN1_INTEGER_value
#endif

static void _cffi_d_sk_ASN1_OBJECT_free(Cryptography_STACK_OF_ASN1_OBJECT * x0)
{
  sk_ASN1_OBJECT_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_OBJECT_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_ASN1_OBJECT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(47), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(47), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_ASN1_OBJECT_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_ASN1_OBJECT_free _cffi_d_sk_ASN1_OBJECT_free
#endif

static Cryptography_STACK_OF_ASN1_OBJECT * _cffi_d_sk_ASN1_OBJECT_new_null(void)
{
  return sk_ASN1_OBJECT_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_OBJECT_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_ASN1_OBJECT * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_OBJECT_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(47));
}
#else
#  define _cffi_f_sk_ASN1_OBJECT_new_null _cffi_d_sk_ASN1_OBJECT_new_null
#endif

static int _cffi_d_sk_ASN1_OBJECT_num(Cryptography_STACK_OF_ASN1_OBJECT * x0)
{
  return sk_ASN1_OBJECT_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_OBJECT_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_ASN1_OBJECT * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(47), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(47), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_OBJECT_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_ASN1_OBJECT_num _cffi_d_sk_ASN1_OBJECT_num
#endif

static int _cffi_d_sk_ASN1_OBJECT_push(Cryptography_STACK_OF_ASN1_OBJECT * x0, ASN1_OBJECT * x1)
{
  return sk_ASN1_OBJECT_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_OBJECT_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_ASN1_OBJECT * x0;
  ASN1_OBJECT * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_ASN1_OBJECT_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(47), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(47), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(811), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(811), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_OBJECT_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_ASN1_OBJECT_push _cffi_d_sk_ASN1_OBJECT_push
#endif

static ASN1_OBJECT * _cffi_d_sk_ASN1_OBJECT_value(Cryptography_STACK_OF_ASN1_OBJECT * x0, int x1)
{
  return sk_ASN1_OBJECT_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_ASN1_OBJECT_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_ASN1_OBJECT * x0;
  int x1;
  Py_ssize_t datasize;
  ASN1_OBJECT * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_ASN1_OBJECT_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(47), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_ASN1_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(47), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_ASN1_OBJECT_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(811));
}
#else
#  define _cffi_f_sk_ASN1_OBJECT_value _cffi_d_sk_ASN1_OBJECT_value
#endif

static void _cffi_d_sk_DIST_POINT_free(Cryptography_STACK_OF_DIST_POINT * x0)
{
  sk_DIST_POINT_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_DIST_POINT_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_DIST_POINT * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(310), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(310), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_DIST_POINT_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_DIST_POINT_free _cffi_d_sk_DIST_POINT_free
#endif

static Cryptography_STACK_OF_DIST_POINT * _cffi_d_sk_DIST_POINT_new_null(void)
{
  return sk_DIST_POINT_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_DIST_POINT_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_DIST_POINT * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_DIST_POINT_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(310));
}
#else
#  define _cffi_f_sk_DIST_POINT_new_null _cffi_d_sk_DIST_POINT_new_null
#endif

static int _cffi_d_sk_DIST_POINT_num(Cryptography_STACK_OF_DIST_POINT * x0)
{
  return sk_DIST_POINT_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_DIST_POINT_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_DIST_POINT * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(310), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(310), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_DIST_POINT_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_DIST_POINT_num _cffi_d_sk_DIST_POINT_num
#endif

static void _cffi_d_sk_DIST_POINT_pop_free(Cryptography_STACK_OF_DIST_POINT * x0, void(* x1)(DIST_POINT *))
{
  sk_DIST_POINT_pop_free(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_DIST_POINT_pop_free(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_DIST_POINT * x0;
  void(* x1)(DIST_POINT *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_DIST_POINT_pop_free", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(310), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(310), arg0) < 0)
      return NULL;
  }

  x1 = (void(*)(DIST_POINT *))_cffi_to_c_pointer(arg1, _cffi_type(3194));
  if (x1 == (void(*)(DIST_POINT *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_DIST_POINT_pop_free(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_DIST_POINT_pop_free _cffi_d_sk_DIST_POINT_pop_free
#endif

static int _cffi_d_sk_DIST_POINT_push(Cryptography_STACK_OF_DIST_POINT * x0, DIST_POINT * x1)
{
  return sk_DIST_POINT_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_DIST_POINT_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_DIST_POINT * x0;
  DIST_POINT * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_DIST_POINT_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(310), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(310), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1415), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1415), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_DIST_POINT_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_DIST_POINT_push _cffi_d_sk_DIST_POINT_push
#endif

static DIST_POINT * _cffi_d_sk_DIST_POINT_value(Cryptography_STACK_OF_DIST_POINT * x0, int x1)
{
  return sk_DIST_POINT_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_DIST_POINT_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_DIST_POINT * x0;
  int x1;
  Py_ssize_t datasize;
  DIST_POINT * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_DIST_POINT_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(310), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_DIST_POINT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(310), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_DIST_POINT_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1415));
}
#else
#  define _cffi_f_sk_DIST_POINT_value _cffi_d_sk_DIST_POINT_value
#endif

static int _cffi_d_sk_GENERAL_NAME_num(GENERAL_NAMES * x0)
{
  return sk_GENERAL_NAME_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_NAME_num(PyObject *self, PyObject *arg0)
{
  GENERAL_NAMES * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(518), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(518), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_NAME_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_GENERAL_NAME_num _cffi_d_sk_GENERAL_NAME_num
#endif

static void _cffi_d_sk_GENERAL_NAME_pop_free(GENERAL_NAMES * x0, void(* x1)(GENERAL_NAME *))
{
  sk_GENERAL_NAME_pop_free(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_NAME_pop_free(PyObject *self, PyObject *args)
{
  GENERAL_NAMES * x0;
  void(* x1)(GENERAL_NAME *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_GENERAL_NAME_pop_free", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(518), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(518), arg0) < 0)
      return NULL;
  }

  x1 = (void(*)(GENERAL_NAME *))_cffi_to_c_pointer(arg1, _cffi_type(3313));
  if (x1 == (void(*)(GENERAL_NAME *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_GENERAL_NAME_pop_free(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_GENERAL_NAME_pop_free _cffi_d_sk_GENERAL_NAME_pop_free
#endif

static int _cffi_d_sk_GENERAL_NAME_push(GENERAL_NAMES * x0, GENERAL_NAME * x1)
{
  return sk_GENERAL_NAME_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_NAME_push(PyObject *self, PyObject *args)
{
  GENERAL_NAMES * x0;
  GENERAL_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_GENERAL_NAME_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(518), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(518), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1228), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (GENERAL_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1228), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_NAME_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_GENERAL_NAME_push _cffi_d_sk_GENERAL_NAME_push
#endif

static GENERAL_NAME * _cffi_d_sk_GENERAL_NAME_value(GENERAL_NAMES * x0, int x1)
{
  return sk_GENERAL_NAME_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_NAME_value(PyObject *self, PyObject *args)
{
  GENERAL_NAMES * x0;
  int x1;
  Py_ssize_t datasize;
  GENERAL_NAME * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_GENERAL_NAME_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(518), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (GENERAL_NAMES *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(518), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_NAME_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1228));
}
#else
#  define _cffi_f_sk_GENERAL_NAME_value _cffi_d_sk_GENERAL_NAME_value
#endif

static void _cffi_d_sk_GENERAL_SUBTREE_free(Cryptography_STACK_OF_GENERAL_SUBTREE * x0)
{
  sk_GENERAL_SUBTREE_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_SUBTREE_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_GENERAL_SUBTREE * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(531), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_GENERAL_SUBTREE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(531), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_GENERAL_SUBTREE_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_GENERAL_SUBTREE_free _cffi_d_sk_GENERAL_SUBTREE_free
#endif

static Cryptography_STACK_OF_GENERAL_SUBTREE * _cffi_d_sk_GENERAL_SUBTREE_new_null(void)
{
  return sk_GENERAL_SUBTREE_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_SUBTREE_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_GENERAL_SUBTREE * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_SUBTREE_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(531));
}
#else
#  define _cffi_f_sk_GENERAL_SUBTREE_new_null _cffi_d_sk_GENERAL_SUBTREE_new_null
#endif

static int _cffi_d_sk_GENERAL_SUBTREE_num(Cryptography_STACK_OF_GENERAL_SUBTREE * x0)
{
  return sk_GENERAL_SUBTREE_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_SUBTREE_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_GENERAL_SUBTREE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(531), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_GENERAL_SUBTREE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(531), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_SUBTREE_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_GENERAL_SUBTREE_num _cffi_d_sk_GENERAL_SUBTREE_num
#endif

static int _cffi_d_sk_GENERAL_SUBTREE_push(Cryptography_STACK_OF_GENERAL_SUBTREE * x0, GENERAL_SUBTREE * x1)
{
  return sk_GENERAL_SUBTREE_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_SUBTREE_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_GENERAL_SUBTREE * x0;
  GENERAL_SUBTREE * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_GENERAL_SUBTREE_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(531), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_GENERAL_SUBTREE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(531), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1422), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (GENERAL_SUBTREE *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1422), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_SUBTREE_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_GENERAL_SUBTREE_push _cffi_d_sk_GENERAL_SUBTREE_push
#endif

static GENERAL_SUBTREE * _cffi_d_sk_GENERAL_SUBTREE_value(Cryptography_STACK_OF_GENERAL_SUBTREE * x0, int x1)
{
  return sk_GENERAL_SUBTREE_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_GENERAL_SUBTREE_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_GENERAL_SUBTREE * x0;
  int x1;
  Py_ssize_t datasize;
  GENERAL_SUBTREE * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_GENERAL_SUBTREE_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(531), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_GENERAL_SUBTREE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(531), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_GENERAL_SUBTREE_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1422));
}
#else
#  define _cffi_f_sk_GENERAL_SUBTREE_value _cffi_d_sk_GENERAL_SUBTREE_value
#endif

static void _cffi_d_sk_POLICYINFO_free(Cryptography_STACK_OF_POLICYINFO * x0)
{
  sk_POLICYINFO_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYINFO_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_POLICYINFO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(637), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(637), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_POLICYINFO_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_POLICYINFO_free _cffi_d_sk_POLICYINFO_free
#endif

static Cryptography_STACK_OF_POLICYINFO * _cffi_d_sk_POLICYINFO_new_null(void)
{
  return sk_POLICYINFO_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYINFO_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_POLICYINFO * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYINFO_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(637));
}
#else
#  define _cffi_f_sk_POLICYINFO_new_null _cffi_d_sk_POLICYINFO_new_null
#endif

static int _cffi_d_sk_POLICYINFO_num(Cryptography_STACK_OF_POLICYINFO * x0)
{
  return sk_POLICYINFO_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYINFO_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_POLICYINFO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(637), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(637), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYINFO_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_POLICYINFO_num _cffi_d_sk_POLICYINFO_num
#endif

static void _cffi_d_sk_POLICYINFO_pop_free(Cryptography_STACK_OF_POLICYINFO * x0, void(* x1)(POLICYINFO *))
{
  sk_POLICYINFO_pop_free(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYINFO_pop_free(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_POLICYINFO * x0;
  void(* x1)(POLICYINFO *);
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_POLICYINFO_pop_free", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(637), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(637), arg0) < 0)
      return NULL;
  }

  x1 = (void(*)(POLICYINFO *))_cffi_to_c_pointer(arg1, _cffi_type(3204));
  if (x1 == (void(*)(POLICYINFO *))NULL && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_POLICYINFO_pop_free(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_POLICYINFO_pop_free _cffi_d_sk_POLICYINFO_pop_free
#endif

static int _cffi_d_sk_POLICYINFO_push(Cryptography_STACK_OF_POLICYINFO * x0, POLICYINFO * x1)
{
  return sk_POLICYINFO_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYINFO_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_POLICYINFO * x0;
  POLICYINFO * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_POLICYINFO_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(637), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(637), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1429), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1429), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYINFO_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_POLICYINFO_push _cffi_d_sk_POLICYINFO_push
#endif

static POLICYINFO * _cffi_d_sk_POLICYINFO_value(Cryptography_STACK_OF_POLICYINFO * x0, int x1)
{
  return sk_POLICYINFO_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYINFO_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_POLICYINFO * x0;
  int x1;
  Py_ssize_t datasize;
  POLICYINFO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_POLICYINFO_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(637), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(637), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYINFO_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1429));
}
#else
#  define _cffi_f_sk_POLICYINFO_value _cffi_d_sk_POLICYINFO_value
#endif

static void _cffi_d_sk_POLICYQUALINFO_free(Cryptography_STACK_OF_POLICYQUALINFO * x0)
{
  sk_POLICYQUALINFO_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYQUALINFO_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_POLICYQUALINFO * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(643), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYQUALINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(643), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_POLICYQUALINFO_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_POLICYQUALINFO_free _cffi_d_sk_POLICYQUALINFO_free
#endif

static Cryptography_STACK_OF_POLICYQUALINFO * _cffi_d_sk_POLICYQUALINFO_new_null(void)
{
  return sk_POLICYQUALINFO_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYQUALINFO_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_POLICYQUALINFO * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYQUALINFO_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(643));
}
#else
#  define _cffi_f_sk_POLICYQUALINFO_new_null _cffi_d_sk_POLICYQUALINFO_new_null
#endif

static int _cffi_d_sk_POLICYQUALINFO_num(Cryptography_STACK_OF_POLICYQUALINFO * x0)
{
  return sk_POLICYQUALINFO_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYQUALINFO_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_POLICYQUALINFO * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(643), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYQUALINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(643), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYQUALINFO_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_POLICYQUALINFO_num _cffi_d_sk_POLICYQUALINFO_num
#endif

static int _cffi_d_sk_POLICYQUALINFO_push(Cryptography_STACK_OF_POLICYQUALINFO * x0, POLICYQUALINFO * x1)
{
  return sk_POLICYQUALINFO_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYQUALINFO_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_POLICYQUALINFO * x0;
  POLICYQUALINFO * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_POLICYQUALINFO_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(643), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYQUALINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(643), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1436), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (POLICYQUALINFO *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1436), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYQUALINFO_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_POLICYQUALINFO_push _cffi_d_sk_POLICYQUALINFO_push
#endif

static POLICYQUALINFO * _cffi_d_sk_POLICYQUALINFO_value(Cryptography_STACK_OF_POLICYQUALINFO * x0, int x1)
{
  return sk_POLICYQUALINFO_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_POLICYQUALINFO_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_POLICYQUALINFO * x0;
  int x1;
  Py_ssize_t datasize;
  POLICYQUALINFO * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_POLICYQUALINFO_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(643), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_POLICYQUALINFO *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(643), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_POLICYQUALINFO_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(1436));
}
#else
#  define _cffi_f_sk_POLICYQUALINFO_value _cffi_d_sk_POLICYQUALINFO_value
#endif

static int _cffi_d_sk_SCT_num(Cryptography_STACK_OF_SCT const * x0)
{
  return sk_SCT_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_SCT_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_SCT const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(680), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_SCT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(680), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_SCT_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_SCT_num _cffi_d_sk_SCT_num
#endif

static SCT * _cffi_d_sk_SCT_value(Cryptography_STACK_OF_SCT const * x0, int x1)
{
  return sk_SCT_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_SCT_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_SCT const * x0;
  int x1;
  Py_ssize_t datasize;
  SCT * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_SCT_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(680), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_SCT const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(680), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_SCT_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(2149));
}
#else
#  define _cffi_f_sk_SCT_value _cffi_d_sk_SCT_value
#endif

static int _cffi_d_sk_SSL_CIPHER_num(Cryptography_STACK_OF_SSL_CIPHER * x0)
{
  return sk_SSL_CIPHER_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_SSL_CIPHER_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_SSL_CIPHER * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(687), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_SSL_CIPHER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(687), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_SSL_CIPHER_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_SSL_CIPHER_num _cffi_d_sk_SSL_CIPHER_num
#endif

static SSL_CIPHER const * _cffi_d_sk_SSL_CIPHER_value(Cryptography_STACK_OF_SSL_CIPHER * x0, int x1)
{
  return sk_SSL_CIPHER_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_SSL_CIPHER_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_SSL_CIPHER * x0;
  int x1;
  Py_ssize_t datasize;
  SSL_CIPHER const * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_SSL_CIPHER_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(687), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_SSL_CIPHER *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(687), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_SSL_CIPHER_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(925));
}
#else
#  define _cffi_f_sk_SSL_CIPHER_value _cffi_d_sk_SSL_CIPHER_value
#endif

static void _cffi_d_sk_X509_CRL_free(Cryptography_STACK_OF_X509_CRL * x0)
{
  sk_X509_CRL_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_CRL_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_CRL * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(772), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(772), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_X509_CRL_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_X509_CRL_free _cffi_d_sk_X509_CRL_free
#endif

static Cryptography_STACK_OF_X509_CRL * _cffi_d_sk_X509_CRL_new_null(void)
{
  return sk_X509_CRL_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_CRL_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_X509_CRL * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_CRL_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(772));
}
#else
#  define _cffi_f_sk_X509_CRL_new_null _cffi_d_sk_X509_CRL_new_null
#endif

static int _cffi_d_sk_X509_CRL_num(Cryptography_STACK_OF_X509_CRL * x0)
{
  return sk_X509_CRL_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_CRL_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_CRL * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(772), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(772), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_CRL_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_CRL_num _cffi_d_sk_X509_CRL_num
#endif

static int _cffi_d_sk_X509_CRL_push(Cryptography_STACK_OF_X509_CRL * x0, X509_CRL * x1)
{
  return sk_X509_CRL_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_CRL_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_CRL * x0;
  X509_CRL * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_CRL_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(772), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(772), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_CRL *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_CRL_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_CRL_push _cffi_d_sk_X509_CRL_push
#endif

static X509_CRL * _cffi_d_sk_X509_CRL_value(Cryptography_STACK_OF_X509_CRL * x0, int x1)
{
  return sk_X509_CRL_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_CRL_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_CRL * x0;
  int x1;
  Py_ssize_t datasize;
  X509_CRL * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_CRL_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(772), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_CRL *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(772), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_CRL_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(80));
}
#else
#  define _cffi_f_sk_X509_CRL_value _cffi_d_sk_X509_CRL_value
#endif

static X509_EXTENSION * _cffi_d_sk_X509_EXTENSION_delete(X509_EXTENSIONS * x0, int x1)
{
  return sk_X509_EXTENSION_delete(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_delete(PyObject *self, PyObject *args)
{
  X509_EXTENSIONS * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_EXTENSION_delete", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(819), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_EXTENSION_delete(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_sk_X509_EXTENSION_delete _cffi_d_sk_X509_EXTENSION_delete
#endif

static void _cffi_d_sk_X509_EXTENSION_free(X509_EXTENSIONS * x0)
{
  sk_X509_EXTENSION_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_free(PyObject *self, PyObject *arg0)
{
  X509_EXTENSIONS * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(819), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_X509_EXTENSION_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_X509_EXTENSION_free _cffi_d_sk_X509_EXTENSION_free
#endif

static int _cffi_d_sk_X509_EXTENSION_insert(X509_EXTENSIONS * x0, X509_EXTENSION * x1, int x2)
{
  return sk_X509_EXTENSION_insert(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_insert(PyObject *self, PyObject *args)
{
  X509_EXTENSIONS * x0;
  X509_EXTENSION * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "sk_X509_EXTENSION_insert", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(819), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(51), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_EXTENSION_insert(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_EXTENSION_insert _cffi_d_sk_X509_EXTENSION_insert
#endif

static X509_EXTENSIONS * _cffi_d_sk_X509_EXTENSION_new_null(void)
{
  return sk_X509_EXTENSION_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_new_null(PyObject *self, PyObject *noarg)
{
  X509_EXTENSIONS * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_EXTENSION_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(819));
}
#else
#  define _cffi_f_sk_X509_EXTENSION_new_null _cffi_d_sk_X509_EXTENSION_new_null
#endif

static int _cffi_d_sk_X509_EXTENSION_num(X509_EXTENSIONS * x0)
{
  return sk_X509_EXTENSION_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_num(PyObject *self, PyObject *arg0)
{
  X509_EXTENSIONS * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(819), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_EXTENSION_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_EXTENSION_num _cffi_d_sk_X509_EXTENSION_num
#endif

static int _cffi_d_sk_X509_EXTENSION_push(X509_EXTENSIONS * x0, X509_EXTENSION * x1)
{
  return sk_X509_EXTENSION_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_push(PyObject *self, PyObject *args)
{
  X509_EXTENSIONS * x0;
  X509_EXTENSION * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_EXTENSION_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(819), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(51), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_EXTENSION *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(51), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_EXTENSION_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_EXTENSION_push _cffi_d_sk_X509_EXTENSION_push
#endif

static X509_EXTENSION * _cffi_d_sk_X509_EXTENSION_value(X509_EXTENSIONS * x0, int x1)
{
  return sk_X509_EXTENSION_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_EXTENSION_value(PyObject *self, PyObject *args)
{
  X509_EXTENSIONS * x0;
  int x1;
  Py_ssize_t datasize;
  X509_EXTENSION * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_EXTENSION_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(819), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (X509_EXTENSIONS *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(819), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_EXTENSION_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(51));
}
#else
#  define _cffi_f_sk_X509_EXTENSION_value _cffi_d_sk_X509_EXTENSION_value
#endif

static Cryptography_STACK_OF_X509_NAME_ENTRY * _cffi_d_sk_X509_NAME_ENTRY_dup(Cryptography_STACK_OF_X509_NAME_ENTRY * x0)
{
  return sk_X509_NAME_ENTRY_dup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_ENTRY_dup(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_NAME_ENTRY * x0;
  Py_ssize_t datasize;
  Cryptography_STACK_OF_X509_NAME_ENTRY * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(273), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(273), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_ENTRY_dup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(273));
}
#else
#  define _cffi_f_sk_X509_NAME_ENTRY_dup _cffi_d_sk_X509_NAME_ENTRY_dup
#endif

static Cryptography_STACK_OF_X509_NAME_ENTRY * _cffi_d_sk_X509_NAME_ENTRY_new_null(void)
{
  return sk_X509_NAME_ENTRY_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_ENTRY_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_X509_NAME_ENTRY * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_ENTRY_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(273));
}
#else
#  define _cffi_f_sk_X509_NAME_ENTRY_new_null _cffi_d_sk_X509_NAME_ENTRY_new_null
#endif

static int _cffi_d_sk_X509_NAME_ENTRY_num(Cryptography_STACK_OF_X509_NAME_ENTRY * x0)
{
  return sk_X509_NAME_ENTRY_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_ENTRY_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_NAME_ENTRY * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(273), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(273), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_ENTRY_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_NAME_ENTRY_num _cffi_d_sk_X509_NAME_ENTRY_num
#endif

static int _cffi_d_sk_X509_NAME_ENTRY_push(Cryptography_STACK_OF_X509_NAME_ENTRY * x0, X509_NAME_ENTRY * x1)
{
  return sk_X509_NAME_ENTRY_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_ENTRY_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_NAME_ENTRY * x0;
  X509_NAME_ENTRY * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_NAME_ENTRY_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(273), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(273), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(54), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(54), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_ENTRY_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_NAME_ENTRY_push _cffi_d_sk_X509_NAME_ENTRY_push
#endif

static X509_NAME_ENTRY * _cffi_d_sk_X509_NAME_ENTRY_value(Cryptography_STACK_OF_X509_NAME_ENTRY * x0, int x1)
{
  return sk_X509_NAME_ENTRY_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_ENTRY_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_NAME_ENTRY * x0;
  int x1;
  Py_ssize_t datasize;
  X509_NAME_ENTRY * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_NAME_ENTRY_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(273), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME_ENTRY *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(273), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_ENTRY_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(54));
}
#else
#  define _cffi_f_sk_X509_NAME_ENTRY_value _cffi_d_sk_X509_NAME_ENTRY_value
#endif

static void _cffi_d_sk_X509_NAME_free(Cryptography_STACK_OF_X509_NAME * x0)
{
  sk_X509_NAME_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_NAME * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(837), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(837), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_X509_NAME_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_X509_NAME_free _cffi_d_sk_X509_NAME_free
#endif

static Cryptography_STACK_OF_X509_NAME * _cffi_d_sk_X509_NAME_new_null(void)
{
  return sk_X509_NAME_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_X509_NAME * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(837));
}
#else
#  define _cffi_f_sk_X509_NAME_new_null _cffi_d_sk_X509_NAME_new_null
#endif

static int _cffi_d_sk_X509_NAME_num(Cryptography_STACK_OF_X509_NAME * x0)
{
  return sk_X509_NAME_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_NAME * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(837), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(837), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_NAME_num _cffi_d_sk_X509_NAME_num
#endif

static int _cffi_d_sk_X509_NAME_push(Cryptography_STACK_OF_X509_NAME * x0, X509_NAME * x1)
{
  return sk_X509_NAME_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_NAME * x0;
  X509_NAME * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_NAME_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(837), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(837), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(847), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509_NAME *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(847), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_NAME_push _cffi_d_sk_X509_NAME_push
#endif

static X509_NAME * _cffi_d_sk_X509_NAME_value(Cryptography_STACK_OF_X509_NAME * x0, int x1)
{
  return sk_X509_NAME_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_NAME_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_NAME * x0;
  int x1;
  Py_ssize_t datasize;
  X509_NAME * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_NAME_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(837), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_NAME *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(837), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_NAME_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(847));
}
#else
#  define _cffi_f_sk_X509_NAME_value _cffi_d_sk_X509_NAME_value
#endif

static int _cffi_d_sk_X509_OBJECT_num(Cryptography_STACK_OF_X509_OBJECT * x0)
{
  return sk_X509_OBJECT_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_OBJECT_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_OBJECT * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(870), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(870), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_OBJECT_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_OBJECT_num _cffi_d_sk_X509_OBJECT_num
#endif

static X509_OBJECT * _cffi_d_sk_X509_OBJECT_value(Cryptography_STACK_OF_X509_OBJECT * x0, int x1)
{
  return sk_X509_OBJECT_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_OBJECT_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_OBJECT * x0;
  int x1;
  Py_ssize_t datasize;
  X509_OBJECT * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_OBJECT_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(870), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_OBJECT *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(870), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_OBJECT_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(737));
}
#else
#  define _cffi_f_sk_X509_OBJECT_value _cffi_d_sk_X509_OBJECT_value
#endif

static int _cffi_d_sk_X509_REVOKED_num(Cryptography_STACK_OF_X509_REVOKED * x0)
{
  return sk_X509_REVOKED_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_REVOKED_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509_REVOKED * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(886), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(886), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_REVOKED_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_REVOKED_num _cffi_d_sk_X509_REVOKED_num
#endif

static X509_REVOKED * _cffi_d_sk_X509_REVOKED_value(Cryptography_STACK_OF_X509_REVOKED * x0, int x1)
{
  return sk_X509_REVOKED_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_REVOKED_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509_REVOKED * x0;
  int x1;
  Py_ssize_t datasize;
  X509_REVOKED * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_REVOKED_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(886), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509_REVOKED *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(886), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_REVOKED_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(823));
}
#else
#  define _cffi_f_sk_X509_REVOKED_value _cffi_d_sk_X509_REVOKED_value
#endif

static void _cffi_d_sk_X509_free(Cryptography_STACK_OF_X509 * x0)
{
  sk_X509_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_free(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509 * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { sk_X509_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_sk_X509_free _cffi_d_sk_X509_free
#endif

static Cryptography_STACK_OF_X509 * _cffi_d_sk_X509_new_null(void)
{
  return sk_X509_new_null();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_new_null(PyObject *self, PyObject *noarg)
{
  Cryptography_STACK_OF_X509 * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_new_null(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(210));
}
#else
#  define _cffi_f_sk_X509_new_null _cffi_d_sk_X509_new_null
#endif

static int _cffi_d_sk_X509_num(Cryptography_STACK_OF_X509 * x0)
{
  return sk_X509_num(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_num(PyObject *self, PyObject *arg0)
{
  Cryptography_STACK_OF_X509 * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_num(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_num _cffi_d_sk_X509_num
#endif

static int _cffi_d_sk_X509_push(Cryptography_STACK_OF_X509 * x0, X509 * x1)
{
  return sk_X509_push(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_push(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509 * x0;
  X509 * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_push", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(28), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (X509 *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(28), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_push(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_sk_X509_push _cffi_d_sk_X509_push
#endif

static X509 * _cffi_d_sk_X509_value(Cryptography_STACK_OF_X509 * x0, int x1)
{
  return sk_X509_value(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_sk_X509_value(PyObject *self, PyObject *args)
{
  Cryptography_STACK_OF_X509 * x0;
  int x1;
  Py_ssize_t datasize;
  X509 * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "sk_X509_value", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Cryptography_STACK_OF_X509 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = sk_X509_value(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(28));
}
#else
#  define _cffi_f_sk_X509_value _cffi_d_sk_X509_value
#endif

_CFFI_UNUSED_FN
static void _cffi_checkfld__ERR_STRING_DATA(ERR_STRING_DATA *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->error) | 0);  /* check that 'ERR_STRING_DATA.error' is an integer */
  { char const * *tmp = &p->string; (void)tmp; }
}
struct _cffi_align__ERR_STRING_DATA { char x; ERR_STRING_DATA y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__AES_KEY(AES_KEY *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
}
struct _cffi_align__AES_KEY { char x; AES_KEY y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__ASN1_OCTET_STRING(ASN1_OCTET_STRING *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->length) | 0);  /* check that 'ASN1_OCTET_STRING.length' is an integer */
  (void)((p->type) | 0);  /* check that 'ASN1_OCTET_STRING.type' is an integer */
  { unsigned char * *tmp = &p->data; (void)tmp; }
  (void)((p->flags) | 0);  /* check that 'ASN1_OCTET_STRING.flags' is an integer */
}
struct _cffi_align__ASN1_OCTET_STRING { char x; ASN1_OCTET_STRING y; };

static const struct _cffi_global_s _cffi_globals[] = {
  { "ACCESS_DESCRIPTION_free", (void *)_cffi_f_ACCESS_DESCRIPTION_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3128), (void *)_cffi_d_ACCESS_DESCRIPTION_free },
  { "ACCESS_DESCRIPTION_new", (void *)_cffi_f_ACCESS_DESCRIPTION_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 4), (void *)_cffi_d_ACCESS_DESCRIPTION_new },
  { "AES_set_decrypt_key", (void *)_cffi_f_AES_set_decrypt_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2804), (void *)_cffi_d_AES_set_decrypt_key },
  { "AES_set_encrypt_key", (void *)_cffi_f_AES_set_encrypt_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2804), (void *)_cffi_d_AES_set_encrypt_key },
  { "AES_unwrap_key", (void *)_cffi_f_AES_unwrap_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 972), (void *)_cffi_d_AES_unwrap_key },
  { "AES_wrap_key", (void *)_cffi_f_AES_wrap_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 972), (void *)_cffi_d_AES_wrap_key },
  { "ASN1_BIT_STRING_free", (void *)_cffi_f_ASN1_BIT_STRING_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3148), (void *)_cffi_d_ASN1_BIT_STRING_free },
  { "ASN1_BIT_STRING_get_bit", (void *)_cffi_f_ASN1_BIT_STRING_get_bit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1032), (void *)_cffi_d_ASN1_BIT_STRING_get_bit },
  { "ASN1_BIT_STRING_new", (void *)_cffi_f_ASN1_BIT_STRING_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 94), (void *)_cffi_d_ASN1_BIT_STRING_new },
  { "ASN1_BIT_STRING_set_bit", (void *)_cffi_f_ASN1_BIT_STRING_set_bit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1036), (void *)_cffi_d_ASN1_BIT_STRING_set_bit },
  { "ASN1_ENUMERATED_free", (void *)_cffi_f_ASN1_ENUMERATED_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3131), (void *)_cffi_d_ASN1_ENUMERATED_free },
  { "ASN1_ENUMERATED_get", (void *)_cffi_f_ASN1_ENUMERATED_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2841), (void *)_cffi_d_ASN1_ENUMERATED_get },
  { "ASN1_ENUMERATED_new", (void *)_cffi_f_ASN1_ENUMERATED_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 6), (void *)_cffi_d_ASN1_ENUMERATED_new },
  { "ASN1_ENUMERATED_set", (void *)_cffi_f_ASN1_ENUMERATED_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 979), (void *)_cffi_d_ASN1_ENUMERATED_set },
  { "ASN1_F_ASN1_CHECK_TLEN", (void *)_cffi_const_ASN1_F_ASN1_CHECK_TLEN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_EX_C2I", (void *)_cffi_const_ASN1_F_ASN1_EX_C2I, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_FIND_END", (void *)_cffi_const_ASN1_F_ASN1_FIND_END, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_GENERATE_V3", (void *)_cffi_const_ASN1_F_ASN1_GENERATE_V3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_GET_OBJECT", (void *)_cffi_const_ASN1_F_ASN1_GET_OBJECT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_ITEM_I2D_FP", (void *)_cffi_const_ASN1_F_ASN1_ITEM_I2D_FP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_ITEM_PACK", (void *)_cffi_const_ASN1_F_ASN1_ITEM_PACK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_ITEM_SIGN", (void *)_cffi_const_ASN1_F_ASN1_ITEM_SIGN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_ITEM_UNPACK", (void *)_cffi_const_ASN1_F_ASN1_ITEM_UNPACK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_ITEM_VERIFY", (void *)_cffi_const_ASN1_F_ASN1_ITEM_VERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_MBSTRING_NCOPY", (void *)_cffi_const_ASN1_F_ASN1_MBSTRING_NCOPY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_TEMPLATE_EX_D2I", (void *)_cffi_const_ASN1_F_ASN1_TEMPLATE_EX_D2I, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_TEMPLATE_NEW", (void *)_cffi_const_ASN1_F_ASN1_TEMPLATE_NEW, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_TEMPLATE_NOEXP_D2I", (void *)_cffi_const_ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING", (void *)_cffi_const_ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_TYPE_GET_OCTETSTRING", (void *)_cffi_const_ASN1_F_ASN1_TYPE_GET_OCTETSTRING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_ASN1_VERIFY", (void *)_cffi_const_ASN1_F_ASN1_VERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_B64_READ_ASN1", (void *)_cffi_const_ASN1_F_B64_READ_ASN1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_B64_WRITE_ASN1", (void *)_cffi_const_ASN1_F_B64_WRITE_ASN1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_BITSTR_CB", (void *)_cffi_const_ASN1_F_BITSTR_CB, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_D2I_ASN1_UINTEGER", (void *)_cffi_const_ASN1_F_D2I_ASN1_UINTEGER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_D2I_PRIVATEKEY", (void *)_cffi_const_ASN1_F_D2I_PRIVATEKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_I2D_DSA_PUBKEY", (void *)_cffi_const_ASN1_F_I2D_DSA_PUBKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_LONG_C2I", (void *)_cffi_const_ASN1_F_LONG_C2I, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_OID_MODULE_INIT", (void *)_cffi_const_ASN1_F_OID_MODULE_INIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_PARSE_TAGGING", (void *)_cffi_const_ASN1_F_PARSE_TAGGING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_PKCS5_PBE_SET", (void *)_cffi_const_ASN1_F_PKCS5_PBE_SET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_SMIME_READ_ASN1", (void *)_cffi_const_ASN1_F_SMIME_READ_ASN1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_F_SMIME_TEXT", (void *)_cffi_const_ASN1_F_SMIME_TEXT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_GENERALIZEDTIME_check", (void *)_cffi_f_ASN1_GENERALIZEDTIME_check, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 987), (void *)_cffi_d_ASN1_GENERALIZEDTIME_check },
  { "ASN1_GENERALIZEDTIME_free", (void *)_cffi_f_ASN1_GENERALIZEDTIME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3134), (void *)_cffi_d_ASN1_GENERALIZEDTIME_free },
  { "ASN1_GENERALIZEDTIME_set", (void *)_cffi_f_ASN1_GENERALIZEDTIME_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 8), (void *)_cffi_d_ASN1_GENERALIZEDTIME_set },
  { "ASN1_GENERALIZEDTIME_set_string", (void *)_cffi_f_ASN1_GENERALIZEDTIME_set_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 990), (void *)_cffi_d_ASN1_GENERALIZEDTIME_set_string },
  { "ASN1_IA5STRING_new", (void *)_cffi_f_ASN1_IA5STRING_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 94), (void *)_cffi_d_ASN1_IA5STRING_new },
  { "ASN1_INTEGER_cmp", (void *)_cffi_f_ASN1_INTEGER_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 998), (void *)_cffi_d_ASN1_INTEGER_cmp },
  { "ASN1_INTEGER_dup", (void *)_cffi_f_ASN1_INTEGER_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 16), (void *)_cffi_d_ASN1_INTEGER_dup },
  { "ASN1_INTEGER_free", (void *)_cffi_f_ASN1_INTEGER_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3137), (void *)_cffi_d_ASN1_INTEGER_free },
  { "ASN1_INTEGER_get", (void *)_cffi_f_ASN1_INTEGER_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2844), (void *)_cffi_d_ASN1_INTEGER_get },
  { "ASN1_INTEGER_new", (void *)_cffi_f_ASN1_INTEGER_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 30), (void *)_cffi_d_ASN1_INTEGER_new },
  { "ASN1_INTEGER_set", (void *)_cffi_f_ASN1_INTEGER_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1002), (void *)_cffi_d_ASN1_INTEGER_set },
  { "ASN1_INTEGER_to_BN", (void *)_cffi_f_ASN1_INTEGER_to_BN, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 120), (void *)_cffi_d_ASN1_INTEGER_to_BN },
  { "ASN1_ITEM_ptr", (void *)_cffi_f_ASN1_ITEM_ptr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 35), (void *)_cffi_d_ASN1_ITEM_ptr },
  { "ASN1_OBJECT_free", (void *)_cffi_f_ASN1_OBJECT_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3140), (void *)_cffi_d_ASN1_OBJECT_free },
  { "ASN1_OBJECT_new", (void *)_cffi_f_ASN1_OBJECT_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 63), (void *)_cffi_d_ASN1_OBJECT_new },
  { "ASN1_OCTET_STRING_cmp", (void *)_cffi_f_ASN1_OCTET_STRING_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1024), (void *)_cffi_d_ASN1_OCTET_STRING_cmp },
  { "ASN1_OCTET_STRING_dup", (void *)_cffi_f_ASN1_OCTET_STRING_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 65), (void *)_cffi_d_ASN1_OCTET_STRING_dup },
  { "ASN1_OCTET_STRING_free", (void *)_cffi_f_ASN1_OCTET_STRING_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3148), (void *)_cffi_d_ASN1_OCTET_STRING_free },
  { "ASN1_OCTET_STRING_new", (void *)_cffi_f_ASN1_OCTET_STRING_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 94), (void *)_cffi_d_ASN1_OCTET_STRING_new },
  { "ASN1_OCTET_STRING_set", (void *)_cffi_f_ASN1_OCTET_STRING_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1045), (void *)_cffi_d_ASN1_OCTET_STRING_set },
  { "ASN1_R_BOOLEAN_IS_WRONG_LENGTH", (void *)_cffi_const_ASN1_R_BOOLEAN_IS_WRONG_LENGTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_BUFFER_TOO_SMALL", (void *)_cffi_const_ASN1_R_BUFFER_TOO_SMALL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER", (void *)_cffi_const_ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_DATA_IS_WRONG", (void *)_cffi_const_ASN1_R_DATA_IS_WRONG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_DECODE_ERROR", (void *)_cffi_const_ASN1_R_DECODE_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_DEPTH_EXCEEDED", (void *)_cffi_const_ASN1_R_DEPTH_EXCEEDED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_ENCODE_ERROR", (void *)_cffi_const_ASN1_R_ENCODE_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_ERROR_GETTING_TIME", (void *)_cffi_const_ASN1_R_ERROR_GETTING_TIME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_ERROR_LOADING_SECTION", (void *)_cffi_const_ASN1_R_ERROR_LOADING_SECTION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_HEADER_TOO_LONG", (void *)_cffi_const_ASN1_R_HEADER_TOO_LONG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_MSTRING_WRONG_TAG", (void *)_cffi_const_ASN1_R_MSTRING_WRONG_TAG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_NESTED_ASN1_STRING", (void *)_cffi_const_ASN1_R_NESTED_ASN1_STRING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_NO_CONTENT_TYPE", (void *)_cffi_const_ASN1_R_NO_CONTENT_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_NO_MATCHING_CHOICE_TYPE", (void *)_cffi_const_ASN1_R_NO_MATCHING_CHOICE_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_NO_MULTIPART_BODY_FAILURE", (void *)_cffi_const_ASN1_R_NO_MULTIPART_BODY_FAILURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_NO_MULTIPART_BOUNDARY", (void *)_cffi_const_ASN1_R_NO_MULTIPART_BOUNDARY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM", (void *)_cffi_const_ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNKNOWN_OBJECT_TYPE", (void *)_cffi_const_ASN1_R_UNKNOWN_OBJECT_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE", (void *)_cffi_const_ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNKNOWN_TAG", (void *)_cffi_const_ASN1_R_UNKNOWN_TAG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE", (void *)_cffi_const_ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE", (void *)_cffi_const_ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_UNSUPPORTED_TYPE", (void *)_cffi_const_ASN1_R_UNSUPPORTED_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_R_WRONG_TAG", (void *)_cffi_const_ASN1_R_WRONG_TAG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ASN1_STRING_cmp", (void *)_cffi_f_ASN1_STRING_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1024), (void *)_cffi_d_ASN1_STRING_cmp },
  { "ASN1_STRING_data", (void *)_cffi_f_ASN1_STRING_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3003), (void *)_cffi_d_ASN1_STRING_data },
  { "ASN1_STRING_dup", (void *)_cffi_f_ASN1_STRING_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 65), (void *)_cffi_d_ASN1_STRING_dup },
  { "ASN1_STRING_free", (void *)_cffi_f_ASN1_STRING_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3148), (void *)_cffi_d_ASN1_STRING_free },
  { "ASN1_STRING_length", (void *)_cffi_f_ASN1_STRING_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1021), (void *)_cffi_d_ASN1_STRING_length },
  { "ASN1_STRING_new", (void *)_cffi_f_ASN1_STRING_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 94), (void *)_cffi_d_ASN1_STRING_new },
  { "ASN1_STRING_set", (void *)_cffi_f_ASN1_STRING_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1050), (void *)_cffi_d_ASN1_STRING_set },
  { "ASN1_STRING_set_default_mask_asc", (void *)_cffi_f_ASN1_STRING_set_default_mask_asc, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2620), (void *)_cffi_d_ASN1_STRING_set_default_mask_asc },
  { "ASN1_STRING_to_UTF8", (void *)_cffi_f_ASN1_STRING_to_UTF8, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2766), (void *)_cffi_d_ASN1_STRING_to_UTF8 },
  { "ASN1_STRING_type", (void *)_cffi_f_ASN1_STRING_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1021), (void *)_cffi_d_ASN1_STRING_type },
  { "ASN1_STRING_type_new", (void *)_cffi_f_ASN1_STRING_type_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 88), (void *)_cffi_d_ASN1_STRING_type_new },
  { "ASN1_TIME_check", (void *)_cffi_f_ASN1_TIME_check, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1021), (void *)_cffi_d_ASN1_TIME_check },
  { "ASN1_TIME_free", (void *)_cffi_f_ASN1_TIME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3148), (void *)_cffi_d_ASN1_TIME_free },
  { "ASN1_TIME_new", (void *)_cffi_f_ASN1_TIME_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 94), (void *)_cffi_d_ASN1_TIME_new },
  { "ASN1_TIME_print", (void *)_cffi_f_ASN1_TIME_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1147), (void *)_cffi_d_ASN1_TIME_print },
  { "ASN1_TIME_set", (void *)_cffi_f_ASN1_TIME_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 72), (void *)_cffi_d_ASN1_TIME_set },
  { "ASN1_TIME_set_string", (void *)_cffi_f_ASN1_TIME_set_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1028), (void *)_cffi_d_ASN1_TIME_set_string },
  { "ASN1_TIME_to_generalizedtime", (void *)_cffi_f_ASN1_TIME_to_generalizedtime, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 12), (void *)_cffi_d_ASN1_TIME_to_generalizedtime },
  { "ASN1_UTCTIME_check", (void *)_cffi_f_ASN1_UTCTIME_check, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1059), (void *)_cffi_d_ASN1_UTCTIME_check },
  { "ASN1_UTCTIME_cmp_time_t", (void *)_cffi_f_ASN1_UTCTIME_cmp_time_t, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1062), (void *)_cffi_d_ASN1_UTCTIME_cmp_time_t },
  { "ASN1_UTCTIME_free", (void *)_cffi_f_ASN1_UTCTIME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3151), (void *)_cffi_d_ASN1_UTCTIME_free },
  { "ASN1_UTCTIME_new", (void *)_cffi_f_ASN1_UTCTIME_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 108), (void *)_cffi_d_ASN1_UTCTIME_new },
  { "ASN1_UTCTIME_print", (void *)_cffi_f_ASN1_UTCTIME_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1151), (void *)_cffi_d_ASN1_UTCTIME_print },
  { "ASN1_UTCTIME_set", (void *)_cffi_f_ASN1_UTCTIME_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 104), (void *)_cffi_d_ASN1_UTCTIME_set },
  { "ASN1_UTF8STRING_free", (void *)_cffi_f_ASN1_UTF8STRING_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3148), (void *)_cffi_d_ASN1_UTF8STRING_free },
  { "ASN1_UTF8STRING_new", (void *)_cffi_f_ASN1_UTF8STRING_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 94), (void *)_cffi_d_ASN1_UTF8STRING_new },
  { "ASN1_item_d2i", (void *)_cffi_f_ASN1_item_d2i, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 110), (void *)_cffi_d_ASN1_item_d2i },
  { "AUTHORITY_KEYID_free", (void *)_cffi_f_AUTHORITY_KEYID_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3154), (void *)_cffi_d_AUTHORITY_KEYID_free },
  { "AUTHORITY_KEYID_new", (void *)_cffi_f_AUTHORITY_KEYID_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 116), (void *)_cffi_d_AUTHORITY_KEYID_new },
  { "BASIC_CONSTRAINTS_free", (void *)_cffi_f_BASIC_CONSTRAINTS_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3157), (void *)_cffi_d_BASIC_CONSTRAINTS_free },
  { "BASIC_CONSTRAINTS_new", (void *)_cffi_f_BASIC_CONSTRAINTS_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 118), (void *)_cffi_d_BASIC_CONSTRAINTS_new },
  { "BIO_CLOSE", (void *)_cffi_const_BIO_CLOSE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_DUP", (void *)_cffi_const_BIO_CTRL_DUP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_EOF", (void *)_cffi_const_BIO_CTRL_EOF, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_FLUSH", (void *)_cffi_const_BIO_CTRL_FLUSH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_GET", (void *)_cffi_const_BIO_CTRL_GET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_GET_CLOSE", (void *)_cffi_const_BIO_CTRL_GET_CLOSE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_INFO", (void *)_cffi_const_BIO_CTRL_INFO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_PENDING", (void *)_cffi_const_BIO_CTRL_PENDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_RESET", (void *)_cffi_const_BIO_CTRL_RESET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_SET", (void *)_cffi_const_BIO_CTRL_SET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_SET_CLOSE", (void *)_cffi_const_BIO_CTRL_SET_CLOSE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_CTRL_WPENDING", (void *)_cffi_const_BIO_CTRL_WPENDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_C_FILE_SEEK", (void *)_cffi_const_BIO_C_FILE_SEEK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_C_FILE_TELL", (void *)_cffi_const_BIO_C_FILE_TELL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_FLAGS_IO_SPECIAL", (void *)_cffi_const_BIO_FLAGS_IO_SPECIAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_FLAGS_READ", (void *)_cffi_const_BIO_FLAGS_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_FLAGS_RWS", (void *)_cffi_const_BIO_FLAGS_RWS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_FLAGS_SHOULD_RETRY", (void *)_cffi_const_BIO_FLAGS_SHOULD_RETRY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_FLAGS_WRITE", (void *)_cffi_const_BIO_FLAGS_WRITE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_NOCLOSE", (void *)_cffi_const_BIO_NOCLOSE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_ACCEPT", (void *)_cffi_const_BIO_TYPE_ACCEPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_BASE64", (void *)_cffi_const_BIO_TYPE_BASE64, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_BIO", (void *)_cffi_const_BIO_TYPE_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_BUFFER", (void *)_cffi_const_BIO_TYPE_BUFFER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_CIPHER", (void *)_cffi_const_BIO_TYPE_CIPHER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_CONNECT", (void *)_cffi_const_BIO_TYPE_CONNECT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_DESCRIPTOR", (void *)_cffi_const_BIO_TYPE_DESCRIPTOR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_FD", (void *)_cffi_const_BIO_TYPE_FD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_FILE", (void *)_cffi_const_BIO_TYPE_FILE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_FILTER", (void *)_cffi_const_BIO_TYPE_FILTER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_MD", (void *)_cffi_const_BIO_TYPE_MD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_MEM", (void *)_cffi_const_BIO_TYPE_MEM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_NBIO_TEST", (void *)_cffi_const_BIO_TYPE_NBIO_TEST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_NONE", (void *)_cffi_const_BIO_TYPE_NONE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_NULL", (void *)_cffi_const_BIO_TYPE_NULL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_NULL_FILTER", (void *)_cffi_const_BIO_TYPE_NULL_FILTER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_SOCKET", (void *)_cffi_const_BIO_TYPE_SOCKET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_SOURCE_SINK", (void *)_cffi_const_BIO_TYPE_SOURCE_SINK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_TYPE_SSL", (void *)_cffi_const_BIO_TYPE_SSL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "BIO_append_filename", (void *)_cffi_f_BIO_append_filename, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2872), (void *)_cffi_d_BIO_append_filename },
  { "BIO_callback_ctrl", (void *)_cffi_f_BIO_callback_ctrl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2892), (void *)_cffi_d_BIO_callback_ctrl },
  { "BIO_clear_retry_flags", (void *)_cffi_f_BIO_clear_retry_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3163), (void *)_cffi_d_BIO_clear_retry_flags },
  { "BIO_ctrl", (void *)_cffi_f_BIO_ctrl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2886), (void *)_cffi_d_BIO_ctrl },
  { "BIO_ctrl_pending", (void *)_cffi_f_BIO_ctrl_pending, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2966), (void *)_cffi_d_BIO_ctrl_pending },
  { "BIO_ctrl_wpending", (void *)_cffi_f_BIO_ctrl_wpending, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2966), (void *)_cffi_d_BIO_ctrl_wpending },
  { "BIO_eof", (void *)_cffi_f_BIO_eof, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_eof },
  { "BIO_f_buffer", (void *)_cffi_f_BIO_f_buffer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_f_buffer },
  { "BIO_f_null", (void *)_cffi_f_BIO_f_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_f_null },
  { "BIO_find_type", (void *)_cffi_f_BIO_find_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 170), (void *)_cffi_d_BIO_find_type },
  { "BIO_flush", (void *)_cffi_f_BIO_flush, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_flush },
  { "BIO_free", (void *)_cffi_f_BIO_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_free },
  { "BIO_free_all", (void *)_cffi_f_BIO_free_all, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3163), (void *)_cffi_d_BIO_free_all },
  { "BIO_get_buffer_num_lines", (void *)_cffi_f_BIO_get_buffer_num_lines, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2847), (void *)_cffi_d_BIO_get_buffer_num_lines },
  { "BIO_get_close", (void *)_cffi_f_BIO_get_close, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_get_close },
  { "BIO_get_fd", (void *)_cffi_f_BIO_get_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2872), (void *)_cffi_d_BIO_get_fd },
  { "BIO_get_fp", (void *)_cffi_f_BIO_get_fp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2859), (void *)_cffi_d_BIO_get_fp },
  { "BIO_get_info_callback", (void *)_cffi_f_BIO_get_info_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1335), (void *)_cffi_d_BIO_get_info_callback },
  { "BIO_get_mem_data", (void *)_cffi_f_BIO_get_mem_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2868), (void *)_cffi_d_BIO_get_mem_data },
  { "BIO_get_mem_ptr", (void *)_cffi_f_BIO_get_mem_ptr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2850), (void *)_cffi_d_BIO_get_mem_ptr },
  { "BIO_gets", (void *)_cffi_f_BIO_gets, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1308), (void *)_cffi_d_BIO_gets },
  { "BIO_int_ctrl", (void *)_cffi_f_BIO_int_ctrl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2880), (void *)_cffi_d_BIO_int_ctrl },
  { "BIO_method_type", (void *)_cffi_f_BIO_method_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1343), (void *)_cffi_d_BIO_method_type },
  { "BIO_new", (void *)_cffi_f_BIO_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 174), (void *)_cffi_d_BIO_new },
  { "BIO_new_CMS", (void *)_cffi_f_BIO_new_CMS, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 166), (void *)_cffi_d_BIO_new_CMS },
  { "BIO_new_fd", (void *)_cffi_f_BIO_new_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 192), (void *)_cffi_d_BIO_new_fd },
  { "BIO_new_file", (void *)_cffi_f_BIO_new_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 188), (void *)_cffi_d_BIO_new_file },
  { "BIO_new_fp", (void *)_cffi_f_BIO_new_fp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 177), (void *)_cffi_d_BIO_new_fp },
  { "BIO_new_mem_buf", (void *)_cffi_f_BIO_new_mem_buf, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_BIO_new_mem_buf },
  { "BIO_new_socket", (void *)_cffi_f_BIO_new_socket, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 192), (void *)_cffi_d_BIO_new_socket },
  { "BIO_next", (void *)_cffi_f_BIO_next, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 159), (void *)_cffi_d_BIO_next },
  { "BIO_pending", (void *)_cffi_f_BIO_pending, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_pending },
  { "BIO_pop", (void *)_cffi_f_BIO_pop, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 159), (void *)_cffi_d_BIO_pop },
  { "BIO_push", (void *)_cffi_f_BIO_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 162), (void *)_cffi_d_BIO_push },
  { "BIO_puts", (void *)_cffi_f_BIO_puts, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1313), (void *)_cffi_d_BIO_puts },
  { "BIO_read", (void *)_cffi_f_BIO_read, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1325), (void *)_cffi_d_BIO_read },
  { "BIO_read_filename", (void *)_cffi_f_BIO_read_filename, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2872), (void *)_cffi_d_BIO_read_filename },
  { "BIO_reset", (void *)_cffi_f_BIO_reset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_reset },
  { "BIO_retry_type", (void *)_cffi_f_BIO_retry_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_retry_type },
  { "BIO_rw_filename", (void *)_cffi_f_BIO_rw_filename, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2872), (void *)_cffi_d_BIO_rw_filename },
  { "BIO_s_fd", (void *)_cffi_f_BIO_s_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_s_fd },
  { "BIO_s_file", (void *)_cffi_f_BIO_s_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_s_file },
  { "BIO_s_mem", (void *)_cffi_f_BIO_s_mem, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_s_mem },
  { "BIO_s_null", (void *)_cffi_f_BIO_s_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_s_null },
  { "BIO_s_socket", (void *)_cffi_f_BIO_s_socket, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 200), (void *)_cffi_d_BIO_s_socket },
  { "BIO_seek", (void *)_cffi_f_BIO_seek, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1317), (void *)_cffi_d_BIO_seek },
  { "BIO_set_buffer_read_data", (void *)_cffi_f_BIO_set_buffer_read_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2906), (void *)_cffi_d_BIO_set_buffer_read_data },
  { "BIO_set_buffer_size", (void *)_cffi_f_BIO_set_buffer_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2897), (void *)_cffi_d_BIO_set_buffer_size },
  { "BIO_set_close", (void *)_cffi_f_BIO_set_close, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1321), (void *)_cffi_d_BIO_set_close },
  { "BIO_set_fd", (void *)_cffi_f_BIO_set_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2901), (void *)_cffi_d_BIO_set_fd },
  { "BIO_set_fp", (void *)_cffi_f_BIO_set_fp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2863), (void *)_cffi_d_BIO_set_fp },
  { "BIO_set_info_callback", (void *)_cffi_f_BIO_set_info_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1339), (void *)_cffi_d_BIO_set_info_callback },
  { "BIO_set_mem_buf", (void *)_cffi_f_BIO_set_mem_buf, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2854), (void *)_cffi_d_BIO_set_mem_buf },
  { "BIO_set_mem_eof_return", (void *)_cffi_f_BIO_set_mem_eof_return, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2876), (void *)_cffi_d_BIO_set_mem_eof_return },
  { "BIO_set_nbio", (void *)_cffi_f_BIO_set_nbio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2897), (void *)_cffi_d_BIO_set_nbio },
  { "BIO_set_read_buffer_size", (void *)_cffi_f_BIO_set_read_buffer_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2897), (void *)_cffi_d_BIO_set_read_buffer_size },
  { "BIO_set_retry_read", (void *)_cffi_f_BIO_set_retry_read, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3163), (void *)_cffi_d_BIO_set_retry_read },
  { "BIO_set_write_buffer_size", (void *)_cffi_f_BIO_set_write_buffer_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2897), (void *)_cffi_d_BIO_set_write_buffer_size },
  { "BIO_should_io_special", (void *)_cffi_f_BIO_should_io_special, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_should_io_special },
  { "BIO_should_read", (void *)_cffi_f_BIO_should_read, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_should_read },
  { "BIO_should_retry", (void *)_cffi_f_BIO_should_retry, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_should_retry },
  { "BIO_should_write", (void *)_cffi_f_BIO_should_write, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_should_write },
  { "BIO_tell", (void *)_cffi_f_BIO_tell, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_tell },
  { "BIO_up_ref", (void *)_cffi_f_BIO_up_ref, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_up_ref },
  { "BIO_vfree", (void *)_cffi_f_BIO_vfree, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3163), (void *)_cffi_d_BIO_vfree },
  { "BIO_wpending", (void *)_cffi_f_BIO_wpending, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1140), (void *)_cffi_d_BIO_wpending },
  { "BIO_write", (void *)_cffi_f_BIO_write, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1330), (void *)_cffi_d_BIO_write },
  { "BIO_write_filename", (void *)_cffi_f_BIO_write_filename, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2872), (void *)_cffi_d_BIO_write_filename },
  { "BN_CTX_end", (void *)_cffi_f_BN_CTX_end, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3174), (void *)_cffi_d_BN_CTX_end },
  { "BN_CTX_free", (void *)_cffi_f_BN_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3174), (void *)_cffi_d_BN_CTX_free },
  { "BN_CTX_get", (void *)_cffi_f_BN_CTX_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 137), (void *)_cffi_d_BN_CTX_get },
  { "BN_CTX_new", (void *)_cffi_f_BN_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 202), (void *)_cffi_d_BN_CTX_new },
  { "BN_CTX_start", (void *)_cffi_f_BN_CTX_start, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3174), (void *)_cffi_d_BN_CTX_start },
  { "BN_add", (void *)_cffi_f_BN_add, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1089), (void *)_cffi_d_BN_add },
  { "BN_bin2bn", (void *)_cffi_f_BN_bin2bn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 147), (void *)_cffi_d_BN_bin2bn },
  { "BN_bn2bin", (void *)_cffi_f_BN_bn2bin, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1136), (void *)_cffi_d_BN_bn2bin },
  { "BN_bn2hex", (void *)_cffi_f_BN_bn2hex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 909), (void *)_cffi_d_BN_bn2hex },
  { "BN_clear_bit", (void *)_cffi_f_BN_clear_bit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1121), (void *)_cffi_d_BN_clear_bit },
  { "BN_cmp", (void *)_cffi_f_BN_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1128), (void *)_cffi_d_BN_cmp },
  { "BN_copy", (void *)_cffi_f_BN_copy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_BN_copy },
  { "BN_dec2bn", (void *)_cffi_f_BN_dec2bn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1066), (void *)_cffi_d_BN_dec2bn },
  { "BN_div", (void *)_cffi_f_BN_div, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1077), (void *)_cffi_d_BN_div },
  { "BN_dup", (void *)_cffi_f_BN_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 134), (void *)_cffi_d_BN_dup },
  { "BN_exp", (void *)_cffi_f_BN_exp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1101), (void *)_cffi_d_BN_exp },
  { "BN_free", (void *)_cffi_f_BN_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3160), (void *)_cffi_d_BN_free },
  { "BN_gcd", (void *)_cffi_f_BN_gcd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1101), (void *)_cffi_d_BN_gcd },
  { "BN_get_word", (void *)_cffi_f_BN_get_word, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 204), (void *)_cffi_d_BN_get_word },
  { "BN_hex2bn", (void *)_cffi_f_BN_hex2bn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1066), (void *)_cffi_d_BN_hex2bn },
  { "BN_is_bit_set", (void *)_cffi_f_BN_is_bit_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1132), (void *)_cffi_d_BN_is_bit_set },
  { "BN_lshift", (void *)_cffi_f_BN_lshift, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1112), (void *)_cffi_d_BN_lshift },
  { "BN_lshift1", (void *)_cffi_f_BN_lshift1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1073), (void *)_cffi_d_BN_lshift1 },
  { "BN_mask_bits", (void *)_cffi_f_BN_mask_bits, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1121), (void *)_cffi_d_BN_mask_bits },
  { "BN_mod", (void *)_cffi_f_BN_mod, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1101), (void *)_cffi_d_BN_mod },
  { "BN_mod_add", (void *)_cffi_f_BN_mod_add, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1094), (void *)_cffi_d_BN_mod_add },
  { "BN_mod_exp", (void *)_cffi_f_BN_mod_exp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1094), (void *)_cffi_d_BN_mod_exp },
  { "BN_mod_inverse", (void *)_cffi_f_BN_mod_inverse, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 128), (void *)_cffi_d_BN_mod_inverse },
  { "BN_mod_mul", (void *)_cffi_f_BN_mod_mul, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1094), (void *)_cffi_d_BN_mod_mul },
  { "BN_mod_sqr", (void *)_cffi_f_BN_mod_sqr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1101), (void *)_cffi_d_BN_mod_sqr },
  { "BN_mod_sub", (void *)_cffi_f_BN_mod_sub, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1094), (void *)_cffi_d_BN_mod_sub },
  { "BN_mul", (void *)_cffi_f_BN_mul, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1101), (void *)_cffi_d_BN_mul },
  { "BN_new", (void *)_cffi_f_BN_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 152), (void *)_cffi_d_BN_new },
  { "BN_nnmod", (void *)_cffi_f_BN_nnmod, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1101), (void *)_cffi_d_BN_nnmod },
  { "BN_num_bits", (void *)_cffi_f_BN_num_bits, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1125), (void *)_cffi_d_BN_num_bits },
  { "BN_num_bytes", (void *)_cffi_f_BN_num_bytes, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1125), (void *)_cffi_d_BN_num_bytes },
  { "BN_one", (void *)_cffi_f_BN_one, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1070), (void *)_cffi_d_BN_one },
  { "BN_rshift", (void *)_cffi_f_BN_rshift, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1084), (void *)_cffi_d_BN_rshift },
  { "BN_rshift1", (void *)_cffi_f_BN_rshift1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1073), (void *)_cffi_d_BN_rshift1 },
  { "BN_set_bit", (void *)_cffi_f_BN_set_bit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1121), (void *)_cffi_d_BN_set_bit },
  { "BN_set_word", (void *)_cffi_f_BN_set_word, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1117), (void *)_cffi_d_BN_set_word },
  { "BN_sqr", (void *)_cffi_f_BN_sqr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1107), (void *)_cffi_d_BN_sqr },
  { "BN_sub", (void *)_cffi_f_BN_sub, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1089), (void *)_cffi_d_BN_sub },
  { "BN_to_ASN1_INTEGER", (void *)_cffi_f_BN_to_ASN1_INTEGER, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 19), (void *)_cffi_d_BN_to_ASN1_INTEGER },
  { "BN_value_one", (void *)_cffi_f_BN_value_one, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 157), (void *)_cffi_d_BN_value_one },
  { "BN_zero", (void *)_cffi_f_BN_zero, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1070), (void *)_cffi_d_BN_zero },
  { "CERTIFICATEPOLICIES_free", (void *)_cffi_f_CERTIFICATEPOLICIES_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3199), (void *)_cffi_d_CERTIFICATEPOLICIES_free },
  { "CMAC_CTX_copy", (void *)_cffi_f_CMAC_CTX_copy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1346), (void *)_cffi_d_CMAC_CTX_copy },
  { "CMAC_CTX_free", (void *)_cffi_f_CMAC_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3177), (void *)_cffi_d_CMAC_CTX_free },
  { "CMAC_CTX_new", (void *)_cffi_f_CMAC_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 207), (void *)_cffi_d_CMAC_CTX_new },
  { "CMAC_Final", (void *)_cffi_f_CMAC_Final, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1350), (void *)_cffi_d_CMAC_Final },
  { "CMAC_Init", (void *)_cffi_f_CMAC_Init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1360), (void *)_cffi_d_CMAC_Init },
  { "CMAC_Update", (void *)_cffi_f_CMAC_Update, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1355), (void *)_cffi_d_CMAC_Update },
  { "CMS_BINARY", (void *)_cffi_const_CMS_BINARY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_CRLFEOL", (void *)_cffi_const_CMS_CRLFEOL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_DEBUG_DECRYPT", (void *)_cffi_const_CMS_DEBUG_DECRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_DETACHED", (void *)_cffi_const_CMS_DETACHED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOATTR", (void *)_cffi_const_CMS_NOATTR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOCERTS", (void *)_cffi_const_CMS_NOCERTS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOCRL", (void *)_cffi_const_CMS_NOCRL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOINTERN", (void *)_cffi_const_CMS_NOINTERN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOOLDMIMETYPE", (void *)_cffi_const_CMS_NOOLDMIMETYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOSIGS", (void *)_cffi_const_CMS_NOSIGS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOSMIMECAP", (void *)_cffi_const_CMS_NOSMIMECAP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NOVERIFY", (void *)_cffi_const_CMS_NOVERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NO_ATTR_VERIFY", (void *)_cffi_const_CMS_NO_ATTR_VERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NO_CONTENT_VERIFY", (void *)_cffi_const_CMS_NO_CONTENT_VERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_NO_SIGNER_CERT_VERIFY", (void *)_cffi_const_CMS_NO_SIGNER_CERT_VERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_PARTIAL", (void *)_cffi_const_CMS_PARTIAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_REUSE_DIGEST", (void *)_cffi_const_CMS_REUSE_DIGEST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_STREAM", (void *)_cffi_const_CMS_STREAM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_TEXT", (void *)_cffi_const_CMS_TEXT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_USE_KEYID", (void *)_cffi_const_CMS_USE_KEYID, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CMS_add1_signer", (void *)_cffi_f_CMS_add1_signer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 222), (void *)_cffi_d_CMS_add1_signer },
  { "CMS_decrypt", (void *)_cffi_f_CMS_decrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1381), (void *)_cffi_d_CMS_decrypt },
  { "CMS_encrypt", (void *)_cffi_f_CMS_encrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 209), (void *)_cffi_d_CMS_encrypt },
  { "CMS_final", (void *)_cffi_f_CMS_final, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1367), (void *)_cffi_d_CMS_final },
  { "CMS_sign", (void *)_cffi_f_CMS_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 215), (void *)_cffi_d_CMS_sign },
  { "CMS_verify", (void *)_cffi_f_CMS_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1373), (void *)_cffi_d_CMS_verify },
  { "CRL_DIST_POINTS_free", (void *)_cffi_f_CRL_DIST_POINTS_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3189), (void *)_cffi_d_CRL_DIST_POINTS_free },
  { "CRYPTOGRAPHY_IS_LIBRESSL", (void *)_cffi_const_CRYPTOGRAPHY_IS_LIBRESSL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER", (void *)_cffi_const_CRYPTOGRAPHY_OPENSSL_102L_OR_GREATER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER", (void *)_cffi_const_CRYPTOGRAPHY_OPENSSL_110F_OR_GREATER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTOGRAPHY_OPENSSL_110_OR_GREATER", (void *)_cffi_const_CRYPTOGRAPHY_OPENSSL_110_OR_GREATER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTOGRAPHY_OPENSSL_LESS_THAN_102", (void *)_cffi_const_CRYPTOGRAPHY_OPENSSL_LESS_THAN_102, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I", (void *)_cffi_const_CRYPTOGRAPHY_OPENSSL_LESS_THAN_102I, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_LOCK", (void *)_cffi_const_CRYPTO_LOCK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_LOCK_SSL", (void *)_cffi_const_CRYPTO_LOCK_SSL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_MEM_CHECK_DISABLE", (void *)_cffi_const_CRYPTO_MEM_CHECK_DISABLE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_MEM_CHECK_ENABLE", (void *)_cffi_const_CRYPTO_MEM_CHECK_ENABLE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_MEM_CHECK_OFF", (void *)_cffi_const_CRYPTO_MEM_CHECK_OFF, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_MEM_CHECK_ON", (void *)_cffi_const_CRYPTO_MEM_CHECK_ON, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_READ", (void *)_cffi_const_CRYPTO_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_UNLOCK", (void *)_cffi_const_CRYPTO_UNLOCK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "CRYPTO_cleanup_all_ex_data", (void *)_cffi_f_CRYPTO_cleanup_all_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_CRYPTO_cleanup_all_ex_data },
  { "CRYPTO_get_locking_callback", (void *)_cffi_f_CRYPTO_get_locking_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3630), (void *)_cffi_d_CRYPTO_get_locking_callback },
  { "CRYPTO_lock", (void *)_cffi_f_CRYPTO_lock, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3576), (void *)_cffi_d_CRYPTO_lock },
  { "CRYPTO_mem_ctrl", (void *)_cffi_f_CRYPTO_mem_ctrl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2687), (void *)_cffi_d_CRYPTO_mem_ctrl },
  { "CRYPTO_num_locks", (void *)_cffi_f_CRYPTO_num_locks, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_CRYPTO_num_locks },
  { "CRYPTO_set_locking_callback", (void *)_cffi_f_CRYPTO_set_locking_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3619), (void *)_cffi_d_CRYPTO_set_locking_callback },
  { "CT_LOG_ENTRY_TYPE_NOT_SET", (void *)_cffi_const_CT_LOG_ENTRY_TYPE_NOT_SET, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CT_LOG_ENTRY_TYPE_PRECERT", (void *)_cffi_const_CT_LOG_ENTRY_TYPE_PRECERT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CT_LOG_ENTRY_TYPE_X509", (void *)_cffi_const_CT_LOG_ENTRY_TYPE_X509, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "Cryptography_CRYPTO_set_mem_functions", (void *)_cffi_f_Cryptography_CRYPTO_set_mem_functions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2818), (void *)_cffi_d_Cryptography_CRYPTO_set_mem_functions },
  { "Cryptography_DH_check", (void *)_cffi_f_Cryptography_DH_check, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1511), (void *)_cffi_d_Cryptography_DH_check },
  { "Cryptography_DTLSv1_get_timeout", (void *)_cffi_f_Cryptography_DTLSv1_get_timeout, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2922), (void *)_cffi_d_Cryptography_DTLSv1_get_timeout },
  { "Cryptography_EVP_MD_CTX_free", (void *)_cffi_f_Cryptography_EVP_MD_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3293), (void *)_cffi_d_Cryptography_EVP_MD_CTX_free },
  { "Cryptography_EVP_MD_CTX_new", (void *)_cffi_f_Cryptography_EVP_MD_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 474), (void *)_cffi_d_Cryptography_EVP_MD_CTX_new },
  { "Cryptography_EVP_PKEY_id", (void *)_cffi_f_Cryptography_EVP_PKEY_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1937), (void *)_cffi_d_Cryptography_EVP_PKEY_id },
  { "Cryptography_HAS_102_VERIFICATION_ERROR_CODES", (void *)_cffi_const_Cryptography_HAS_102_VERIFICATION_ERROR_CODES, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_102_VERIFICATION_PARAMS", (void *)_cffi_const_Cryptography_HAS_102_VERIFICATION_PARAMS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_AES_WRAP", (void *)_cffi_const_Cryptography_HAS_AES_WRAP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_ALPN", (void *)_cffi_const_Cryptography_HAS_ALPN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_CMAC", (void *)_cffi_const_Cryptography_HAS_CMAC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_CMS", (void *)_cffi_const_Cryptography_HAS_CMS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_CMS_BIO_FUNCTIONS", (void *)_cffi_const_Cryptography_HAS_CMS_BIO_FUNCTIONS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_COMPRESSION", (void *)_cffi_const_Cryptography_HAS_COMPRESSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_DTLS", (void *)_cffi_const_Cryptography_HAS_DTLS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_EC", (void *)_cffi_const_Cryptography_HAS_EC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_EC2M", (void *)_cffi_const_Cryptography_HAS_EC2M, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_ECDH", (void *)_cffi_const_Cryptography_HAS_ECDH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_ECDSA", (void *)_cffi_const_Cryptography_HAS_ECDSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_EC_1_0_2", (void *)_cffi_const_Cryptography_HAS_EC_1_0_2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_EC_CODES", (void *)_cffi_const_Cryptography_HAS_EC_CODES, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_EGD", (void *)_cffi_const_Cryptography_HAS_EGD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_ENGINE_CRYPTODEV", (void *)_cffi_const_Cryptography_HAS_ENGINE_CRYPTODEV, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_EVP_PKEY_DHX", (void *)_cffi_const_Cryptography_HAS_EVP_PKEY_DHX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_GCM", (void *)_cffi_const_Cryptography_HAS_GCM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_GET_SERVER_TMP_KEY", (void *)_cffi_const_Cryptography_HAS_GET_SERVER_TMP_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_LOCKING_CALLBACKS", (void *)_cffi_const_Cryptography_HAS_LOCKING_CALLBACKS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_MEM_FUNCTIONS", (void *)_cffi_const_Cryptography_HAS_MEM_FUNCTIONS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_NEXTPROTONEG", (void *)_cffi_const_Cryptography_HAS_NEXTPROTONEG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_OP_NO_COMPRESSION", (void *)_cffi_const_Cryptography_HAS_OP_NO_COMPRESSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_PBKDF2_HMAC", (void *)_cffi_const_Cryptography_HAS_PBKDF2_HMAC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_PKEY_CTX", (void *)_cffi_const_Cryptography_HAS_PKEY_CTX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_PSS_PADDING", (void *)_cffi_const_Cryptography_HAS_PSS_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_RELEASE_BUFFERS", (void *)_cffi_const_Cryptography_HAS_RELEASE_BUFFERS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_RSA_OAEP_MD", (void *)_cffi_const_Cryptography_HAS_RSA_OAEP_MD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR", (void *)_cffi_const_Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SCRYPT", (void *)_cffi_const_Cryptography_HAS_SCRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SCT", (void *)_cffi_const_Cryptography_HAS_SCT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SECURE_RENEGOTIATION", (void *)_cffi_const_Cryptography_HAS_SECURE_RENEGOTIATION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SET_CERT_CB", (void *)_cffi_const_Cryptography_HAS_SET_CERT_CB, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SET_ECDH_AUTO", (void *)_cffi_const_Cryptography_HAS_SET_ECDH_AUTO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL2", (void *)_cffi_const_Cryptography_HAS_SSL2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL3_METHOD", (void *)_cffi_const_Cryptography_HAS_SSL3_METHOD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS", (void *)_cffi_const_Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE", (void *)_cffi_const_Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING", (void *)_cffi_const_Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL_OP_NO_TICKET", (void *)_cffi_const_Cryptography_HAS_SSL_OP_NO_TICKET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL_SET_SSL_CTX", (void *)_cffi_const_Cryptography_HAS_SSL_SET_SSL_CTX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_SSL_ST", (void *)_cffi_const_Cryptography_HAS_SSL_ST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_STATUS_REQ_OCSP_RESP", (void *)_cffi_const_Cryptography_HAS_STATUS_REQ_OCSP_RESP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_TLSEXT_HOSTNAME", (void *)_cffi_const_Cryptography_HAS_TLSEXT_HOSTNAME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_TLSEXT_STATUS_REQ_CB", (void *)_cffi_const_Cryptography_HAS_TLSEXT_STATUS_REQ_CB, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE", (void *)_cffi_const_Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_TLS_ST", (void *)_cffi_const_Cryptography_HAS_TLS_ST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_TLSv1_1", (void *)_cffi_const_Cryptography_HAS_TLSv1_1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_TLSv1_2", (void *)_cffi_const_Cryptography_HAS_TLSv1_2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_X25519", (void *)_cffi_const_Cryptography_HAS_X25519, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_X509_STORE_CTX_GET_ISSUER", (void *)_cffi_const_Cryptography_HAS_X509_STORE_CTX_GET_ISSUER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN", (void *)_cffi_const_Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST", (void *)_cffi_const_Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "Cryptography_HMAC_CTX_free", (void *)_cffi_f_Cryptography_HMAC_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3315), (void *)_cffi_d_Cryptography_HMAC_CTX_free },
  { "Cryptography_HMAC_CTX_new", (void *)_cffi_f_Cryptography_HMAC_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 536), (void *)_cffi_d_Cryptography_HMAC_CTX_new },
  { "Cryptography_X509_NAME_ENTRY_set", (void *)_cffi_f_Cryptography_X509_NAME_ENTRY_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2477), (void *)_cffi_d_Cryptography_X509_NAME_ENTRY_set },
  { "Cryptography_X509_REVOKED_dup", (void *)_cffi_f_Cryptography_X509_REVOKED_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 889), (void *)_cffi_d_Cryptography_X509_REVOKED_dup },
  { "Cryptography_add_osrandom_engine", (void *)_cffi_f_Cryptography_add_osrandom_engine, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_Cryptography_add_osrandom_engine },
  { "Cryptography_d2i_DHxparams_bio", (void *)_cffi_f_Cryptography_d2i_DHxparams_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 283), (void *)_cffi_d_Cryptography_d2i_DHxparams_bio },
  { "Cryptography_free_wrapper", (void *)_cffi_f_Cryptography_free_wrapper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3605), (void *)_cffi_d_Cryptography_free_wrapper },
  { "Cryptography_i2d_DHxparams_bio", (void *)_cffi_f_Cryptography_i2d_DHxparams_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1161), (void *)_cffi_d_Cryptography_i2d_DHxparams_bio },
  { "Cryptography_malloc_wrapper", (void *)_cffi_f_Cryptography_malloc_wrapper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3106), (void *)_cffi_d_Cryptography_malloc_wrapper },
  { "Cryptography_osrandom_engine_id", (void *)_cffi_const_Cryptography_osrandom_engine_id, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "Cryptography_osrandom_engine_name", (void *)_cffi_const_Cryptography_osrandom_engine_name, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "Cryptography_pem_password_cb", (void *)_cffi_f_Cryptography_pem_password_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2629), (void *)_cffi_d_Cryptography_pem_password_cb },
  { "Cryptography_realloc_wrapper", (void *)_cffi_f_Cryptography_realloc_wrapper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3111), (void *)_cffi_d_Cryptography_realloc_wrapper },
  { "DH_F_COMPUTE_KEY", (void *)_cffi_const_DH_F_COMPUTE_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "DH_R_INVALID_PUBKEY", (void *)_cffi_const_DH_R_INVALID_PUBKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "DH_check_pub_key", (void *)_cffi_f_DH_check_pub_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1506), (void *)_cffi_d_DH_check_pub_key },
  { "DH_compute_key", (void *)_cffi_f_DH_compute_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2778), (void *)_cffi_d_DH_compute_key },
  { "DH_free", (void *)_cffi_f_DH_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3221), (void *)_cffi_d_DH_free },
  { "DH_generate_key", (void *)_cffi_f_DH_generate_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1478), (void *)_cffi_d_DH_generate_key },
  { "DH_generate_parameters_ex", (void *)_cffi_f_DH_generate_parameters_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1492), (void *)_cffi_d_DH_generate_parameters_ex },
  { "DH_get0_key", (void *)_cffi_f_DH_get0_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3224), (void *)_cffi_d_DH_get0_key },
  { "DH_get0_pqg", (void *)_cffi_f_DH_get0_pqg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3229), (void *)_cffi_d_DH_get0_pqg },
  { "DH_get_ex_data", (void *)_cffi_f_DH_get_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3071), (void *)_cffi_d_DH_get_ex_data },
  { "DH_new", (void *)_cffi_f_DH_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 304), (void *)_cffi_d_DH_new },
  { "DH_set0_key", (void *)_cffi_f_DH_set0_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1481), (void *)_cffi_d_DH_set0_key },
  { "DH_set0_pqg", (void *)_cffi_f_DH_set0_pqg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1486), (void *)_cffi_d_DH_set0_pqg },
  { "DH_set_ex_data", (void *)_cffi_f_DH_set_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1498), (void *)_cffi_d_DH_set_ex_data },
  { "DH_size", (void *)_cffi_f_DH_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1503), (void *)_cffi_d_DH_size },
  { "DHparams_dup", (void *)_cffi_f_DHparams_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 298), (void *)_cffi_d_DHparams_dup },
  { "DHparams_print", (void *)_cffi_f_DHparams_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1165), (void *)_cffi_d_DHparams_print },
  { "DHparams_print_fp", (void *)_cffi_f_DHparams_print_fp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1978), (void *)_cffi_d_DHparams_print_fp },
  { "DIST_POINT_NAME_free", (void *)_cffi_f_DIST_POINT_NAME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3238), (void *)_cffi_d_DIST_POINT_NAME_free },
  { "DIST_POINT_NAME_new", (void *)_cffi_f_DIST_POINT_NAME_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 315), (void *)_cffi_d_DIST_POINT_NAME_new },
  { "DIST_POINT_free", (void *)_cffi_f_DIST_POINT_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3235), (void *)_cffi_d_DIST_POINT_free },
  { "DIST_POINT_new", (void *)_cffi_f_DIST_POINT_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 313), (void *)_cffi_d_DIST_POINT_new },
  { "DSA_free", (void *)_cffi_f_DSA_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3241), (void *)_cffi_d_DSA_free },
  { "DSA_generate_key", (void *)_cffi_f_DSA_generate_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1519), (void *)_cffi_d_DSA_generate_key },
  { "DSA_generate_parameters_ex", (void *)_cffi_f_DSA_generate_parameters_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1533), (void *)_cffi_d_DSA_generate_parameters_ex },
  { "DSA_get0_key", (void *)_cffi_f_DSA_get0_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3244), (void *)_cffi_d_DSA_get0_key },
  { "DSA_get0_pqg", (void *)_cffi_f_DSA_get0_pqg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3249), (void *)_cffi_d_DSA_get0_pqg },
  { "DSA_new", (void *)_cffi_f_DSA_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 338), (void *)_cffi_d_DSA_new },
  { "DSA_set0_key", (void *)_cffi_f_DSA_set0_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1522), (void *)_cffi_d_DSA_set0_key },
  { "DSA_set0_pqg", (void *)_cffi_f_DSA_set0_pqg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1527), (void *)_cffi_d_DSA_set0_pqg },
  { "DSA_sign", (void *)_cffi_f_DSA_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2720), (void *)_cffi_d_DSA_sign },
  { "DSA_size", (void *)_cffi_f_DSA_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1546), (void *)_cffi_d_DSA_size },
  { "DSA_verify", (void *)_cffi_f_DSA_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2736), (void *)_cffi_d_DSA_verify },
  { "DSAparams_dup", (void *)_cffi_f_DSAparams_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 332), (void *)_cffi_d_DSAparams_dup },
  { "DTLSv1_client_method", (void *)_cffi_f_DTLSv1_client_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_DTLSv1_client_method },
  { "DTLSv1_handle_timeout", (void *)_cffi_f_DTLSv1_handle_timeout, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2911), (void *)_cffi_d_DTLSv1_handle_timeout },
  { "DTLSv1_method", (void *)_cffi_f_DTLSv1_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_DTLSv1_method },
  { "DTLSv1_server_method", (void *)_cffi_f_DTLSv1_server_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_DTLSv1_server_method },
  { "ECDH_compute_key", (void *)_cffi_f_ECDH_compute_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2823), (void *)_cffi_d_ECDH_compute_key },
  { "ECDSA_SIG_free", (void *)_cffi_f_ECDSA_SIG_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3255), (void *)_cffi_d_ECDSA_SIG_free },
  { "ECDSA_SIG_new", (void *)_cffi_f_ECDSA_SIG_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 360), (void *)_cffi_d_ECDSA_SIG_new },
  { "ECDSA_do_sign", (void *)_cffi_f_ECDSA_do_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 355), (void *)_cffi_d_ECDSA_do_sign },
  { "ECDSA_do_sign_ex", (void *)_cffi_f_ECDSA_do_sign_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 348), (void *)_cffi_d_ECDSA_do_sign_ex },
  { "ECDSA_do_verify", (void *)_cffi_f_ECDSA_do_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2809), (void *)_cffi_d_ECDSA_do_verify },
  { "ECDSA_sign", (void *)_cffi_f_ECDSA_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2728), (void *)_cffi_d_ECDSA_sign },
  { "ECDSA_sign_ex", (void *)_cffi_f_ECDSA_sign_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2710), (void *)_cffi_d_ECDSA_sign_ex },
  { "ECDSA_sign_setup", (void *)_cffi_f_ECDSA_sign_setup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1699), (void *)_cffi_d_ECDSA_sign_setup },
  { "ECDSA_size", (void *)_cffi_f_ECDSA_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1717), (void *)_cffi_d_ECDSA_size },
  { "ECDSA_verify", (void *)_cffi_f_ECDSA_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2744), (void *)_cffi_d_ECDSA_verify },
  { "EC_F_EC_GROUP_NEW_BY_CURVE_NAME", (void *)_cffi_const_EC_F_EC_GROUP_NEW_BY_CURVE_NAME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EC_GF2m_simple_method", (void *)_cffi_f_EC_GF2m_simple_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 407), (void *)_cffi_d_EC_GF2m_simple_method },
  { "EC_GFp_mont_method", (void *)_cffi_f_EC_GFp_mont_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 407), (void *)_cffi_d_EC_GFp_mont_method },
  { "EC_GFp_nist_method", (void *)_cffi_f_EC_GFp_nist_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 407), (void *)_cffi_d_EC_GFp_nist_method },
  { "EC_GFp_simple_method", (void *)_cffi_f_EC_GFp_simple_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 407), (void *)_cffi_d_EC_GFp_simple_method },
  { "EC_GROUP_clear_free", (void *)_cffi_f_EC_GROUP_clear_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3258), (void *)_cffi_d_EC_GROUP_clear_free },
  { "EC_GROUP_free", (void *)_cffi_f_EC_GROUP_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3258), (void *)_cffi_d_EC_GROUP_free },
  { "EC_GROUP_get0_generator", (void *)_cffi_f_EC_GROUP_get0_generator, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 428), (void *)_cffi_d_EC_GROUP_get0_generator },
  { "EC_GROUP_get_curve_GF2m", (void *)_cffi_f_EC_GROUP_get_curve_GF2m, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1567), (void *)_cffi_d_EC_GROUP_get_curve_GF2m },
  { "EC_GROUP_get_curve_GFp", (void *)_cffi_f_EC_GROUP_get_curve_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1567), (void *)_cffi_d_EC_GROUP_get_curve_GFp },
  { "EC_GROUP_get_curve_name", (void *)_cffi_f_EC_GROUP_get_curve_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1564), (void *)_cffi_d_EC_GROUP_get_curve_name },
  { "EC_GROUP_get_degree", (void *)_cffi_f_EC_GROUP_get_degree, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1564), (void *)_cffi_d_EC_GROUP_get_degree },
  { "EC_GROUP_get_order", (void *)_cffi_f_EC_GROUP_get_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1574), (void *)_cffi_d_EC_GROUP_get_order },
  { "EC_GROUP_have_precompute_mult", (void *)_cffi_f_EC_GROUP_have_precompute_mult, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1564), (void *)_cffi_d_EC_GROUP_have_precompute_mult },
  { "EC_GROUP_method_of", (void *)_cffi_f_EC_GROUP_method_of, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 401), (void *)_cffi_d_EC_GROUP_method_of },
  { "EC_GROUP_new", (void *)_cffi_f_EC_GROUP_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 368), (void *)_cffi_d_EC_GROUP_new },
  { "EC_GROUP_new_by_curve_name", (void *)_cffi_f_EC_GROUP_new_by_curve_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 371), (void *)_cffi_d_EC_GROUP_new_by_curve_name },
  { "EC_GROUP_new_curve_GF2m", (void *)_cffi_f_EC_GROUP_new_curve_GF2m, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 362), (void *)_cffi_d_EC_GROUP_new_curve_GF2m },
  { "EC_GROUP_new_curve_GFp", (void *)_cffi_f_EC_GROUP_new_curve_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 362), (void *)_cffi_d_EC_GROUP_new_curve_GFp },
  { "EC_GROUP_precompute_mult", (void *)_cffi_f_EC_GROUP_precompute_mult, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1560), (void *)_cffi_d_EC_GROUP_precompute_mult },
  { "EC_GROUP_set_asn1_flag", (void *)_cffi_f_EC_GROUP_set_asn1_flag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3261), (void *)_cffi_d_EC_GROUP_set_asn1_flag },
  { "EC_GROUP_set_curve_GF2m", (void *)_cffi_f_EC_GROUP_set_curve_GF2m, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1553), (void *)_cffi_d_EC_GROUP_set_curve_GF2m },
  { "EC_GROUP_set_curve_GFp", (void *)_cffi_f_EC_GROUP_set_curve_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1553), (void *)_cffi_d_EC_GROUP_set_curve_GFp },
  { "EC_GROUP_set_point_conversion_form", (void *)_cffi_f_EC_GROUP_set_point_conversion_form, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3265), (void *)_cffi_d_EC_GROUP_set_point_conversion_form },
  { "EC_KEY_check_key", (void *)_cffi_f_EC_KEY_check_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1717), (void *)_cffi_d_EC_KEY_check_key },
  { "EC_KEY_clear_flags", (void *)_cffi_f_EC_KEY_clear_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3272), (void *)_cffi_d_EC_KEY_clear_flags },
  { "EC_KEY_copy", (void *)_cffi_f_EC_KEY_copy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 389), (void *)_cffi_d_EC_KEY_copy },
  { "EC_KEY_dup", (void *)_cffi_f_EC_KEY_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 386), (void *)_cffi_d_EC_KEY_dup },
  { "EC_KEY_free", (void *)_cffi_f_EC_KEY_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3269), (void *)_cffi_d_EC_KEY_free },
  { "EC_KEY_generate_key", (void *)_cffi_f_EC_KEY_generate_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1683), (void *)_cffi_d_EC_KEY_generate_key },
  { "EC_KEY_get0_group", (void *)_cffi_f_EC_KEY_get0_group, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 374), (void *)_cffi_d_EC_KEY_get0_group },
  { "EC_KEY_get0_private_key", (void *)_cffi_f_EC_KEY_get0_private_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 154), (void *)_cffi_d_EC_KEY_get0_private_key },
  { "EC_KEY_get0_public_key", (void *)_cffi_f_EC_KEY_get0_public_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 431), (void *)_cffi_d_EC_KEY_get0_public_key },
  { "EC_KEY_get_conv_form", (void *)_cffi_f_EC_KEY_get_conv_form, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2960), (void *)_cffi_d_EC_KEY_get_conv_form },
  { "EC_KEY_get_enc_flags", (void *)_cffi_f_EC_KEY_get_enc_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3014), (void *)_cffi_d_EC_KEY_get_enc_flags },
  { "EC_KEY_get_flags", (void *)_cffi_f_EC_KEY_get_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1717), (void *)_cffi_d_EC_KEY_get_flags },
  { "EC_KEY_new", (void *)_cffi_f_EC_KEY_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 399), (void *)_cffi_d_EC_KEY_new },
  { "EC_KEY_new_by_curve_name", (void *)_cffi_f_EC_KEY_new_by_curve_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 396), (void *)_cffi_d_EC_KEY_new_by_curve_name },
  { "EC_KEY_precompute_mult", (void *)_cffi_f_EC_KEY_precompute_mult, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1695), (void *)_cffi_d_EC_KEY_precompute_mult },
  { "EC_KEY_set_asn1_flag", (void *)_cffi_f_EC_KEY_set_asn1_flag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3272), (void *)_cffi_d_EC_KEY_set_asn1_flag },
  { "EC_KEY_set_conv_form", (void *)_cffi_f_EC_KEY_set_conv_form, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3276), (void *)_cffi_d_EC_KEY_set_conv_form },
  { "EC_KEY_set_enc_flags", (void *)_cffi_f_EC_KEY_set_enc_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3280), (void *)_cffi_d_EC_KEY_set_enc_flags },
  { "EC_KEY_set_flags", (void *)_cffi_f_EC_KEY_set_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3272), (void *)_cffi_d_EC_KEY_set_flags },
  { "EC_KEY_set_group", (void *)_cffi_f_EC_KEY_set_group, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1705), (void *)_cffi_d_EC_KEY_set_group },
  { "EC_KEY_set_private_key", (void *)_cffi_f_EC_KEY_set_private_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1691), (void *)_cffi_d_EC_KEY_set_private_key },
  { "EC_KEY_set_public_key", (void *)_cffi_f_EC_KEY_set_public_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1709), (void *)_cffi_d_EC_KEY_set_public_key },
  { "EC_KEY_set_public_key_affine_coordinates", (void *)_cffi_f_EC_KEY_set_public_key_affine_coordinates, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1686), (void *)_cffi_d_EC_KEY_set_public_key_affine_coordinates },
  { "EC_KEY_up_ref", (void *)_cffi_f_EC_KEY_up_ref, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1683), (void *)_cffi_d_EC_KEY_up_ref },
  { "EC_METHOD_get_field_type", (void *)_cffi_f_EC_METHOD_get_field_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1720), (void *)_cffi_d_EC_METHOD_get_field_type },
  { "EC_POINT_add", (void *)_cffi_f_EC_POINT_add, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1633), (void *)_cffi_d_EC_POINT_add },
  { "EC_POINT_bn2point", (void *)_cffi_f_EC_POINT_bn2point, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 412), (void *)_cffi_d_EC_POINT_bn2point },
  { "EC_POINT_clear_free", (void *)_cffi_f_EC_POINT_clear_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3284), (void *)_cffi_d_EC_POINT_clear_free },
  { "EC_POINT_cmp", (void *)_cffi_f_EC_POINT_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1671), (void *)_cffi_d_EC_POINT_cmp },
  { "EC_POINT_copy", (void *)_cffi_f_EC_POINT_copy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1723), (void *)_cffi_d_EC_POINT_copy },
  { "EC_POINT_dbl", (void *)_cffi_f_EC_POINT_dbl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1627), (void *)_cffi_d_EC_POINT_dbl },
  { "EC_POINT_dup", (void *)_cffi_f_EC_POINT_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 424), (void *)_cffi_d_EC_POINT_dup },
  { "EC_POINT_free", (void *)_cffi_f_EC_POINT_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3284), (void *)_cffi_d_EC_POINT_free },
  { "EC_POINT_get_Jprojective_coordinates_GFp", (void *)_cffi_f_EC_POINT_get_Jprojective_coordinates_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1651), (void *)_cffi_d_EC_POINT_get_Jprojective_coordinates_GFp },
  { "EC_POINT_get_affine_coordinates_GF2m", (void *)_cffi_f_EC_POINT_get_affine_coordinates_GF2m, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1659), (void *)_cffi_d_EC_POINT_get_affine_coordinates_GF2m },
  { "EC_POINT_get_affine_coordinates_GFp", (void *)_cffi_f_EC_POINT_get_affine_coordinates_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1659), (void *)_cffi_d_EC_POINT_get_affine_coordinates_GFp },
  { "EC_POINT_hex2point", (void *)_cffi_f_EC_POINT_hex2point, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 418), (void *)_cffi_d_EC_POINT_hex2point },
  { "EC_POINT_invert", (void *)_cffi_f_EC_POINT_invert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1622), (void *)_cffi_d_EC_POINT_invert },
  { "EC_POINT_is_at_infinity", (void *)_cffi_f_EC_POINT_is_at_infinity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1647), (void *)_cffi_d_EC_POINT_is_at_infinity },
  { "EC_POINT_is_on_curve", (void *)_cffi_f_EC_POINT_is_on_curve, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1666), (void *)_cffi_d_EC_POINT_is_on_curve },
  { "EC_POINT_make_affine", (void *)_cffi_f_EC_POINT_make_affine, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1622), (void *)_cffi_d_EC_POINT_make_affine },
  { "EC_POINT_method_of", (void *)_cffi_f_EC_POINT_method_of, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 404), (void *)_cffi_d_EC_POINT_method_of },
  { "EC_POINT_mul", (void *)_cffi_f_EC_POINT_mul, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1598), (void *)_cffi_d_EC_POINT_mul },
  { "EC_POINT_new", (void *)_cffi_f_EC_POINT_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 409), (void *)_cffi_d_EC_POINT_new },
  { "EC_POINT_oct2point", (void *)_cffi_f_EC_POINT_oct2point, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1640), (void *)_cffi_d_EC_POINT_oct2point },
  { "EC_POINT_point2bn", (void *)_cffi_f_EC_POINT_point2bn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 140), (void *)_cffi_d_EC_POINT_point2bn },
  { "EC_POINT_point2hex", (void *)_cffi_f_EC_POINT_point2hex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 912), (void *)_cffi_d_EC_POINT_point2hex },
  { "EC_POINT_point2oct", (void *)_cffi_f_EC_POINT_point2oct, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2969), (void *)_cffi_d_EC_POINT_point2oct },
  { "EC_POINT_set_Jprojective_coordinates_GFp", (void *)_cffi_f_EC_POINT_set_Jprojective_coordinates_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1583), (void *)_cffi_d_EC_POINT_set_Jprojective_coordinates_GFp },
  { "EC_POINT_set_affine_coordinates_GF2m", (void *)_cffi_f_EC_POINT_set_affine_coordinates_GF2m, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1591), (void *)_cffi_d_EC_POINT_set_affine_coordinates_GF2m },
  { "EC_POINT_set_affine_coordinates_GFp", (void *)_cffi_f_EC_POINT_set_affine_coordinates_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1591), (void *)_cffi_d_EC_POINT_set_affine_coordinates_GFp },
  { "EC_POINT_set_compressed_coordinates_GF2m", (void *)_cffi_f_EC_POINT_set_compressed_coordinates_GF2m, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1606), (void *)_cffi_d_EC_POINT_set_compressed_coordinates_GF2m },
  { "EC_POINT_set_compressed_coordinates_GFp", (void *)_cffi_f_EC_POINT_set_compressed_coordinates_GFp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1606), (void *)_cffi_d_EC_POINT_set_compressed_coordinates_GFp },
  { "EC_POINT_set_to_infinity", (void *)_cffi_f_EC_POINT_set_to_infinity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1579), (void *)_cffi_d_EC_POINT_set_to_infinity },
  { "EC_POINTs_make_affine", (void *)_cffi_f_EC_POINTs_make_affine, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1677), (void *)_cffi_d_EC_POINTs_make_affine },
  { "EC_POINTs_mul", (void *)_cffi_f_EC_POINTs_mul, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1613), (void *)_cffi_d_EC_POINTs_mul },
  { "EC_R_UNKNOWN_GROUP", (void *)_cffi_const_EC_R_UNKNOWN_GROUP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EC_curve_nid2nist", (void *)_cffi_f_EC_curve_nid2nist, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 958), (void *)_cffi_d_EC_curve_nid2nist },
  { "EC_get_builtin_curves", (void *)_cffi_f_EC_get_builtin_curves, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2977), (void *)_cffi_d_EC_get_builtin_curves },
  { "ENGINE_METHOD_ALL", (void *)_cffi_const_ENGINE_METHOD_ALL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_METHOD_CIPHERS", (void *)_cffi_const_ENGINE_METHOD_CIPHERS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_METHOD_DIGESTS", (void *)_cffi_const_ENGINE_METHOD_DIGESTS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_METHOD_DSA", (void *)_cffi_const_ENGINE_METHOD_DSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_METHOD_NONE", (void *)_cffi_const_ENGINE_METHOD_NONE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_METHOD_RAND", (void *)_cffi_const_ENGINE_METHOD_RAND, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_METHOD_RSA", (void *)_cffi_const_ENGINE_METHOD_RSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_R_CONFLICTING_ENGINE_ID", (void *)_cffi_const_ENGINE_R_CONFLICTING_ENGINE_ID, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ENGINE_add", (void *)_cffi_f_ENGINE_add, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_add },
  { "ENGINE_add_conf_module", (void *)_cffi_f_ENGINE_add_conf_module, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_add_conf_module },
  { "ENGINE_by_id", (void *)_cffi_f_ENGINE_by_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 437), (void *)_cffi_d_ENGINE_by_id },
  { "ENGINE_cleanup", (void *)_cffi_f_ENGINE_cleanup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_cleanup },
  { "ENGINE_cmd_is_executable", (void *)_cffi_f_ENGINE_cmd_is_executable, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1788), (void *)_cffi_d_ENGINE_cmd_is_executable },
  { "ENGINE_ctrl", (void *)_cffi_f_ENGINE_ctrl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1792), (void *)_cffi_d_ENGINE_ctrl },
  { "ENGINE_ctrl_cmd", (void *)_cffi_f_ENGINE_ctrl_cmd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1776), (void *)_cffi_d_ENGINE_ctrl_cmd },
  { "ENGINE_ctrl_cmd_string", (void *)_cffi_f_ENGINE_ctrl_cmd_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1770), (void *)_cffi_d_ENGINE_ctrl_cmd_string },
  { "ENGINE_finish", (void *)_cffi_f_ENGINE_finish, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_finish },
  { "ENGINE_free", (void *)_cffi_f_ENGINE_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_free },
  { "ENGINE_get_DH", (void *)_cffi_f_ENGINE_get_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_ENGINE_get_DH },
  { "ENGINE_get_DSA", (void *)_cffi_f_ENGINE_get_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ENGINE_get_DSA },
  { "ENGINE_get_RAND", (void *)_cffi_f_ENGINE_get_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 650), (void *)_cffi_d_ENGINE_get_RAND },
  { "ENGINE_get_RSA", (void *)_cffi_f_ENGINE_get_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 676), (void *)_cffi_d_ENGINE_get_RSA },
  { "ENGINE_get_cipher", (void *)_cffi_f_ENGINE_get_cipher, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 450), (void *)_cffi_d_ENGINE_get_cipher },
  { "ENGINE_get_cipher_engine", (void *)_cffi_f_ENGINE_get_cipher_engine, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 440), (void *)_cffi_d_ENGINE_get_cipher_engine },
  { "ENGINE_get_cmd_defns", (void *)_cffi_f_ENGINE_get_cmd_defns, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 445), (void *)_cffi_d_ENGINE_get_cmd_defns },
  { "ENGINE_get_default_DH", (void *)_cffi_f_ENGINE_get_default_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_get_default_DH },
  { "ENGINE_get_default_DSA", (void *)_cffi_f_ENGINE_get_default_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_get_default_DSA },
  { "ENGINE_get_default_RAND", (void *)_cffi_f_ENGINE_get_default_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_get_default_RAND },
  { "ENGINE_get_default_RSA", (void *)_cffi_f_ENGINE_get_default_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_get_default_RSA },
  { "ENGINE_get_digest", (void *)_cffi_f_ENGINE_get_digest, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 462), (void *)_cffi_d_ENGINE_get_digest },
  { "ENGINE_get_digest_engine", (void *)_cffi_f_ENGINE_get_digest_engine, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 440), (void *)_cffi_d_ENGINE_get_digest_engine },
  { "ENGINE_get_first", (void *)_cffi_f_ENGINE_get_first, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_get_first },
  { "ENGINE_get_flags", (void *)_cffi_f_ENGINE_get_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1803), (void *)_cffi_d_ENGINE_get_flags },
  { "ENGINE_get_id", (void *)_cffi_f_ENGINE_get_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 941), (void *)_cffi_d_ENGINE_get_id },
  { "ENGINE_get_last", (void *)_cffi_f_ENGINE_get_last, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_get_last },
  { "ENGINE_get_name", (void *)_cffi_f_ENGINE_get_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 941), (void *)_cffi_d_ENGINE_get_name },
  { "ENGINE_get_next", (void *)_cffi_f_ENGINE_get_next, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 434), (void *)_cffi_d_ENGINE_get_next },
  { "ENGINE_get_prev", (void *)_cffi_f_ENGINE_get_prev, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 434), (void *)_cffi_d_ENGINE_get_prev },
  { "ENGINE_get_table_flags", (void *)_cffi_f_ENGINE_get_table_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3017), (void *)_cffi_d_ENGINE_get_table_flags },
  { "ENGINE_init", (void *)_cffi_f_ENGINE_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_init },
  { "ENGINE_load_builtin_engines", (void *)_cffi_f_ENGINE_load_builtin_engines, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_load_builtin_engines },
  { "ENGINE_load_cryptodev", (void *)_cffi_f_ENGINE_load_cryptodev, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_load_cryptodev },
  { "ENGINE_load_dynamic", (void *)_cffi_f_ENGINE_load_dynamic, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_load_dynamic },
  { "ENGINE_load_openssl", (void *)_cffi_f_ENGINE_load_openssl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_load_openssl },
  { "ENGINE_load_private_key", (void *)_cffi_f_ENGINE_load_private_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 486), (void *)_cffi_d_ENGINE_load_private_key },
  { "ENGINE_load_public_key", (void *)_cffi_f_ENGINE_load_public_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 486), (void *)_cffi_d_ENGINE_load_public_key },
  { "ENGINE_new", (void *)_cffi_f_ENGINE_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 443), (void *)_cffi_d_ENGINE_new },
  { "ENGINE_register_DH", (void *)_cffi_f_ENGINE_register_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_DH },
  { "ENGINE_register_DSA", (void *)_cffi_f_ENGINE_register_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_DSA },
  { "ENGINE_register_RAND", (void *)_cffi_f_ENGINE_register_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_RAND },
  { "ENGINE_register_RSA", (void *)_cffi_f_ENGINE_register_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_RSA },
  { "ENGINE_register_all_DH", (void *)_cffi_f_ENGINE_register_all_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_register_all_DH },
  { "ENGINE_register_all_DSA", (void *)_cffi_f_ENGINE_register_all_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_register_all_DSA },
  { "ENGINE_register_all_RAND", (void *)_cffi_f_ENGINE_register_all_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_register_all_RAND },
  { "ENGINE_register_all_RSA", (void *)_cffi_f_ENGINE_register_all_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_register_all_RSA },
  { "ENGINE_register_all_ciphers", (void *)_cffi_f_ENGINE_register_all_ciphers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_register_all_ciphers },
  { "ENGINE_register_all_complete", (void *)_cffi_f_ENGINE_register_all_complete, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_ENGINE_register_all_complete },
  { "ENGINE_register_all_digests", (void *)_cffi_f_ENGINE_register_all_digests, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ENGINE_register_all_digests },
  { "ENGINE_register_ciphers", (void *)_cffi_f_ENGINE_register_ciphers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_ciphers },
  { "ENGINE_register_complete", (void *)_cffi_f_ENGINE_register_complete, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_complete },
  { "ENGINE_register_digests", (void *)_cffi_f_ENGINE_register_digests, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_register_digests },
  { "ENGINE_remove", (void *)_cffi_f_ENGINE_remove, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_remove },
  { "ENGINE_set_DH", (void *)_cffi_f_ENGINE_set_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1730), (void *)_cffi_d_ENGINE_set_DH },
  { "ENGINE_set_DSA", (void *)_cffi_f_ENGINE_set_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1734), (void *)_cffi_d_ENGINE_set_DSA },
  { "ENGINE_set_RAND", (void *)_cffi_f_ENGINE_set_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1758), (void *)_cffi_d_ENGINE_set_RAND },
  { "ENGINE_set_RSA", (void *)_cffi_f_ENGINE_set_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1762), (void *)_cffi_d_ENGINE_set_RSA },
  { "ENGINE_set_ciphers", (void *)_cffi_f_ENGINE_set_ciphers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1738), (void *)_cffi_d_ENGINE_set_ciphers },
  { "ENGINE_set_cmd_defns", (void *)_cffi_f_ENGINE_set_cmd_defns, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1742), (void *)_cffi_d_ENGINE_set_cmd_defns },
  { "ENGINE_set_ctrl_function", (void *)_cffi_f_ENGINE_set_ctrl_function, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1746), (void *)_cffi_d_ENGINE_set_ctrl_function },
  { "ENGINE_set_default", (void *)_cffi_f_ENGINE_set_default, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1799), (void *)_cffi_d_ENGINE_set_default },
  { "ENGINE_set_default_DH", (void *)_cffi_f_ENGINE_set_default_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_set_default_DH },
  { "ENGINE_set_default_DSA", (void *)_cffi_f_ENGINE_set_default_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_set_default_DSA },
  { "ENGINE_set_default_RAND", (void *)_cffi_f_ENGINE_set_default_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_set_default_RAND },
  { "ENGINE_set_default_RSA", (void *)_cffi_f_ENGINE_set_default_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_set_default_RSA },
  { "ENGINE_set_default_ciphers", (void *)_cffi_f_ENGINE_set_default_ciphers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_set_default_ciphers },
  { "ENGINE_set_default_digests", (void *)_cffi_f_ENGINE_set_default_digests, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_set_default_digests },
  { "ENGINE_set_default_string", (void *)_cffi_f_ENGINE_set_default_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1766), (void *)_cffi_d_ENGINE_set_default_string },
  { "ENGINE_set_destroy_function", (void *)_cffi_f_ENGINE_set_destroy_function, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1784), (void *)_cffi_d_ENGINE_set_destroy_function },
  { "ENGINE_set_digests", (void *)_cffi_f_ENGINE_set_digests, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1750), (void *)_cffi_d_ENGINE_set_digests },
  { "ENGINE_set_finish_function", (void *)_cffi_f_ENGINE_set_finish_function, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1784), (void *)_cffi_d_ENGINE_set_finish_function },
  { "ENGINE_set_flags", (void *)_cffi_f_ENGINE_set_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1788), (void *)_cffi_d_ENGINE_set_flags },
  { "ENGINE_set_id", (void *)_cffi_f_ENGINE_set_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1766), (void *)_cffi_d_ENGINE_set_id },
  { "ENGINE_set_init_function", (void *)_cffi_f_ENGINE_set_init_function, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1784), (void *)_cffi_d_ENGINE_set_init_function },
  { "ENGINE_set_load_privkey_function", (void *)_cffi_f_ENGINE_set_load_privkey_function, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1754), (void *)_cffi_d_ENGINE_set_load_privkey_function },
  { "ENGINE_set_load_pubkey_function", (void *)_cffi_f_ENGINE_set_load_pubkey_function, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1754), (void *)_cffi_d_ENGINE_set_load_pubkey_function },
  { "ENGINE_set_name", (void *)_cffi_f_ENGINE_set_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1766), (void *)_cffi_d_ENGINE_set_name },
  { "ENGINE_set_table_flags", (void *)_cffi_f_ENGINE_set_table_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3594), (void *)_cffi_d_ENGINE_set_table_flags },
  { "ENGINE_unregister_DH", (void *)_cffi_f_ENGINE_unregister_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3287), (void *)_cffi_d_ENGINE_unregister_DH },
  { "ENGINE_unregister_DSA", (void *)_cffi_f_ENGINE_unregister_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3287), (void *)_cffi_d_ENGINE_unregister_DSA },
  { "ENGINE_unregister_RAND", (void *)_cffi_f_ENGINE_unregister_RAND, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3287), (void *)_cffi_d_ENGINE_unregister_RAND },
  { "ENGINE_unregister_RSA", (void *)_cffi_f_ENGINE_unregister_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3287), (void *)_cffi_d_ENGINE_unregister_RSA },
  { "ENGINE_unregister_ciphers", (void *)_cffi_f_ENGINE_unregister_ciphers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3287), (void *)_cffi_d_ENGINE_unregister_ciphers },
  { "ENGINE_unregister_digests", (void *)_cffi_f_ENGINE_unregister_digests, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3287), (void *)_cffi_d_ENGINE_unregister_digests },
  { "ENGINE_up_ref", (void *)_cffi_f_ENGINE_up_ref, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1727), (void *)_cffi_d_ENGINE_up_ref },
  { "ERR_GET_FUNC", (void *)_cffi_f_ERR_GET_FUNC, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2815), (void *)_cffi_d_ERR_GET_FUNC },
  { "ERR_GET_LIB", (void *)_cffi_f_ERR_GET_LIB, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2815), (void *)_cffi_d_ERR_GET_LIB },
  { "ERR_GET_REASON", (void *)_cffi_f_ERR_GET_REASON, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2815), (void *)_cffi_d_ERR_GET_REASON },
  { "ERR_LIB_ASN1", (void *)_cffi_const_ERR_LIB_ASN1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_DH", (void *)_cffi_const_ERR_LIB_DH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_EC", (void *)_cffi_const_ERR_LIB_EC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_EVP", (void *)_cffi_const_ERR_LIB_EVP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_PEM", (void *)_cffi_const_ERR_LIB_PEM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_PKCS12", (void *)_cffi_const_ERR_LIB_PKCS12, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_RSA", (void *)_cffi_const_ERR_LIB_RSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_SSL", (void *)_cffi_const_ERR_LIB_SSL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_LIB_X509", (void *)_cffi_const_ERR_LIB_X509, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "ERR_PACK", (void *)_cffi_f_ERR_PACK, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3064), (void *)_cffi_d_ERR_PACK },
  { "ERR_add_error_data", (void *)_cffi_const_ERR_add_error_data, _CFFI_OP(_CFFI_OP_CONSTANT, 3794), (void *)0 },
  { "ERR_clear_error", (void *)_cffi_f_ERR_clear_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ERR_clear_error },
  { "ERR_error_string", (void *)_cffi_f_ERR_error_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 934), (void *)_cffi_d_ERR_error_string },
  { "ERR_error_string_n", (void *)_cffi_f_ERR_error_string_n, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3597), (void *)_cffi_d_ERR_error_string_n },
  { "ERR_free_strings", (void *)_cffi_f_ERR_free_strings, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ERR_free_strings },
  { "ERR_func_error_string", (void *)_cffi_f_ERR_func_error_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 964), (void *)_cffi_d_ERR_func_error_string },
  { "ERR_get_error", (void *)_cffi_f_ERR_get_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3069), (void *)_cffi_d_ERR_get_error },
  { "ERR_get_error_line", (void *)_cffi_f_ERR_get_error_line, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3054), (void *)_cffi_d_ERR_get_error_line },
  { "ERR_get_error_line_data", (void *)_cffi_f_ERR_get_error_line_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3058), (void *)_cffi_d_ERR_get_error_line_data },
  { "ERR_get_next_error_library", (void *)_cffi_f_ERR_get_next_error_library, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_ERR_get_next_error_library },
  { "ERR_get_state", (void *)_cffi_f_ERR_get_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 448), (void *)_cffi_d_ERR_get_state },
  { "ERR_lib_error_string", (void *)_cffi_f_ERR_lib_error_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 964), (void *)_cffi_d_ERR_lib_error_string },
  { "ERR_load_RAND_strings", (void *)_cffi_f_ERR_load_RAND_strings, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_ERR_load_RAND_strings },
  { "ERR_peek_error", (void *)_cffi_f_ERR_peek_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3069), (void *)_cffi_d_ERR_peek_error },
  { "ERR_peek_error_line", (void *)_cffi_f_ERR_peek_error_line, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3054), (void *)_cffi_d_ERR_peek_error_line },
  { "ERR_peek_error_line_data", (void *)_cffi_f_ERR_peek_error_line_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3058), (void *)_cffi_d_ERR_peek_error_line_data },
  { "ERR_peek_last_error", (void *)_cffi_f_ERR_peek_last_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3069), (void *)_cffi_d_ERR_peek_last_error },
  { "ERR_peek_last_error_line", (void *)_cffi_f_ERR_peek_last_error_line, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3054), (void *)_cffi_d_ERR_peek_last_error_line },
  { "ERR_peek_last_error_line_data", (void *)_cffi_f_ERR_peek_last_error_line_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3058), (void *)_cffi_d_ERR_peek_last_error_line_data },
  { "ERR_print_errors", (void *)_cffi_f_ERR_print_errors, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3163), (void *)_cffi_d_ERR_print_errors },
  { "ERR_print_errors_fp", (void *)_cffi_f_ERR_print_errors_fp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3302), (void *)_cffi_d_ERR_print_errors_fp },
  { "ERR_put_error", (void *)_cffi_f_ERR_put_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3582), (void *)_cffi_d_ERR_put_error },
  { "ERR_reason_error_string", (void *)_cffi_f_ERR_reason_error_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 964), (void *)_cffi_d_ERR_reason_error_string },
  { "EVP_CIPHER_CTX_block_size", (void *)_cffi_f_EVP_CIPHER_CTX_block_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1849), (void *)_cffi_d_EVP_CIPHER_CTX_block_size },
  { "EVP_CIPHER_CTX_cipher", (void *)_cffi_f_EVP_CIPHER_CTX_cipher, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 454), (void *)_cffi_d_EVP_CIPHER_CTX_cipher },
  { "EVP_CIPHER_CTX_cleanup", (void *)_cffi_f_EVP_CIPHER_CTX_cleanup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1809), (void *)_cffi_d_EVP_CIPHER_CTX_cleanup },
  { "EVP_CIPHER_CTX_ctrl", (void *)_cffi_f_EVP_CIPHER_CTX_ctrl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1831), (void *)_cffi_d_EVP_CIPHER_CTX_ctrl },
  { "EVP_CIPHER_CTX_free", (void *)_cffi_f_EVP_CIPHER_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3290), (void *)_cffi_d_EVP_CIPHER_CTX_free },
  { "EVP_CIPHER_CTX_init", (void *)_cffi_f_EVP_CIPHER_CTX_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3290), (void *)_cffi_d_EVP_CIPHER_CTX_init },
  { "EVP_CIPHER_CTX_new", (void *)_cffi_f_EVP_CIPHER_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 460), (void *)_cffi_d_EVP_CIPHER_CTX_new },
  { "EVP_CIPHER_CTX_set_key_length", (void *)_cffi_f_EVP_CIPHER_CTX_set_key_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1827), (void *)_cffi_d_EVP_CIPHER_CTX_set_key_length },
  { "EVP_CIPHER_CTX_set_padding", (void *)_cffi_f_EVP_CIPHER_CTX_set_padding, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1827), (void *)_cffi_d_EVP_CIPHER_CTX_set_padding },
  { "EVP_CIPHER_block_size", (void *)_cffi_f_EVP_CIPHER_block_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1806), (void *)_cffi_d_EVP_CIPHER_block_size },
  { "EVP_CTRL_GCM_GET_TAG", (void *)_cffi_const_EVP_CTRL_GCM_GET_TAG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_CTRL_GCM_SET_IVLEN", (void *)_cffi_const_EVP_CTRL_GCM_SET_IVLEN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_CTRL_GCM_SET_TAG", (void *)_cffi_const_EVP_CTRL_GCM_SET_TAG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_CipherFinal_ex", (void *)_cffi_f_EVP_CipherFinal_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1837), (void *)_cffi_d_EVP_CipherFinal_ex },
  { "EVP_CipherInit_ex", (void *)_cffi_f_EVP_CipherInit_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1819), (void *)_cffi_d_EVP_CipherInit_ex },
  { "EVP_CipherUpdate", (void *)_cffi_f_EVP_CipherUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1842), (void *)_cffi_d_EVP_CipherUpdate },
  { "EVP_DecryptFinal_ex", (void *)_cffi_f_EVP_DecryptFinal_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1837), (void *)_cffi_d_EVP_DecryptFinal_ex },
  { "EVP_DecryptInit_ex", (void *)_cffi_f_EVP_DecryptInit_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1812), (void *)_cffi_d_EVP_DecryptInit_ex },
  { "EVP_DecryptUpdate", (void *)_cffi_f_EVP_DecryptUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1842), (void *)_cffi_d_EVP_DecryptUpdate },
  { "EVP_DigestFinal_ex", (void *)_cffi_f_EVP_DigestFinal_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1868), (void *)_cffi_d_EVP_DigestFinal_ex },
  { "EVP_DigestInit_ex", (void *)_cffi_f_EVP_DigestInit_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1859), (void *)_cffi_d_EVP_DigestInit_ex },
  { "EVP_DigestUpdate", (void *)_cffi_f_EVP_DigestUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1885), (void *)_cffi_d_EVP_DigestUpdate },
  { "EVP_EncryptFinal_ex", (void *)_cffi_f_EVP_EncryptFinal_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1837), (void *)_cffi_d_EVP_EncryptFinal_ex },
  { "EVP_EncryptInit_ex", (void *)_cffi_f_EVP_EncryptInit_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1812), (void *)_cffi_d_EVP_EncryptInit_ex },
  { "EVP_EncryptUpdate", (void *)_cffi_f_EVP_EncryptUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1842), (void *)_cffi_d_EVP_EncryptUpdate },
  { "EVP_F_AES_INIT_KEY", (void *)_cffi_const_EVP_F_AES_INIT_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_CAMELLIA_INIT_KEY", (void *)_cffi_const_EVP_F_CAMELLIA_INIT_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_CIPHERINIT_EX", (void *)_cffi_const_EVP_F_EVP_CIPHERINIT_EX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_CIPHER_CTX_CTRL", (void *)_cffi_const_EVP_F_EVP_CIPHER_CTX_CTRL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH", (void *)_cffi_const_EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_DECRYPTFINAL_EX", (void *)_cffi_const_EVP_F_EVP_DECRYPTFINAL_EX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_DIGESTINIT_EX", (void *)_cffi_const_EVP_F_EVP_DIGESTINIT_EX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_ENCRYPTFINAL_EX", (void *)_cffi_const_EVP_F_EVP_ENCRYPTFINAL_EX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_MD_CTX_COPY_EX", (void *)_cffi_const_EVP_F_EVP_MD_CTX_COPY_EX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_OPENINIT", (void *)_cffi_const_EVP_F_EVP_OPENINIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PBE_ALG_ADD", (void *)_cffi_const_EVP_F_EVP_PBE_ALG_ADD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PBE_CIPHERINIT", (void *)_cffi_const_EVP_F_EVP_PBE_CIPHERINIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PKCS82PKEY", (void *)_cffi_const_EVP_F_EVP_PKCS82PKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PKEY_COPY_PARAMETERS", (void *)_cffi_const_EVP_F_EVP_PKEY_COPY_PARAMETERS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PKEY_DECRYPT", (void *)_cffi_const_EVP_F_EVP_PKEY_DECRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PKEY_ENCRYPT", (void *)_cffi_const_EVP_F_EVP_PKEY_ENCRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_PKEY_NEW", (void *)_cffi_const_EVP_F_EVP_PKEY_NEW, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_SIGNFINAL", (void *)_cffi_const_EVP_F_EVP_SIGNFINAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_EVP_VERIFYFINAL", (void *)_cffi_const_EVP_F_EVP_VERIFYFINAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_PKCS5_PBE_KEYIVGEN", (void *)_cffi_const_EVP_F_PKCS5_PBE_KEYIVGEN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_PKCS5_V2_PBE_KEYIVGEN", (void *)_cffi_const_EVP_F_PKCS5_V2_PBE_KEYIVGEN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_RC2_MAGIC_TO_METH", (void *)_cffi_const_EVP_F_RC2_MAGIC_TO_METH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_F_RC5_CTRL", (void *)_cffi_const_EVP_F_RC5_CTRL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_MAX_MD_SIZE", (void *)_cffi_const_EVP_MAX_MD_SIZE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_MD_CTX_block_size", (void *)_cffi_f_EVP_MD_CTX_block_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1890), (void *)_cffi_d_EVP_MD_CTX_block_size },
  { "EVP_MD_CTX_copy_ex", (void *)_cffi_f_EVP_MD_CTX_copy_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1864), (void *)_cffi_d_EVP_MD_CTX_copy_ex },
  { "EVP_MD_CTX_md", (void *)_cffi_f_EVP_MD_CTX_md, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 466), (void *)_cffi_d_EVP_MD_CTX_md },
  { "EVP_MD_size", (void *)_cffi_f_EVP_MD_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1852), (void *)_cffi_d_EVP_MD_size },
  { "EVP_PBE_scrypt", (void *)_cffi_f_EVP_PBE_scrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2670), (void *)_cffi_d_EVP_PBE_scrypt },
  { "EVP_PKCS82PKEY", (void *)_cffi_f_EVP_PKCS82PKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 495), (void *)_cffi_d_EVP_PKCS82PKEY },
  { "EVP_PKEY_CTX_dup", (void *)_cffi_f_EVP_PKEY_CTX_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 510), (void *)_cffi_d_EVP_PKEY_CTX_dup },
  { "EVP_PKEY_CTX_free", (void *)_cffi_f_EVP_PKEY_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3299), (void *)_cffi_d_EVP_PKEY_CTX_free },
  { "EVP_PKEY_CTX_new", (void *)_cffi_f_EVP_PKEY_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 506), (void *)_cffi_d_EVP_PKEY_CTX_new },
  { "EVP_PKEY_CTX_new_id", (void *)_cffi_f_EVP_PKEY_CTX_new_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 513), (void *)_cffi_d_EVP_PKEY_CTX_new_id },
  { "EVP_PKEY_CTX_set_rsa_mgf1_md", (void *)_cffi_f_EVP_PKEY_CTX_set_rsa_mgf1_md, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1952), (void *)_cffi_d_EVP_PKEY_CTX_set_rsa_mgf1_md },
  { "EVP_PKEY_CTX_set_rsa_oaep_md", (void *)_cffi_f_EVP_PKEY_CTX_set_rsa_oaep_md, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1952), (void *)_cffi_d_EVP_PKEY_CTX_set_rsa_oaep_md },
  { "EVP_PKEY_CTX_set_rsa_padding", (void *)_cffi_f_EVP_PKEY_CTX_set_rsa_padding, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1960), (void *)_cffi_d_EVP_PKEY_CTX_set_rsa_padding },
  { "EVP_PKEY_CTX_set_rsa_pss_saltlen", (void *)_cffi_f_EVP_PKEY_CTX_set_rsa_pss_saltlen, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1960), (void *)_cffi_d_EVP_PKEY_CTX_set_rsa_pss_saltlen },
  { "EVP_PKEY_CTX_set_signature_md", (void *)_cffi_f_EVP_PKEY_CTX_set_signature_md, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1956), (void *)_cffi_d_EVP_PKEY_CTX_set_signature_md },
  { "EVP_PKEY_DH", (void *)_cffi_const_EVP_PKEY_DH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_PKEY_DHX", (void *)_cffi_const_EVP_PKEY_DHX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_PKEY_DSA", (void *)_cffi_const_EVP_PKEY_DSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_PKEY_EC", (void *)_cffi_const_EVP_PKEY_EC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_PKEY_RSA", (void *)_cffi_const_EVP_PKEY_RSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_PKEY_add1_attr", (void *)_cffi_f_EVP_PKEY_add1_attr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1919), (void *)_cffi_d_EVP_PKEY_add1_attr },
  { "EVP_PKEY_add1_attr_by_NID", (void *)_cffi_f_EVP_PKEY_add1_attr_by_NID, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1930), (void *)_cffi_d_EVP_PKEY_add1_attr_by_NID },
  { "EVP_PKEY_add1_attr_by_OBJ", (void *)_cffi_f_EVP_PKEY_add1_attr_by_OBJ, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1896), (void *)_cffi_d_EVP_PKEY_add1_attr_by_OBJ },
  { "EVP_PKEY_add1_attr_by_txt", (void *)_cffi_f_EVP_PKEY_add1_attr_by_txt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1923), (void *)_cffi_d_EVP_PKEY_add1_attr_by_txt },
  { "EVP_PKEY_assign_DSA", (void *)_cffi_f_EVP_PKEY_assign_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1907), (void *)_cffi_d_EVP_PKEY_assign_DSA },
  { "EVP_PKEY_assign_EC_KEY", (void *)_cffi_f_EVP_PKEY_assign_EC_KEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1911), (void *)_cffi_d_EVP_PKEY_assign_EC_KEY },
  { "EVP_PKEY_assign_RSA", (void *)_cffi_f_EVP_PKEY_assign_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1915), (void *)_cffi_d_EVP_PKEY_assign_RSA },
  { "EVP_PKEY_bits", (void *)_cffi_f_EVP_PKEY_bits, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1893), (void *)_cffi_d_EVP_PKEY_bits },
  { "EVP_PKEY_cmp", (void *)_cffi_f_EVP_PKEY_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1940), (void *)_cffi_d_EVP_PKEY_cmp },
  { "EVP_PKEY_decrypt", (void *)_cffi_f_EVP_PKEY_decrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1964), (void *)_cffi_d_EVP_PKEY_decrypt },
  { "EVP_PKEY_decrypt_init", (void *)_cffi_f_EVP_PKEY_decrypt_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1949), (void *)_cffi_d_EVP_PKEY_decrypt_init },
  { "EVP_PKEY_delete_attr", (void *)_cffi_f_EVP_PKEY_delete_attr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 753), (void *)_cffi_d_EVP_PKEY_delete_attr },
  { "EVP_PKEY_encrypt", (void *)_cffi_f_EVP_PKEY_encrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1964), (void *)_cffi_d_EVP_PKEY_encrypt },
  { "EVP_PKEY_encrypt_init", (void *)_cffi_f_EVP_PKEY_encrypt_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1949), (void *)_cffi_d_EVP_PKEY_encrypt_init },
  { "EVP_PKEY_free", (void *)_cffi_f_EVP_PKEY_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3296), (void *)_cffi_d_EVP_PKEY_free },
  { "EVP_PKEY_get1_DH", (void *)_cffi_f_EVP_PKEY_get1_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 301), (void *)_cffi_d_EVP_PKEY_get1_DH },
  { "EVP_PKEY_get1_DSA", (void *)_cffi_f_EVP_PKEY_get1_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 335), (void *)_cffi_d_EVP_PKEY_get1_DSA },
  { "EVP_PKEY_get1_EC_KEY", (void *)_cffi_f_EVP_PKEY_get1_EC_KEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 393), (void *)_cffi_d_EVP_PKEY_get1_EC_KEY },
  { "EVP_PKEY_get1_RSA", (void *)_cffi_f_EVP_PKEY_get1_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 663), (void *)_cffi_d_EVP_PKEY_get1_RSA },
  { "EVP_PKEY_get_attr", (void *)_cffi_f_EVP_PKEY_get_attr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 757), (void *)_cffi_d_EVP_PKEY_get_attr },
  { "EVP_PKEY_get_attr_by_NID", (void *)_cffi_f_EVP_PKEY_get_attr_by_NID, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1944), (void *)_cffi_d_EVP_PKEY_get_attr_by_NID },
  { "EVP_PKEY_get_attr_count", (void *)_cffi_f_EVP_PKEY_get_attr_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1937), (void *)_cffi_d_EVP_PKEY_get_attr_count },
  { "EVP_PKEY_id", (void *)_cffi_f_EVP_PKEY_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1937), (void *)_cffi_d_EVP_PKEY_id },
  { "EVP_PKEY_new", (void *)_cffi_f_EVP_PKEY_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 504), (void *)_cffi_d_EVP_PKEY_new },
  { "EVP_PKEY_set1_DH", (void *)_cffi_f_EVP_PKEY_set1_DH, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1903), (void *)_cffi_d_EVP_PKEY_set1_DH },
  { "EVP_PKEY_set1_DSA", (void *)_cffi_f_EVP_PKEY_set1_DSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1907), (void *)_cffi_d_EVP_PKEY_set1_DSA },
  { "EVP_PKEY_set1_EC_KEY", (void *)_cffi_f_EVP_PKEY_set1_EC_KEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1911), (void *)_cffi_d_EVP_PKEY_set1_EC_KEY },
  { "EVP_PKEY_set1_RSA", (void *)_cffi_f_EVP_PKEY_set1_RSA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1915), (void *)_cffi_d_EVP_PKEY_set1_RSA },
  { "EVP_PKEY_sign", (void *)_cffi_f_EVP_PKEY_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1964), (void *)_cffi_d_EVP_PKEY_sign },
  { "EVP_PKEY_sign_init", (void *)_cffi_f_EVP_PKEY_sign_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1949), (void *)_cffi_d_EVP_PKEY_sign_init },
  { "EVP_PKEY_size", (void *)_cffi_f_EVP_PKEY_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1893), (void *)_cffi_d_EVP_PKEY_size },
  { "EVP_PKEY_type", (void *)_cffi_f_EVP_PKEY_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2687), (void *)_cffi_d_EVP_PKEY_type },
  { "EVP_PKEY_verify", (void *)_cffi_f_EVP_PKEY_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1971), (void *)_cffi_d_EVP_PKEY_verify },
  { "EVP_PKEY_verify_init", (void *)_cffi_f_EVP_PKEY_verify_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1949), (void *)_cffi_d_EVP_PKEY_verify_init },
  { "EVP_R_AES_KEY_SETUP_FAILED", (void *)_cffi_const_EVP_R_AES_KEY_SETUP_FAILED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_BAD_DECRYPT", (void *)_cffi_const_EVP_R_BAD_DECRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_CAMELLIA_KEY_SETUP_FAILED", (void *)_cffi_const_EVP_R_CAMELLIA_KEY_SETUP_FAILED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_CIPHER_PARAMETER_ERROR", (void *)_cffi_const_EVP_R_CIPHER_PARAMETER_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_CTRL_NOT_IMPLEMENTED", (void *)_cffi_const_EVP_R_CTRL_NOT_IMPLEMENTED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED", (void *)_cffi_const_EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH", (void *)_cffi_const_EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_DECODE_ERROR", (void *)_cffi_const_EVP_R_DECODE_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_DIFFERENT_KEY_TYPES", (void *)_cffi_const_EVP_R_DIFFERENT_KEY_TYPES, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_INITIALIZATION_ERROR", (void *)_cffi_const_EVP_R_INITIALIZATION_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_INPUT_NOT_INITIALIZED", (void *)_cffi_const_EVP_R_INPUT_NOT_INITIALIZED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_INVALID_KEY_LENGTH", (void *)_cffi_const_EVP_R_INVALID_KEY_LENGTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_KEYGEN_FAILURE", (void *)_cffi_const_EVP_R_KEYGEN_FAILURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_MISSING_PARAMETERS", (void *)_cffi_const_EVP_R_MISSING_PARAMETERS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_NO_CIPHER_SET", (void *)_cffi_const_EVP_R_NO_CIPHER_SET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_NO_DIGEST_SET", (void *)_cffi_const_EVP_R_NO_DIGEST_SET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_PUBLIC_KEY_NOT_RSA", (void *)_cffi_const_EVP_R_PUBLIC_KEY_NOT_RSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_UNKNOWN_PBE_ALGORITHM", (void *)_cffi_const_EVP_R_UNKNOWN_PBE_ALGORITHM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_UNSUPPORTED_CIPHER", (void *)_cffi_const_EVP_R_UNSUPPORTED_CIPHER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_UNSUPPORTED_KEYLENGTH", (void *)_cffi_const_EVP_R_UNSUPPORTED_KEYLENGTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION", (void *)_cffi_const_EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM", (void *)_cffi_const_EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_UNSUPPORTED_SALT_TYPE", (void *)_cffi_const_EVP_R_UNSUPPORTED_SALT_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_R_WRONG_FINAL_BLOCK_LENGTH", (void *)_cffi_const_EVP_R_WRONG_FINAL_BLOCK_LENGTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "EVP_SignFinal", (void *)_cffi_f_EVP_SignFinal, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1873), (void *)_cffi_d_EVP_SignFinal },
  { "EVP_SignInit", (void *)_cffi_f_EVP_SignInit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1855), (void *)_cffi_d_EVP_SignInit },
  { "EVP_SignUpdate", (void *)_cffi_f_EVP_SignUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1885), (void *)_cffi_d_EVP_SignUpdate },
  { "EVP_VerifyFinal", (void *)_cffi_f_EVP_VerifyFinal, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1879), (void *)_cffi_d_EVP_VerifyFinal },
  { "EVP_VerifyInit", (void *)_cffi_f_EVP_VerifyInit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1855), (void *)_cffi_d_EVP_VerifyInit },
  { "EVP_VerifyUpdate", (void *)_cffi_f_EVP_VerifyUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1885), (void *)_cffi_d_EVP_VerifyUpdate },
  { "EVP_get_cipherbyname", (void *)_cffi_f_EVP_get_cipherbyname, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 457), (void *)_cffi_d_EVP_get_cipherbyname },
  { "EVP_get_digestbyname", (void *)_cffi_f_EVP_get_digestbyname, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 469), (void *)_cffi_d_EVP_get_digestbyname },
  { "EVP_md5", (void *)_cffi_f_EVP_md5, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_md5 },
  { "EVP_ripemd160", (void *)_cffi_f_EVP_ripemd160, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_ripemd160 },
  { "EVP_sha1", (void *)_cffi_f_EVP_sha1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_sha1 },
  { "EVP_sha224", (void *)_cffi_f_EVP_sha224, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_sha224 },
  { "EVP_sha256", (void *)_cffi_f_EVP_sha256, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_sha256 },
  { "EVP_sha384", (void *)_cffi_f_EVP_sha384, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_sha384 },
  { "EVP_sha512", (void *)_cffi_f_EVP_sha512, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 472), (void *)_cffi_d_EVP_sha512 },
  { "GENERAL_NAMES_free", (void *)_cffi_f_GENERAL_NAMES_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3308), (void *)_cffi_d_GENERAL_NAMES_free },
  { "GENERAL_NAMES_new", (void *)_cffi_f_GENERAL_NAMES_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 528), (void *)_cffi_d_GENERAL_NAMES_new },
  { "GENERAL_NAME_free", (void *)_cffi_f_GENERAL_NAME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3305), (void *)_cffi_d_GENERAL_NAME_free },
  { "GENERAL_NAME_new", (void *)_cffi_f_GENERAL_NAME_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 521), (void *)_cffi_d_GENERAL_NAME_new },
  { "GENERAL_NAME_print", (void *)_cffi_f_GENERAL_NAME_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1226), (void *)_cffi_d_GENERAL_NAME_print },
  { "GENERAL_SUBTREE_new", (void *)_cffi_f_GENERAL_SUBTREE_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 534), (void *)_cffi_d_GENERAL_SUBTREE_new },
  { "GEN_DIRNAME", (void *)_cffi_const_GEN_DIRNAME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_DNS", (void *)_cffi_const_GEN_DNS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_EDIPARTY", (void *)_cffi_const_GEN_EDIPARTY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_EMAIL", (void *)_cffi_const_GEN_EMAIL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_IPADD", (void *)_cffi_const_GEN_IPADD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_OTHERNAME", (void *)_cffi_const_GEN_OTHERNAME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_RID", (void *)_cffi_const_GEN_RID, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_URI", (void *)_cffi_const_GEN_URI, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "GEN_X400", (void *)_cffi_const_GEN_X400, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "HMAC_CTX_copy", (void *)_cffi_f_HMAC_CTX_copy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1993), (void *)_cffi_d_HMAC_CTX_copy },
  { "HMAC_Final", (void *)_cffi_f_HMAC_Final, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1997), (void *)_cffi_d_HMAC_Final },
  { "HMAC_Init_ex", (void *)_cffi_f_HMAC_Init_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2007), (void *)_cffi_d_HMAC_Init_ex },
  { "HMAC_Update", (void *)_cffi_f_HMAC_Update, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2002), (void *)_cffi_d_HMAC_Update },
  { "MBSTRING_ASC", (void *)_cffi_const_MBSTRING_ASC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "MBSTRING_BMP", (void *)_cffi_const_MBSTRING_BMP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "MBSTRING_FLAG", (void *)_cffi_const_MBSTRING_FLAG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "MBSTRING_UNIV", (void *)_cffi_const_MBSTRING_UNIV, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "MBSTRING_UTF8", (void *)_cffi_const_MBSTRING_UTF8, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "M_ASN1_TIME_dup", (void *)_cffi_f_M_ASN1_TIME_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 91), (void *)_cffi_d_M_ASN1_TIME_dup },
  { "NAME_CONSTRAINTS_free", (void *)_cffi_f_NAME_CONSTRAINTS_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3318), (void *)_cffi_d_NAME_CONSTRAINTS_free },
  { "NAME_CONSTRAINTS_new", (void *)_cffi_f_NAME_CONSTRAINTS_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 538), (void *)_cffi_d_NAME_CONSTRAINTS_new },
  { "NETSCAPE_SPKI_b64_decode", (void *)_cffi_f_NETSCAPE_SPKI_b64_decode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 540), (void *)_cffi_d_NETSCAPE_SPKI_b64_decode },
  { "NETSCAPE_SPKI_b64_encode", (void *)_cffi_f_NETSCAPE_SPKI_b64_encode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 918), (void *)_cffi_d_NETSCAPE_SPKI_b64_encode },
  { "NETSCAPE_SPKI_free", (void *)_cffi_f_NETSCAPE_SPKI_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3321), (void *)_cffi_d_NETSCAPE_SPKI_free },
  { "NETSCAPE_SPKI_get_pubkey", (void *)_cffi_f_NETSCAPE_SPKI_get_pubkey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 492), (void *)_cffi_d_NETSCAPE_SPKI_get_pubkey },
  { "NETSCAPE_SPKI_new", (void *)_cffi_f_NETSCAPE_SPKI_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 544), (void *)_cffi_d_NETSCAPE_SPKI_new },
  { "NETSCAPE_SPKI_set_pubkey", (void *)_cffi_f_NETSCAPE_SPKI_set_pubkey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2014), (void *)_cffi_d_NETSCAPE_SPKI_set_pubkey },
  { "NETSCAPE_SPKI_sign", (void *)_cffi_f_NETSCAPE_SPKI_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2018), (void *)_cffi_d_NETSCAPE_SPKI_sign },
  { "NETSCAPE_SPKI_verify", (void *)_cffi_f_NETSCAPE_SPKI_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2014), (void *)_cffi_d_NETSCAPE_SPKI_verify },
  { "NID_X25519", (void *)_cffi_const_NID_X25519, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2onb191v4", (void *)_cffi_const_NID_X9_62_c2onb191v4, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2onb191v5", (void *)_cffi_const_NID_X9_62_c2onb191v5, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2onb239v4", (void *)_cffi_const_NID_X9_62_c2onb239v4, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2onb239v5", (void *)_cffi_const_NID_X9_62_c2onb239v5, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb163v1", (void *)_cffi_const_NID_X9_62_c2pnb163v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb163v2", (void *)_cffi_const_NID_X9_62_c2pnb163v2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb163v3", (void *)_cffi_const_NID_X9_62_c2pnb163v3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb176v1", (void *)_cffi_const_NID_X9_62_c2pnb176v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb208w1", (void *)_cffi_const_NID_X9_62_c2pnb208w1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb272w1", (void *)_cffi_const_NID_X9_62_c2pnb272w1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb304w1", (void *)_cffi_const_NID_X9_62_c2pnb304w1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2pnb368w1", (void *)_cffi_const_NID_X9_62_c2pnb368w1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb191v1", (void *)_cffi_const_NID_X9_62_c2tnb191v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb191v2", (void *)_cffi_const_NID_X9_62_c2tnb191v2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb191v3", (void *)_cffi_const_NID_X9_62_c2tnb191v3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb239v1", (void *)_cffi_const_NID_X9_62_c2tnb239v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb239v2", (void *)_cffi_const_NID_X9_62_c2tnb239v2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb239v3", (void *)_cffi_const_NID_X9_62_c2tnb239v3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb359v1", (void *)_cffi_const_NID_X9_62_c2tnb359v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_c2tnb431r1", (void *)_cffi_const_NID_X9_62_c2tnb431r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime192v1", (void *)_cffi_const_NID_X9_62_prime192v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime192v2", (void *)_cffi_const_NID_X9_62_prime192v2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime192v3", (void *)_cffi_const_NID_X9_62_prime192v3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime239v1", (void *)_cffi_const_NID_X9_62_prime239v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime239v2", (void *)_cffi_const_NID_X9_62_prime239v2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime239v3", (void *)_cffi_const_NID_X9_62_prime239v3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_X9_62_prime256v1", (void *)_cffi_const_NID_X9_62_prime256v1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ad_OCSP", (void *)_cffi_const_NID_ad_OCSP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ad_ca_issuers", (void *)_cffi_const_NID_ad_ca_issuers, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_any_policy", (void *)_cffi_const_NID_any_policy, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_authority_key_identifier", (void *)_cffi_const_NID_authority_key_identifier, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_basic_constraints", (void *)_cffi_const_NID_basic_constraints, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_certificate_issuer", (void *)_cffi_const_NID_certificate_issuer, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_certificate_policies", (void *)_cffi_const_NID_certificate_policies, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_commonName", (void *)_cffi_const_NID_commonName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_countryName", (void *)_cffi_const_NID_countryName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_crl_distribution_points", (void *)_cffi_const_NID_crl_distribution_points, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_crl_number", (void *)_cffi_const_NID_crl_number, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_crl_reason", (void *)_cffi_const_NID_crl_reason, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_delta_crl", (void *)_cffi_const_NID_delta_crl, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_dnQualifier", (void *)_cffi_const_NID_dnQualifier, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_domainComponent", (void *)_cffi_const_NID_domainComponent, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_dsa", (void *)_cffi_const_NID_dsa, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_dsaWithSHA", (void *)_cffi_const_NID_dsaWithSHA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_dsaWithSHA1", (void *)_cffi_const_NID_dsaWithSHA1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ecdsa_with_SHA1", (void *)_cffi_const_NID_ecdsa_with_SHA1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ecdsa_with_SHA224", (void *)_cffi_const_NID_ecdsa_with_SHA224, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ecdsa_with_SHA256", (void *)_cffi_const_NID_ecdsa_with_SHA256, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ecdsa_with_SHA384", (void *)_cffi_const_NID_ecdsa_with_SHA384, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ecdsa_with_SHA512", (void *)_cffi_const_NID_ecdsa_with_SHA512, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ext_key_usage", (void *)_cffi_const_NID_ext_key_usage, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_generationQualifier", (void *)_cffi_const_NID_generationQualifier, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_givenName", (void *)_cffi_const_NID_givenName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_info_access", (void *)_cffi_const_NID_info_access, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_inhibit_any_policy", (void *)_cffi_const_NID_inhibit_any_policy, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_invalidity_date", (void *)_cffi_const_NID_invalidity_date, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ipsec3", (void *)_cffi_const_NID_ipsec3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ipsec4", (void *)_cffi_const_NID_ipsec4, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_issuer_alt_name", (void *)_cffi_const_NID_issuer_alt_name, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_issuing_distribution_point", (void *)_cffi_const_NID_issuing_distribution_point, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_key_usage", (void *)_cffi_const_NID_key_usage, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_localityName", (void *)_cffi_const_NID_localityName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_md2", (void *)_cffi_const_NID_md2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_md4", (void *)_cffi_const_NID_md4, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_md5", (void *)_cffi_const_NID_md5, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_mdc2", (void *)_cffi_const_NID_mdc2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_name_constraints", (void *)_cffi_const_NID_name_constraints, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_no_rev_avail", (void *)_cffi_const_NID_no_rev_avail, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_organizationName", (void *)_cffi_const_NID_organizationName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_organizationalUnitName", (void *)_cffi_const_NID_organizationalUnitName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_pbe_WithSHA1And3_Key_TripleDES_CBC", (void *)_cffi_const_NID_pbe_WithSHA1And3_Key_TripleDES_CBC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_pkcs9_emailAddress", (void *)_cffi_const_NID_pkcs9_emailAddress, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_policy_constraints", (void *)_cffi_const_NID_policy_constraints, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_policy_mappings", (void *)_cffi_const_NID_policy_mappings, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_private_key_usage_period", (void *)_cffi_const_NID_private_key_usage_period, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_pseudonym", (void *)_cffi_const_NID_pseudonym, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_ripemd160", (void *)_cffi_const_NID_ripemd160, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp112r1", (void *)_cffi_const_NID_secp112r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp112r2", (void *)_cffi_const_NID_secp112r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp128r1", (void *)_cffi_const_NID_secp128r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp128r2", (void *)_cffi_const_NID_secp128r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp160k1", (void *)_cffi_const_NID_secp160k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp160r1", (void *)_cffi_const_NID_secp160r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp160r2", (void *)_cffi_const_NID_secp160r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp192k1", (void *)_cffi_const_NID_secp192k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp224k1", (void *)_cffi_const_NID_secp224k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp224r1", (void *)_cffi_const_NID_secp224r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp256k1", (void *)_cffi_const_NID_secp256k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp384r1", (void *)_cffi_const_NID_secp384r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_secp521r1", (void *)_cffi_const_NID_secp521r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect113r1", (void *)_cffi_const_NID_sect113r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect113r2", (void *)_cffi_const_NID_sect113r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect131r1", (void *)_cffi_const_NID_sect131r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect131r2", (void *)_cffi_const_NID_sect131r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect163k1", (void *)_cffi_const_NID_sect163k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect163r1", (void *)_cffi_const_NID_sect163r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect163r2", (void *)_cffi_const_NID_sect163r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect193r1", (void *)_cffi_const_NID_sect193r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect193r2", (void *)_cffi_const_NID_sect193r2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect233k1", (void *)_cffi_const_NID_sect233k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect233r1", (void *)_cffi_const_NID_sect233r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect239k1", (void *)_cffi_const_NID_sect239k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect283k1", (void *)_cffi_const_NID_sect283k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect283r1", (void *)_cffi_const_NID_sect283r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect409k1", (void *)_cffi_const_NID_sect409k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect409r1", (void *)_cffi_const_NID_sect409r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect571k1", (void *)_cffi_const_NID_sect571k1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sect571r1", (void *)_cffi_const_NID_sect571r1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_serialNumber", (void *)_cffi_const_NID_serialNumber, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sha", (void *)_cffi_const_NID_sha, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sha1", (void *)_cffi_const_NID_sha1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sha224", (void *)_cffi_const_NID_sha224, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sha256", (void *)_cffi_const_NID_sha256, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sha384", (void *)_cffi_const_NID_sha384, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_sha512", (void *)_cffi_const_NID_sha512, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_stateOrProvinceName", (void *)_cffi_const_NID_stateOrProvinceName, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_subject_alt_name", (void *)_cffi_const_NID_subject_alt_name, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_subject_key_identifier", (void *)_cffi_const_NID_subject_key_identifier, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_surname", (void *)_cffi_const_NID_surname, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_target_information", (void *)_cffi_const_NID_target_information, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_title", (void *)_cffi_const_NID_title, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_undef", (void *)_cffi_const_NID_undef, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls1", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls10", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls10, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls11", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls11, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls12", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls12, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls3", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls4", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls4, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls5", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls5, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls6", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls6, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls7", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls7, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls8", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls8, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NID_wap_wsg_idm_ecid_wtls9", (void *)_cffi_const_NID_wap_wsg_idm_ecid_wtls9, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "NOTICEREF_free", (void *)_cffi_f_NOTICEREF_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3324), (void *)_cffi_d_NOTICEREF_free },
  { "NOTICEREF_new", (void *)_cffi_f_NOTICEREF_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 546), (void *)_cffi_d_NOTICEREF_new },
  { "OBJ_NAME_TYPE_MD_METH", (void *)_cffi_const_OBJ_NAME_TYPE_MD_METH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OBJ_NAME_do_all", (void *)_cffi_f_OBJ_NAME_do_all, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3589), (void *)_cffi_d_OBJ_NAME_do_all },
  { "OBJ_cleanup", (void *)_cffi_f_OBJ_cleanup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_OBJ_cleanup },
  { "OBJ_cmp", (void *)_cffi_f_OBJ_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1017), (void *)_cffi_d_OBJ_cmp },
  { "OBJ_create", (void *)_cffi_f_OBJ_create, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2638), (void *)_cffi_d_OBJ_create },
  { "OBJ_dup", (void *)_cffi_f_OBJ_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 43), (void *)_cffi_d_OBJ_dup },
  { "OBJ_ln2nid", (void *)_cffi_f_OBJ_ln2nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2635), (void *)_cffi_d_OBJ_ln2nid },
  { "OBJ_nid2ln", (void *)_cffi_f_OBJ_nid2ln, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 958), (void *)_cffi_d_OBJ_nid2ln },
  { "OBJ_nid2obj", (void *)_cffi_f_OBJ_nid2obj, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 60), (void *)_cffi_d_OBJ_nid2obj },
  { "OBJ_nid2sn", (void *)_cffi_f_OBJ_nid2sn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 958), (void *)_cffi_d_OBJ_nid2sn },
  { "OBJ_obj2nid", (void *)_cffi_f_OBJ_obj2nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1014), (void *)_cffi_d_OBJ_obj2nid },
  { "OBJ_obj2txt", (void *)_cffi_f_OBJ_obj2txt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2623), (void *)_cffi_d_OBJ_obj2txt },
  { "OBJ_sn2nid", (void *)_cffi_f_OBJ_sn2nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2635), (void *)_cffi_d_OBJ_sn2nid },
  { "OBJ_txt2nid", (void *)_cffi_f_OBJ_txt2nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2635), (void *)_cffi_d_OBJ_txt2nid },
  { "OBJ_txt2obj", (void *)_cffi_f_OBJ_txt2obj, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 56), (void *)_cffi_d_OBJ_txt2obj },
  { "OCSP_BASICRESP_add1_ext_i2d", (void *)_cffi_f_OCSP_BASICRESP_add1_ext_i2d, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2038), (void *)_cffi_d_OCSP_BASICRESP_add1_ext_i2d },
  { "OCSP_BASICRESP_free", (void *)_cffi_f_OCSP_BASICRESP_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3331), (void *)_cffi_d_OCSP_BASICRESP_free },
  { "OCSP_BASICRESP_get_ext", (void *)_cffi_f_OCSP_BASICRESP_get_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 789), (void *)_cffi_d_OCSP_BASICRESP_get_ext },
  { "OCSP_BASICRESP_get_ext_count", (void *)_cffi_f_OCSP_BASICRESP_get_ext_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2023), (void *)_cffi_d_OCSP_BASICRESP_get_ext_count },
  { "OCSP_BASICRESP_new", (void *)_cffi_f_OCSP_BASICRESP_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 551), (void *)_cffi_d_OCSP_BASICRESP_new },
  { "OCSP_ONEREQ_get_ext", (void *)_cffi_f_OCSP_ONEREQ_get_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 793), (void *)_cffi_d_OCSP_ONEREQ_get_ext },
  { "OCSP_ONEREQ_get_ext_count", (void *)_cffi_f_OCSP_ONEREQ_get_ext_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2050), (void *)_cffi_d_OCSP_ONEREQ_get_ext_count },
  { "OCSP_REQUEST_add1_ext_i2d", (void *)_cffi_f_OCSP_REQUEST_add1_ext_i2d, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2056), (void *)_cffi_d_OCSP_REQUEST_add1_ext_i2d },
  { "OCSP_REQUEST_free", (void *)_cffi_f_OCSP_REQUEST_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3334), (void *)_cffi_d_OCSP_REQUEST_free },
  { "OCSP_REQUEST_new", (void *)_cffi_f_OCSP_REQUEST_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 564), (void *)_cffi_d_OCSP_REQUEST_new },
  { "OCSP_SINGLERESP_get_ext", (void *)_cffi_f_OCSP_SINGLERESP_get_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 797), (void *)_cffi_d_OCSP_SINGLERESP_get_ext },
  { "OCSP_SINGLERESP_get_ext_count", (void *)_cffi_f_OCSP_SINGLERESP_get_ext_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2071), (void *)_cffi_d_OCSP_SINGLERESP_get_ext_count },
  { "OCSP_basic_add1_cert", (void *)_cffi_f_OCSP_basic_add1_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2026), (void *)_cffi_d_OCSP_basic_add1_cert },
  { "OCSP_basic_add1_nonce", (void *)_cffi_f_OCSP_basic_add1_nonce, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2045), (void *)_cffi_d_OCSP_basic_add1_nonce },
  { "OCSP_basic_add1_status", (void *)_cffi_f_OCSP_basic_add1_status, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 574), (void *)_cffi_d_OCSP_basic_add1_status },
  { "OCSP_basic_sign", (void *)_cffi_f_OCSP_basic_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2030), (void *)_cffi_d_OCSP_basic_sign },
  { "OCSP_onereq_get0_id", (void *)_cffi_f_OCSP_onereq_get0_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 553), (void *)_cffi_d_OCSP_onereq_get0_id },
  { "OCSP_request_add1_nonce", (void *)_cffi_f_OCSP_request_add1_nonce, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2063), (void *)_cffi_d_OCSP_request_add1_nonce },
  { "OCSP_request_onereq_count", (void *)_cffi_f_OCSP_request_onereq_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2053), (void *)_cffi_d_OCSP_request_onereq_count },
  { "OCSP_request_onereq_get0", (void *)_cffi_f_OCSP_request_onereq_get0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 556), (void *)_cffi_d_OCSP_request_onereq_get0 },
  { "OCSP_resp_count", (void *)_cffi_f_OCSP_resp_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2023), (void *)_cffi_d_OCSP_resp_count },
  { "OCSP_resp_get0", (void *)_cffi_f_OCSP_resp_get0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 583), (void *)_cffi_d_OCSP_resp_get0 },
  { "OCSP_response_create", (void *)_cffi_f_OCSP_response_create, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 570), (void *)_cffi_d_OCSP_response_create },
  { "OCSP_response_get1_basic", (void *)_cffi_f_OCSP_response_get1_basic, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 548), (void *)_cffi_d_OCSP_response_get1_basic },
  { "OCSP_response_status", (void *)_cffi_f_OCSP_response_status, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2068), (void *)_cffi_d_OCSP_response_status },
  { "OCSP_single_get0_status", (void *)_cffi_f_OCSP_single_get0_status, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2074), (void *)_cffi_d_OCSP_single_get0_status },
  { "OPENSSL_BUILT_ON", (void *)_cffi_const_OPENSSL_BUILT_ON, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_CFLAGS", (void *)_cffi_const_OPENSSL_CFLAGS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_DIR", (void *)_cffi_const_OPENSSL_DIR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_EC_NAMED_CURVE", (void *)_cffi_const_OPENSSL_EC_NAMED_CURVE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_NPN_NEGOTIATED", (void *)_cffi_const_OPENSSL_NPN_NEGOTIATED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_PLATFORM", (void *)_cffi_const_OPENSSL_PLATFORM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_VERSION", (void *)_cffi_const_OPENSSL_VERSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_VERSION_NUMBER", (void *)_cffi_const_OPENSSL_VERSION_NUMBER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "OPENSSL_VERSION_TEXT", (void *)_cffi_const_OPENSSL_VERSION_TEXT, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "OPENSSL_config", (void *)_cffi_f_OPENSSL_config, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3570), (void *)_cffi_d_OPENSSL_config },
  { "OPENSSL_free", (void *)_cffi_f_OPENSSL_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3602), (void *)_cffi_d_OPENSSL_free },
  { "OPENSSL_malloc", (void *)_cffi_f_OPENSSL_malloc, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3103), (void *)_cffi_d_OPENSSL_malloc },
  { "OPENSSL_no_config", (void *)_cffi_f_OPENSSL_no_config, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_OPENSSL_no_config },
  { "OTHERNAME_free", (void *)_cffi_f_OTHERNAME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3337), (void *)_cffi_d_OTHERNAME_free },
  { "OTHERNAME_new", (void *)_cffi_f_OTHERNAME_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 587), (void *)_cffi_d_OTHERNAME_new },
  { "OpenSSL_add_all_algorithms", (void *)_cffi_f_OpenSSL_add_all_algorithms, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_OpenSSL_add_all_algorithms },
  { "OpenSSL_version", (void *)_cffi_f_OpenSSL_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 958), (void *)_cffi_d_OpenSSL_version },
  { "OpenSSL_version_num", (void *)_cffi_f_OpenSSL_version_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3069), (void *)_cffi_d_OpenSSL_version_num },
  { "PEM_F_D2I_PKCS8PRIVATEKEY_BIO", (void *)_cffi_const_PEM_F_D2I_PKCS8PRIVATEKEY_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_D2I_PKCS8PRIVATEKEY_FP", (void *)_cffi_const_PEM_F_D2I_PKCS8PRIVATEKEY_FP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_DO_PK8PKEY", (void *)_cffi_const_PEM_F_DO_PK8PKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_DO_PK8PKEY_FP", (void *)_cffi_const_PEM_F_DO_PK8PKEY_FP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_LOAD_IV", (void *)_cffi_const_PEM_F_LOAD_IV, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_ASN1_READ", (void *)_cffi_const_PEM_F_PEM_ASN1_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_ASN1_READ_BIO", (void *)_cffi_const_PEM_F_PEM_ASN1_READ_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_ASN1_WRITE", (void *)_cffi_const_PEM_F_PEM_ASN1_WRITE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_ASN1_WRITE_BIO", (void *)_cffi_const_PEM_F_PEM_ASN1_WRITE_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_DEF_CALLBACK", (void *)_cffi_const_PEM_F_PEM_DEF_CALLBACK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_DO_HEADER", (void *)_cffi_const_PEM_F_PEM_DO_HEADER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_GET_EVP_CIPHER_INFO", (void *)_cffi_const_PEM_F_PEM_GET_EVP_CIPHER_INFO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_READ", (void *)_cffi_const_PEM_F_PEM_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_READ_BIO", (void *)_cffi_const_PEM_F_PEM_READ_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_READ_BIO_PRIVATEKEY", (void *)_cffi_const_PEM_F_PEM_READ_BIO_PRIVATEKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_READ_PRIVATEKEY", (void *)_cffi_const_PEM_F_PEM_READ_PRIVATEKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_SIGNFINAL", (void *)_cffi_const_PEM_F_PEM_SIGNFINAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_WRITE", (void *)_cffi_const_PEM_F_PEM_WRITE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_WRITE_BIO", (void *)_cffi_const_PEM_F_PEM_WRITE_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_X509_INFO_READ", (void *)_cffi_const_PEM_F_PEM_X509_INFO_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_X509_INFO_READ_BIO", (void *)_cffi_const_PEM_F_PEM_X509_INFO_READ_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_F_PEM_X509_INFO_WRITE_BIO", (void *)_cffi_const_PEM_F_PEM_X509_INFO_WRITE_BIO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_BAD_BASE64_DECODE", (void *)_cffi_const_PEM_R_BAD_BASE64_DECODE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_BAD_DECRYPT", (void *)_cffi_const_PEM_R_BAD_DECRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_BAD_END_LINE", (void *)_cffi_const_PEM_R_BAD_END_LINE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_BAD_IV_CHARS", (void *)_cffi_const_PEM_R_BAD_IV_CHARS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_BAD_PASSWORD_READ", (void *)_cffi_const_PEM_R_BAD_PASSWORD_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_ERROR_CONVERTING_PRIVATE_KEY", (void *)_cffi_const_PEM_R_ERROR_CONVERTING_PRIVATE_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_NOT_DEK_INFO", (void *)_cffi_const_PEM_R_NOT_DEK_INFO, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_NOT_ENCRYPTED", (void *)_cffi_const_PEM_R_NOT_ENCRYPTED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_NOT_PROC_TYPE", (void *)_cffi_const_PEM_R_NOT_PROC_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_NO_START_LINE", (void *)_cffi_const_PEM_R_NO_START_LINE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_PROBLEMS_GETTING_PASSWORD", (void *)_cffi_const_PEM_R_PROBLEMS_GETTING_PASSWORD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_READ_KEY", (void *)_cffi_const_PEM_R_READ_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_SHORT_HEADER", (void *)_cffi_const_PEM_R_SHORT_HEADER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_UNSUPPORTED_CIPHER", (void *)_cffi_const_PEM_R_UNSUPPORTED_CIPHER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_R_UNSUPPORTED_ENCRYPTION", (void *)_cffi_const_PEM_R_UNSUPPORTED_ENCRYPTION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PEM_read_bio_DHparams", (void *)_cffi_f_PEM_read_bio_DHparams, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 287), (void *)_cffi_d_PEM_read_bio_DHparams },
  { "PEM_read_bio_DSAPrivateKey", (void *)_cffi_f_PEM_read_bio_DSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 321), (void *)_cffi_d_PEM_read_bio_DSAPrivateKey },
  { "PEM_read_bio_DSA_PUBKEY", (void *)_cffi_f_PEM_read_bio_DSA_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 321), (void *)_cffi_d_PEM_read_bio_DSA_PUBKEY },
  { "PEM_read_bio_PKCS7", (void *)_cffi_f_PEM_read_bio_PKCS7, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 613), (void *)_cffi_d_PEM_read_bio_PKCS7 },
  { "PEM_read_bio_PUBKEY", (void *)_cffi_f_PEM_read_bio_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 480), (void *)_cffi_d_PEM_read_bio_PUBKEY },
  { "PEM_read_bio_PrivateKey", (void *)_cffi_f_PEM_read_bio_PrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 480), (void *)_cffi_d_PEM_read_bio_PrivateKey },
  { "PEM_read_bio_RSAPrivateKey", (void *)_cffi_f_PEM_read_bio_RSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 657), (void *)_cffi_d_PEM_read_bio_RSAPrivateKey },
  { "PEM_read_bio_RSAPublicKey", (void *)_cffi_f_PEM_read_bio_RSAPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 657), (void *)_cffi_d_PEM_read_bio_RSAPublicKey },
  { "PEM_read_bio_X509", (void *)_cffi_f_PEM_read_bio_X509, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 720), (void *)_cffi_d_PEM_read_bio_X509 },
  { "PEM_read_bio_X509_AUX", (void *)_cffi_f_PEM_read_bio_X509_AUX, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 720), (void *)_cffi_d_PEM_read_bio_X509_AUX },
  { "PEM_read_bio_X509_CRL", (void *)_cffi_f_PEM_read_bio_X509_CRL, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 765), (void *)_cffi_d_PEM_read_bio_X509_CRL },
  { "PEM_read_bio_X509_REQ", (void *)_cffi_f_PEM_read_bio_X509_REQ, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 877), (void *)_cffi_d_PEM_read_bio_X509_REQ },
  { "PEM_write_bio_CMS_stream", (void *)_cffi_f_PEM_write_bio_CMS_stream, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1155), (void *)_cffi_d_PEM_write_bio_CMS_stream },
  { "PEM_write_bio_DHparams", (void *)_cffi_f_PEM_write_bio_DHparams, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1161), (void *)_cffi_d_PEM_write_bio_DHparams },
  { "PEM_write_bio_DHxparams", (void *)_cffi_f_PEM_write_bio_DHxparams, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1161), (void *)_cffi_d_PEM_write_bio_DHxparams },
  { "PEM_write_bio_DSAPrivateKey", (void *)_cffi_f_PEM_write_bio_DSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1173), (void *)_cffi_d_PEM_write_bio_DSAPrivateKey },
  { "PEM_write_bio_DSA_PUBKEY", (void *)_cffi_f_PEM_write_bio_DSA_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1169), (void *)_cffi_d_PEM_write_bio_DSA_PUBKEY },
  { "PEM_write_bio_ECPrivateKey", (void *)_cffi_f_PEM_write_bio_ECPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1186), (void *)_cffi_d_PEM_write_bio_ECPrivateKey },
  { "PEM_write_bio_PKCS7", (void *)_cffi_f_PEM_write_bio_PKCS7, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1242), (void *)_cffi_d_PEM_write_bio_PKCS7 },
  { "PEM_write_bio_PKCS8PrivateKey", (void *)_cffi_f_PEM_write_bio_PKCS8PrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1199), (void *)_cffi_d_PEM_write_bio_PKCS8PrivateKey },
  { "PEM_write_bio_PKCS8PrivateKey_nid", (void *)_cffi_f_PEM_write_bio_PKCS8PrivateKey_nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1217), (void *)_cffi_d_PEM_write_bio_PKCS8PrivateKey_nid },
  { "PEM_write_bio_PUBKEY", (void *)_cffi_f_PEM_write_bio_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1195), (void *)_cffi_d_PEM_write_bio_PUBKEY },
  { "PEM_write_bio_PrivateKey", (void *)_cffi_f_PEM_write_bio_PrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1208), (void *)_cffi_d_PEM_write_bio_PrivateKey },
  { "PEM_write_bio_RSAPrivateKey", (void *)_cffi_f_PEM_write_bio_RSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1256), (void *)_cffi_d_PEM_write_bio_RSAPrivateKey },
  { "PEM_write_bio_RSAPublicKey", (void *)_cffi_f_PEM_write_bio_RSAPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1265), (void *)_cffi_d_PEM_write_bio_RSAPublicKey },
  { "PEM_write_bio_X509", (void *)_cffi_f_PEM_write_bio_X509, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1278), (void *)_cffi_d_PEM_write_bio_X509 },
  { "PEM_write_bio_X509_CRL", (void *)_cffi_f_PEM_write_bio_X509_CRL, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1288), (void *)_cffi_d_PEM_write_bio_X509_CRL },
  { "PEM_write_bio_X509_REQ", (void *)_cffi_f_PEM_write_bio_X509_REQ, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1298), (void *)_cffi_d_PEM_write_bio_X509_REQ },
  { "PKCS12_F_PKCS12_PBE_CRYPT", (void *)_cffi_const_PKCS12_F_PKCS12_PBE_CRYPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS12_R_PKCS12_CIPHERFINAL_ERROR", (void *)_cffi_const_PKCS12_R_PKCS12_CIPHERFINAL_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS12_create", (void *)_cffi_f_PKCS12_create, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 593), (void *)_cffi_d_PKCS12_create },
  { "PKCS12_free", (void *)_cffi_f_PKCS12_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3340), (void *)_cffi_d_PKCS12_free },
  { "PKCS12_parse", (void *)_cffi_f_PKCS12_parse, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2081), (void *)_cffi_d_PKCS12_parse },
  { "PKCS5_PBKDF2_HMAC", (void *)_cffi_f_PKCS5_PBKDF2_HMAC, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2647), (void *)_cffi_d_PKCS5_PBKDF2_HMAC },
  { "PKCS5_PBKDF2_HMAC_SHA1", (void *)_cffi_f_PKCS5_PBKDF2_HMAC_SHA1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2657), (void *)_cffi_d_PKCS5_PBKDF2_HMAC_SHA1 },
  { "PKCS7_BINARY", (void *)_cffi_const_PKCS7_BINARY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_DETACHED", (void *)_cffi_const_PKCS7_DETACHED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOATTR", (void *)_cffi_const_PKCS7_NOATTR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOCERTS", (void *)_cffi_const_PKCS7_NOCERTS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOCHAIN", (void *)_cffi_const_PKCS7_NOCHAIN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOINTERN", (void *)_cffi_const_PKCS7_NOINTERN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOSIGS", (void *)_cffi_const_PKCS7_NOSIGS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOSMIMECAP", (void *)_cffi_const_PKCS7_NOSMIMECAP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_NOVERIFY", (void *)_cffi_const_PKCS7_NOVERIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_STREAM", (void *)_cffi_const_PKCS7_STREAM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_TEXT", (void *)_cffi_const_PKCS7_TEXT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "PKCS7_dataInit", (void *)_cffi_f_PKCS7_dataInit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 181), (void *)_cffi_d_PKCS7_dataInit },
  { "PKCS7_decrypt", (void *)_cffi_f_PKCS7_decrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2099), (void *)_cffi_d_PKCS7_decrypt },
  { "PKCS7_encrypt", (void *)_cffi_f_PKCS7_encrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 619), (void *)_cffi_d_PKCS7_encrypt },
  { "PKCS7_free", (void *)_cffi_f_PKCS7_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3343), (void *)_cffi_d_PKCS7_free },
  { "PKCS7_get0_signers", (void *)_cffi_f_PKCS7_get0_signers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 249), (void *)_cffi_d_PKCS7_get0_signers },
  { "PKCS7_sign", (void *)_cffi_f_PKCS7_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 625), (void *)_cffi_d_PKCS7_sign },
  { "PKCS7_type_is_data", (void *)_cffi_f_PKCS7_type_is_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2088), (void *)_cffi_d_PKCS7_type_is_data },
  { "PKCS7_type_is_digest", (void *)_cffi_f_PKCS7_type_is_digest, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2088), (void *)_cffi_d_PKCS7_type_is_digest },
  { "PKCS7_type_is_encrypted", (void *)_cffi_f_PKCS7_type_is_encrypted, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2088), (void *)_cffi_d_PKCS7_type_is_encrypted },
  { "PKCS7_type_is_enveloped", (void *)_cffi_f_PKCS7_type_is_enveloped, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2088), (void *)_cffi_d_PKCS7_type_is_enveloped },
  { "PKCS7_type_is_signed", (void *)_cffi_f_PKCS7_type_is_signed, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2088), (void *)_cffi_d_PKCS7_type_is_signed },
  { "PKCS7_type_is_signedAndEnveloped", (void *)_cffi_f_PKCS7_type_is_signedAndEnveloped, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2088), (void *)_cffi_d_PKCS7_type_is_signedAndEnveloped },
  { "PKCS7_verify", (void *)_cffi_f_PKCS7_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2091), (void *)_cffi_d_PKCS7_verify },
  { "PKCS8_PRIV_KEY_INFO_free", (void *)_cffi_f_PKCS8_PRIV_KEY_INFO_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3346), (void *)_cffi_d_PKCS8_PRIV_KEY_INFO_free },
  { "POINT_CONVERSION_COMPRESSED", (void *)_cffi_const_POINT_CONVERSION_COMPRESSED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "POINT_CONVERSION_HYBRID", (void *)_cffi_const_POINT_CONVERSION_HYBRID, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "POINT_CONVERSION_UNCOMPRESSED", (void *)_cffi_const_POINT_CONVERSION_UNCOMPRESSED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "POLICYINFO_free", (void *)_cffi_f_POLICYINFO_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3349), (void *)_cffi_d_POLICYINFO_free },
  { "POLICYINFO_new", (void *)_cffi_f_POLICYINFO_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 640), (void *)_cffi_d_POLICYINFO_new },
  { "POLICYQUALINFO_free", (void *)_cffi_f_POLICYQUALINFO_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3352), (void *)_cffi_d_POLICYQUALINFO_free },
  { "POLICYQUALINFO_new", (void *)_cffi_f_POLICYQUALINFO_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 646), (void *)_cffi_d_POLICYQUALINFO_new },
  { "POLICY_CONSTRAINTS_free", (void *)_cffi_f_POLICY_CONSTRAINTS_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3355), (void *)_cffi_d_POLICY_CONSTRAINTS_free },
  { "POLICY_CONSTRAINTS_new", (void *)_cffi_f_POLICY_CONSTRAINTS_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 648), (void *)_cffi_d_POLICY_CONSTRAINTS_new },
  { "RAND_add", (void *)_cffi_f_RAND_add, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3614), (void *)_cffi_d_RAND_add },
  { "RAND_bytes", (void *)_cffi_f_RAND_bytes, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2783), (void *)_cffi_d_RAND_bytes },
  { "RAND_cleanup", (void *)_cffi_f_RAND_cleanup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_RAND_cleanup },
  { "RAND_egd", (void *)_cffi_f_RAND_egd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2635), (void *)_cffi_d_RAND_egd },
  { "RAND_egd_bytes", (void *)_cffi_f_RAND_egd_bytes, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2643), (void *)_cffi_d_RAND_egd_bytes },
  { "RAND_file_name", (void *)_cffi_f_RAND_file_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 954), (void *)_cffi_d_RAND_file_name },
  { "RAND_load_file", (void *)_cffi_f_RAND_load_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2666), (void *)_cffi_d_RAND_load_file },
  { "RAND_query_egd_bytes", (void *)_cffi_f_RAND_query_egd_bytes, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2682), (void *)_cffi_d_RAND_query_egd_bytes },
  { "RAND_seed", (void *)_cffi_f_RAND_seed, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3610), (void *)_cffi_d_RAND_seed },
  { "RAND_status", (void *)_cffi_f_RAND_status, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_RAND_status },
  { "RAND_write_file", (void *)_cffi_f_RAND_write_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2635), (void *)_cffi_d_RAND_write_file },
  { "RSAPublicKey_dup", (void *)_cffi_f_RSAPublicKey_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 671), (void *)_cffi_d_RSAPublicKey_dup },
  { "RSA_F4", (void *)_cffi_const_RSA_F4, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_F_RSA_SIGN", (void *)_cffi_const_RSA_F_RSA_SIGN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_NO_PADDING", (void *)_cffi_const_RSA_NO_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_PKCS1_OAEP_PADDING", (void *)_cffi_const_RSA_PKCS1_OAEP_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_PKCS1_PADDING", (void *)_cffi_const_RSA_PKCS1_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_PKCS1_PSS_PADDING", (void *)_cffi_const_RSA_PKCS1_PSS_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_BLOCK_TYPE_IS_NOT_01", (void *)_cffi_const_RSA_R_BLOCK_TYPE_IS_NOT_01, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_BLOCK_TYPE_IS_NOT_02", (void *)_cffi_const_RSA_R_BLOCK_TYPE_IS_NOT_02, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE", (void *)_cffi_const_RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_DATA_TOO_LARGE_FOR_MODULUS", (void *)_cffi_const_RSA_R_DATA_TOO_LARGE_FOR_MODULUS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY", (void *)_cffi_const_RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_OAEP_DECODING_ERROR", (void *)_cffi_const_RSA_R_OAEP_DECODING_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_R_PKCS_DECODING_ERROR", (void *)_cffi_const_RSA_R_PKCS_DECODING_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_SSLV23_PADDING", (void *)_cffi_const_RSA_SSLV23_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_X931_PADDING", (void *)_cffi_const_RSA_X931_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "RSA_blinding_off", (void *)_cffi_f_RSA_blinding_off, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3358), (void *)_cffi_d_RSA_blinding_off },
  { "RSA_blinding_on", (void *)_cffi_f_RSA_blinding_on, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2117), (void *)_cffi_d_RSA_blinding_on },
  { "RSA_check_key", (void *)_cffi_f_RSA_check_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2145), (void *)_cffi_d_RSA_check_key },
  { "RSA_free", (void *)_cffi_f_RSA_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3358), (void *)_cffi_d_RSA_free },
  { "RSA_generate_key_ex", (void *)_cffi_f_RSA_generate_key_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2121), (void *)_cffi_d_RSA_generate_key_ex },
  { "RSA_get0_crt_params", (void *)_cffi_f_RSA_get0_crt_params, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3366), (void *)_cffi_d_RSA_get0_crt_params },
  { "RSA_get0_factors", (void *)_cffi_f_RSA_get0_factors, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3361), (void *)_cffi_d_RSA_get0_factors },
  { "RSA_get0_key", (void *)_cffi_f_RSA_get0_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3366), (void *)_cffi_d_RSA_get0_key },
  { "RSA_new", (void *)_cffi_f_RSA_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 674), (void *)_cffi_d_RSA_new },
  { "RSA_padding_add_PKCS1_OAEP", (void *)_cffi_f_RSA_padding_add_PKCS1_OAEP, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2796), (void *)_cffi_d_RSA_padding_add_PKCS1_OAEP },
  { "RSA_padding_add_PKCS1_PSS", (void *)_cffi_f_RSA_padding_add_PKCS1_PSS, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2131), (void *)_cffi_d_RSA_padding_add_PKCS1_PSS },
  { "RSA_padding_check_PKCS1_OAEP", (void *)_cffi_f_RSA_padding_check_PKCS1_OAEP, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2787), (void *)_cffi_d_RSA_padding_check_PKCS1_OAEP },
  { "RSA_print", (void *)_cffi_f_RSA_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1269), (void *)_cffi_d_RSA_print },
  { "RSA_private_decrypt", (void *)_cffi_f_RSA_private_decrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2752), (void *)_cffi_d_RSA_private_decrypt },
  { "RSA_private_encrypt", (void *)_cffi_f_RSA_private_encrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2752), (void *)_cffi_d_RSA_private_encrypt },
  { "RSA_public_decrypt", (void *)_cffi_f_RSA_public_decrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2752), (void *)_cffi_d_RSA_public_decrypt },
  { "RSA_public_encrypt", (void *)_cffi_f_RSA_public_encrypt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2752), (void *)_cffi_d_RSA_public_encrypt },
  { "RSA_set0_crt_params", (void *)_cffi_f_RSA_set0_crt_params, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2111), (void *)_cffi_d_RSA_set0_crt_params },
  { "RSA_set0_factors", (void *)_cffi_f_RSA_set0_factors, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2106), (void *)_cffi_d_RSA_set0_factors },
  { "RSA_set0_key", (void *)_cffi_f_RSA_set0_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2111), (void *)_cffi_d_RSA_set0_key },
  { "RSA_size", (void *)_cffi_f_RSA_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2145), (void *)_cffi_d_RSA_size },
  { "RSA_verify_PKCS1_PSS", (void *)_cffi_f_RSA_verify_PKCS1_PSS, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2138), (void *)_cffi_d_RSA_verify_PKCS1_PSS },
  { "SCT_LIST_free", (void *)_cffi_f_SCT_LIST_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3209), (void *)_cffi_d_SCT_LIST_free },
  { "SCT_SOURCE_OCSP_STAPLED_RESPONSE", (void *)_cffi_const_SCT_SOURCE_OCSP_STAPLED_RESPONSE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "SCT_SOURCE_TLS_EXTENSION", (void *)_cffi_const_SCT_SOURCE_TLS_EXTENSION, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "SCT_SOURCE_UNKNOWN", (void *)_cffi_const_SCT_SOURCE_UNKNOWN, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "SCT_SOURCE_X509V3_EXTENSION", (void *)_cffi_const_SCT_SOURCE_X509V3_EXTENSION, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "SCT_VERSION_NOT_SET", (void *)_cffi_const_SCT_VERSION_NOT_SET, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "SCT_VERSION_V1", (void *)_cffi_const_SCT_VERSION_V1, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "SCT_get0_log_id", (void *)_cffi_f_SCT_get0_log_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2981), (void *)_cffi_d_SCT_get0_log_id },
  { "SCT_get_log_entry_type", (void *)_cffi_f_SCT_get_log_entry_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 969), (void *)_cffi_d_SCT_get_log_entry_type },
  { "SCT_get_timestamp", (void *)_cffi_f_SCT_get_timestamp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3000), (void *)_cffi_d_SCT_get_timestamp },
  { "SCT_get_version", (void *)_cffi_f_SCT_get_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2963), (void *)_cffi_d_SCT_get_version },
  { "SCT_set_source", (void *)_cffi_f_SCT_set_source, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2148), (void *)_cffi_d_SCT_set_source },
  { "SMIME_read_PKCS7", (void *)_cffi_f_SMIME_read_PKCS7, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 605), (void *)_cffi_d_SMIME_read_PKCS7 },
  { "SMIME_write_PKCS7", (void *)_cffi_f_SMIME_write_PKCS7, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1246), (void *)_cffi_d_SMIME_write_PKCS7 },
  { "SN_X9_62_c2onb191v4", (void *)_cffi_const_SN_X9_62_c2onb191v4, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2onb191v5", (void *)_cffi_const_SN_X9_62_c2onb191v5, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2onb239v4", (void *)_cffi_const_SN_X9_62_c2onb239v4, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2onb239v5", (void *)_cffi_const_SN_X9_62_c2onb239v5, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb163v1", (void *)_cffi_const_SN_X9_62_c2pnb163v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb163v2", (void *)_cffi_const_SN_X9_62_c2pnb163v2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb163v3", (void *)_cffi_const_SN_X9_62_c2pnb163v3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb176v1", (void *)_cffi_const_SN_X9_62_c2pnb176v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb208w1", (void *)_cffi_const_SN_X9_62_c2pnb208w1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb272w1", (void *)_cffi_const_SN_X9_62_c2pnb272w1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb304w1", (void *)_cffi_const_SN_X9_62_c2pnb304w1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2pnb368w1", (void *)_cffi_const_SN_X9_62_c2pnb368w1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb191v1", (void *)_cffi_const_SN_X9_62_c2tnb191v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb191v2", (void *)_cffi_const_SN_X9_62_c2tnb191v2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb191v3", (void *)_cffi_const_SN_X9_62_c2tnb191v3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb239v1", (void *)_cffi_const_SN_X9_62_c2tnb239v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb239v2", (void *)_cffi_const_SN_X9_62_c2tnb239v2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb239v3", (void *)_cffi_const_SN_X9_62_c2tnb239v3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb359v1", (void *)_cffi_const_SN_X9_62_c2tnb359v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_c2tnb431r1", (void *)_cffi_const_SN_X9_62_c2tnb431r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime192v1", (void *)_cffi_const_SN_X9_62_prime192v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime192v2", (void *)_cffi_const_SN_X9_62_prime192v2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime192v3", (void *)_cffi_const_SN_X9_62_prime192v3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime239v1", (void *)_cffi_const_SN_X9_62_prime239v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime239v2", (void *)_cffi_const_SN_X9_62_prime239v2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime239v3", (void *)_cffi_const_SN_X9_62_prime239v3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_X9_62_prime256v1", (void *)_cffi_const_SN_X9_62_prime256v1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_ipsec3", (void *)_cffi_const_SN_ipsec3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_ipsec4", (void *)_cffi_const_SN_ipsec4, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp112r1", (void *)_cffi_const_SN_secp112r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp112r2", (void *)_cffi_const_SN_secp112r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp128r1", (void *)_cffi_const_SN_secp128r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp128r2", (void *)_cffi_const_SN_secp128r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp160k1", (void *)_cffi_const_SN_secp160k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp160r1", (void *)_cffi_const_SN_secp160r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp160r2", (void *)_cffi_const_SN_secp160r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp192k1", (void *)_cffi_const_SN_secp192k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp224k1", (void *)_cffi_const_SN_secp224k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp224r1", (void *)_cffi_const_SN_secp224r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp256k1", (void *)_cffi_const_SN_secp256k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp384r1", (void *)_cffi_const_SN_secp384r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_secp521r1", (void *)_cffi_const_SN_secp521r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect113r1", (void *)_cffi_const_SN_sect113r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect113r2", (void *)_cffi_const_SN_sect113r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect131r1", (void *)_cffi_const_SN_sect131r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect131r2", (void *)_cffi_const_SN_sect131r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect163k1", (void *)_cffi_const_SN_sect163k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect163r1", (void *)_cffi_const_SN_sect163r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect163r2", (void *)_cffi_const_SN_sect163r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect193r1", (void *)_cffi_const_SN_sect193r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect193r2", (void *)_cffi_const_SN_sect193r2, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect233k1", (void *)_cffi_const_SN_sect233k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect233r1", (void *)_cffi_const_SN_sect233r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect239k1", (void *)_cffi_const_SN_sect239k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect283k1", (void *)_cffi_const_SN_sect283k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect283r1", (void *)_cffi_const_SN_sect283r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect409k1", (void *)_cffi_const_SN_sect409k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect409r1", (void *)_cffi_const_SN_sect409r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect571k1", (void *)_cffi_const_SN_sect571k1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_sect571r1", (void *)_cffi_const_SN_sect571r1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls1", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls1, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls10", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls10, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls11", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls11, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls12", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls12, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls3", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls3, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls4", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls4, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls5", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls5, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls6", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls6, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls7", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls7, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls8", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls8, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SN_wap_wsg_idm_ecid_wtls9", (void *)_cffi_const_SN_wap_wsg_idm_ecid_wtls9, _CFFI_OP(_CFFI_OP_CONSTANT, 57), (void *)0 },
  { "SSL3_RANDOM_SIZE", (void *)_cffi_const_SSL3_RANDOM_SIZE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSLEAY_BUILT_ON", (void *)_cffi_const_SSLEAY_BUILT_ON, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSLEAY_CFLAGS", (void *)_cffi_const_SSLEAY_CFLAGS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSLEAY_DIR", (void *)_cffi_const_SSLEAY_DIR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSLEAY_PLATFORM", (void *)_cffi_const_SSLEAY_PLATFORM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSLEAY_VERSION", (void *)_cffi_const_SSLEAY_VERSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_ACCESS_DENIED", (void *)_cffi_const_SSL_AD_ACCESS_DENIED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_BAD_CERTIFICATE", (void *)_cffi_const_SSL_AD_BAD_CERTIFICATE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_BAD_CERTIFICATE_HASH_VALUE", (void *)_cffi_const_SSL_AD_BAD_CERTIFICATE_HASH_VALUE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE", (void *)_cffi_const_SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_BAD_RECORD_MAC", (void *)_cffi_const_SSL_AD_BAD_RECORD_MAC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_CERTIFICATE_EXPIRED", (void *)_cffi_const_SSL_AD_CERTIFICATE_EXPIRED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_CERTIFICATE_REVOKED", (void *)_cffi_const_SSL_AD_CERTIFICATE_REVOKED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_CERTIFICATE_UNKNOWN", (void *)_cffi_const_SSL_AD_CERTIFICATE_UNKNOWN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_CERTIFICATE_UNOBTAINABLE", (void *)_cffi_const_SSL_AD_CERTIFICATE_UNOBTAINABLE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_CLOSE_NOTIFY", (void *)_cffi_const_SSL_AD_CLOSE_NOTIFY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_DECODE_ERROR", (void *)_cffi_const_SSL_AD_DECODE_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_DECOMPRESSION_FAILURE", (void *)_cffi_const_SSL_AD_DECOMPRESSION_FAILURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_DECRYPT_ERROR", (void *)_cffi_const_SSL_AD_DECRYPT_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_HANDSHAKE_FAILURE", (void *)_cffi_const_SSL_AD_HANDSHAKE_FAILURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_ILLEGAL_PARAMETER", (void *)_cffi_const_SSL_AD_ILLEGAL_PARAMETER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_INSUFFICIENT_SECURITY", (void *)_cffi_const_SSL_AD_INSUFFICIENT_SECURITY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_INTERNAL_ERROR", (void *)_cffi_const_SSL_AD_INTERNAL_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_NO_RENEGOTIATION", (void *)_cffi_const_SSL_AD_NO_RENEGOTIATION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_PROTOCOL_VERSION", (void *)_cffi_const_SSL_AD_PROTOCOL_VERSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_RECORD_OVERFLOW", (void *)_cffi_const_SSL_AD_RECORD_OVERFLOW, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_UNEXPECTED_MESSAGE", (void *)_cffi_const_SSL_AD_UNEXPECTED_MESSAGE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_UNKNOWN_CA", (void *)_cffi_const_SSL_AD_UNKNOWN_CA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_UNKNOWN_PSK_IDENTITY", (void *)_cffi_const_SSL_AD_UNKNOWN_PSK_IDENTITY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_UNRECOGNIZED_NAME", (void *)_cffi_const_SSL_AD_UNRECOGNIZED_NAME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_UNSUPPORTED_CERTIFICATE", (void *)_cffi_const_SSL_AD_UNSUPPORTED_CERTIFICATE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_UNSUPPORTED_EXTENSION", (void *)_cffi_const_SSL_AD_UNSUPPORTED_EXTENSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_AD_USER_CANCELLED", (void *)_cffi_const_SSL_AD_USER_CANCELLED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_ACCEPT_EXIT", (void *)_cffi_const_SSL_CB_ACCEPT_EXIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_ACCEPT_LOOP", (void *)_cffi_const_SSL_CB_ACCEPT_LOOP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_ALERT", (void *)_cffi_const_SSL_CB_ALERT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_CONNECT_EXIT", (void *)_cffi_const_SSL_CB_CONNECT_EXIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_CONNECT_LOOP", (void *)_cffi_const_SSL_CB_CONNECT_LOOP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_EXIT", (void *)_cffi_const_SSL_CB_EXIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_HANDSHAKE_DONE", (void *)_cffi_const_SSL_CB_HANDSHAKE_DONE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_HANDSHAKE_START", (void *)_cffi_const_SSL_CB_HANDSHAKE_START, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_LOOP", (void *)_cffi_const_SSL_CB_LOOP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_READ", (void *)_cffi_const_SSL_CB_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_READ_ALERT", (void *)_cffi_const_SSL_CB_READ_ALERT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_WRITE", (void *)_cffi_const_SSL_CB_WRITE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CB_WRITE_ALERT", (void *)_cffi_const_SSL_CB_WRITE_ALERT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_CIPHER_description", (void *)_cffi_f_SSL_CIPHER_description, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 924), (void *)_cffi_d_SSL_CIPHER_description },
  { "SSL_CIPHER_get_bits", (void *)_cffi_f_SSL_CIPHER_get_bits, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2239), (void *)_cffi_d_SSL_CIPHER_get_bits },
  { "SSL_CIPHER_get_name", (void *)_cffi_f_SSL_CIPHER_get_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 951), (void *)_cffi_d_SSL_CIPHER_get_name },
  { "SSL_CIPHER_get_version", (void *)_cffi_f_SSL_CIPHER_get_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 951), (void *)_cffi_d_SSL_CIPHER_get_version },
  { "SSL_COMP_get_name", (void *)_cffi_f_SSL_COMP_get_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 938), (void *)_cffi_d_SSL_COMP_get_name },
  { "SSL_CTX_add_client_CA", (void *)_cffi_f_SSL_CTX_add_client_CA, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2254), (void *)_cffi_d_SSL_CTX_add_client_CA },
  { "SSL_CTX_add_extra_chain_cert", (void *)_cffi_f_SSL_CTX_add_extra_chain_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3037), (void *)_cffi_d_SSL_CTX_add_extra_chain_cert },
  { "SSL_CTX_check_private_key", (void *)_cffi_f_SSL_CTX_check_private_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2291), (void *)_cffi_d_SSL_CTX_check_private_key },
  { "SSL_CTX_clear_options", (void *)_cffi_f_SSL_CTX_clear_options, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3041), (void *)_cffi_d_SSL_CTX_clear_options },
  { "SSL_CTX_free", (void *)_cffi_f_SSL_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3412), (void *)_cffi_d_SSL_CTX_free },
  { "SSL_CTX_get_cert_store", (void *)_cffi_f_SSL_CTX_get_cert_store, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 894), (void *)_cffi_d_SSL_CTX_get_cert_store },
  { "SSL_CTX_get_ex_data", (void *)_cffi_f_SSL_CTX_get_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3079), (void *)_cffi_d_SSL_CTX_get_ex_data },
  { "SSL_CTX_get_ex_new_index", (void *)_cffi_f_SSL_CTX_get_ex_new_index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2759), (void *)_cffi_d_SSL_CTX_get_ex_new_index },
  { "SSL_CTX_get_info_callback", (void *)_cffi_f_SSL_CTX_get_info_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3627), (void *)_cffi_d_SSL_CTX_get_info_callback },
  { "SSL_CTX_get_mode", (void *)_cffi_f_SSL_CTX_get_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3026), (void *)_cffi_d_SSL_CTX_get_mode },
  { "SSL_CTX_get_options", (void *)_cffi_f_SSL_CTX_get_options, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3026), (void *)_cffi_d_SSL_CTX_get_options },
  { "SSL_CTX_get_session_cache_mode", (void *)_cffi_f_SSL_CTX_get_session_cache_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3026), (void *)_cffi_d_SSL_CTX_get_session_cache_mode },
  { "SSL_CTX_get_ssl_method", (void *)_cffi_f_SSL_CTX_get_ssl_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 703), (void *)_cffi_d_SSL_CTX_get_ssl_method },
  { "SSL_CTX_get_timeout", (void *)_cffi_f_SSL_CTX_get_timeout, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2951), (void *)_cffi_d_SSL_CTX_get_timeout },
  { "SSL_CTX_get_verify_callback", (void *)_cffi_f_SSL_CTX_get_verify_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2835), (void *)_cffi_d_SSL_CTX_get_verify_callback },
  { "SSL_CTX_get_verify_depth", (void *)_cffi_f_SSL_CTX_get_verify_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2291), (void *)_cffi_d_SSL_CTX_get_verify_depth },
  { "SSL_CTX_get_verify_mode", (void *)_cffi_f_SSL_CTX_get_verify_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2291), (void *)_cffi_d_SSL_CTX_get_verify_mode },
  { "SSL_CTX_load_verify_locations", (void *)_cffi_f_SSL_CTX_load_verify_locations, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2262), (void *)_cffi_d_SSL_CTX_load_verify_locations },
  { "SSL_CTX_new", (void *)_cffi_f_SSL_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 700), (void *)_cffi_d_SSL_CTX_new },
  { "SSL_CTX_sess_accept", (void *)_cffi_f_SSL_CTX_sess_accept, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_accept },
  { "SSL_CTX_sess_accept_good", (void *)_cffi_f_SSL_CTX_sess_accept_good, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_accept_good },
  { "SSL_CTX_sess_accept_renegotiate", (void *)_cffi_f_SSL_CTX_sess_accept_renegotiate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_accept_renegotiate },
  { "SSL_CTX_sess_cache_full", (void *)_cffi_f_SSL_CTX_sess_cache_full, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_cache_full },
  { "SSL_CTX_sess_cb_hits", (void *)_cffi_f_SSL_CTX_sess_cb_hits, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_cb_hits },
  { "SSL_CTX_sess_connect", (void *)_cffi_f_SSL_CTX_sess_connect, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_connect },
  { "SSL_CTX_sess_connect_good", (void *)_cffi_f_SSL_CTX_sess_connect_good, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_connect_good },
  { "SSL_CTX_sess_connect_renegotiate", (void *)_cffi_f_SSL_CTX_sess_connect_renegotiate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_connect_renegotiate },
  { "SSL_CTX_sess_hits", (void *)_cffi_f_SSL_CTX_sess_hits, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_hits },
  { "SSL_CTX_sess_misses", (void *)_cffi_f_SSL_CTX_sess_misses, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_misses },
  { "SSL_CTX_sess_number", (void *)_cffi_f_SSL_CTX_sess_number, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_number },
  { "SSL_CTX_sess_timeouts", (void *)_cffi_f_SSL_CTX_sess_timeouts, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2936), (void *)_cffi_d_SSL_CTX_sess_timeouts },
  { "SSL_CTX_set_alpn_protos", (void *)_cffi_f_SSL_CTX_set_alpn_protos, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2286), (void *)_cffi_d_SSL_CTX_set_alpn_protos },
  { "SSL_CTX_set_alpn_select_cb", (void *)_cffi_f_SSL_CTX_set_alpn_select_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3428), (void *)_cffi_d_SSL_CTX_set_alpn_select_cb },
  { "SSL_CTX_set_cert_cb", (void *)_cffi_f_SSL_CTX_set_cert_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3438), (void *)_cffi_d_SSL_CTX_set_cert_cb },
  { "SSL_CTX_set_cert_store", (void *)_cffi_f_SSL_CTX_set_cert_store, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3419), (void *)_cffi_d_SSL_CTX_set_cert_store },
  { "SSL_CTX_set_cert_verify_callback", (void *)_cffi_f_SSL_CTX_set_cert_verify_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3447), (void *)_cffi_d_SSL_CTX_set_cert_verify_callback },
  { "SSL_CTX_set_cipher_list", (void *)_cffi_f_SSL_CTX_set_cipher_list, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2258), (void *)_cffi_d_SSL_CTX_set_cipher_list },
  { "SSL_CTX_set_client_CA_list", (void *)_cffi_f_SSL_CTX_set_client_CA_list, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3415), (void *)_cffi_d_SSL_CTX_set_client_CA_list },
  { "SSL_CTX_set_client_cert_engine", (void *)_cffi_f_SSL_CTX_set_client_cert_engine, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2246), (void *)_cffi_d_SSL_CTX_set_client_cert_engine },
  { "SSL_CTX_set_default_passwd_cb", (void *)_cffi_f_SSL_CTX_set_default_passwd_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3452), (void *)_cffi_d_SSL_CTX_set_default_passwd_cb },
  { "SSL_CTX_set_default_passwd_cb_userdata", (void *)_cffi_f_SSL_CTX_set_default_passwd_cb_userdata, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3465), (void *)_cffi_d_SSL_CTX_set_default_passwd_cb_userdata },
  { "SSL_CTX_set_default_verify_paths", (void *)_cffi_f_SSL_CTX_set_default_verify_paths, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2243), (void *)_cffi_d_SSL_CTX_set_default_verify_paths },
  { "SSL_CTX_set_ecdh_auto", (void *)_cffi_f_SSL_CTX_set_ecdh_auto, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2272), (void *)_cffi_d_SSL_CTX_set_ecdh_auto },
  { "SSL_CTX_set_ex_data", (void *)_cffi_f_SSL_CTX_set_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2281), (void *)_cffi_d_SSL_CTX_set_ex_data },
  { "SSL_CTX_set_info_callback", (void *)_cffi_f_SSL_CTX_set_info_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3469), (void *)_cffi_d_SSL_CTX_set_info_callback },
  { "SSL_CTX_set_mode", (void *)_cffi_f_SSL_CTX_set_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3041), (void *)_cffi_d_SSL_CTX_set_mode },
  { "SSL_CTX_set_next_proto_select_cb", (void *)_cffi_f_SSL_CTX_set_next_proto_select_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3423), (void *)_cffi_d_SSL_CTX_set_next_proto_select_cb },
  { "SSL_CTX_set_next_protos_advertised_cb", (void *)_cffi_f_SSL_CTX_set_next_protos_advertised_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3433), (void *)_cffi_d_SSL_CTX_set_next_protos_advertised_cb },
  { "SSL_CTX_set_options", (void *)_cffi_f_SSL_CTX_set_options, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3041), (void *)_cffi_d_SSL_CTX_set_options },
  { "SSL_CTX_set_session_cache_mode", (void *)_cffi_f_SSL_CTX_set_session_cache_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3041), (void *)_cffi_d_SSL_CTX_set_session_cache_mode },
  { "SSL_CTX_set_session_id_context", (void *)_cffi_f_SSL_CTX_set_session_id_context, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2286), (void *)_cffi_d_SSL_CTX_set_session_id_context },
  { "SSL_CTX_set_timeout", (void *)_cffi_f_SSL_CTX_set_timeout, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2943), (void *)_cffi_d_SSL_CTX_set_timeout },
  { "SSL_CTX_set_tlsext_servername_arg", (void *)_cffi_f_SSL_CTX_set_tlsext_servername_arg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3465), (void *)_cffi_d_SSL_CTX_set_tlsext_servername_arg },
  { "SSL_CTX_set_tlsext_servername_callback", (void *)_cffi_f_SSL_CTX_set_tlsext_servername_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3443), (void *)_cffi_d_SSL_CTX_set_tlsext_servername_callback },
  { "SSL_CTX_set_tlsext_status_arg", (void *)_cffi_f_SSL_CTX_set_tlsext_status_arg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2947), (void *)_cffi_d_SSL_CTX_set_tlsext_status_arg },
  { "SSL_CTX_set_tlsext_status_cb", (void *)_cffi_f_SSL_CTX_set_tlsext_status_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2939), (void *)_cffi_d_SSL_CTX_set_tlsext_status_cb },
  { "SSL_CTX_set_tmp_dh", (void *)_cffi_f_SSL_CTX_set_tmp_dh, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3029), (void *)_cffi_d_SSL_CTX_set_tmp_dh },
  { "SSL_CTX_set_tmp_ecdh", (void *)_cffi_f_SSL_CTX_set_tmp_ecdh, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3033), (void *)_cffi_d_SSL_CTX_set_tmp_ecdh },
  { "SSL_CTX_set_verify", (void *)_cffi_f_SSL_CTX_set_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3460), (void *)_cffi_d_SSL_CTX_set_verify },
  { "SSL_CTX_set_verify_depth", (void *)_cffi_f_SSL_CTX_set_verify_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3456), (void *)_cffi_d_SSL_CTX_set_verify_depth },
  { "SSL_CTX_use_PrivateKey", (void *)_cffi_f_SSL_CTX_use_PrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2250), (void *)_cffi_d_SSL_CTX_use_PrivateKey },
  { "SSL_CTX_use_PrivateKey_ASN1", (void *)_cffi_f_SSL_CTX_use_PrivateKey_ASN1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2696), (void *)_cffi_d_SSL_CTX_use_PrivateKey_ASN1 },
  { "SSL_CTX_use_PrivateKey_file", (void *)_cffi_f_SSL_CTX_use_PrivateKey_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2267), (void *)_cffi_d_SSL_CTX_use_PrivateKey_file },
  { "SSL_CTX_use_certificate", (void *)_cffi_f_SSL_CTX_use_certificate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2254), (void *)_cffi_d_SSL_CTX_use_certificate },
  { "SSL_CTX_use_certificate_ASN1", (void *)_cffi_f_SSL_CTX_use_certificate_ASN1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2276), (void *)_cffi_d_SSL_CTX_use_certificate_ASN1 },
  { "SSL_CTX_use_certificate_chain_file", (void *)_cffi_f_SSL_CTX_use_certificate_chain_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2258), (void *)_cffi_d_SSL_CTX_use_certificate_chain_file },
  { "SSL_CTX_use_certificate_file", (void *)_cffi_f_SSL_CTX_use_certificate_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2267), (void *)_cffi_d_SSL_CTX_use_certificate_file },
  { "SSL_ERROR_NONE", (void *)_cffi_const_SSL_ERROR_NONE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_SSL", (void *)_cffi_const_SSL_ERROR_SSL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_SYSCALL", (void *)_cffi_const_SSL_ERROR_SYSCALL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_WANT_CONNECT", (void *)_cffi_const_SSL_ERROR_WANT_CONNECT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_WANT_READ", (void *)_cffi_const_SSL_ERROR_WANT_READ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_WANT_WRITE", (void *)_cffi_const_SSL_ERROR_WANT_WRITE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_WANT_X509_LOOKUP", (void *)_cffi_const_SSL_ERROR_WANT_X509_LOOKUP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ERROR_ZERO_RETURN", (void *)_cffi_const_SSL_ERROR_ZERO_RETURN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_FILETYPE_ASN1", (void *)_cffi_const_SSL_FILETYPE_ASN1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_FILETYPE_PEM", (void *)_cffi_const_SSL_FILETYPE_PEM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER", (void *)_cffi_const_SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_MODE_AUTO_RETRY", (void *)_cffi_const_SSL_MODE_AUTO_RETRY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_MODE_ENABLE_PARTIAL_WRITE", (void *)_cffi_const_SSL_MODE_ENABLE_PARTIAL_WRITE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_MODE_RELEASE_BUFFERS", (void *)_cffi_const_SSL_MODE_RELEASE_BUFFERS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_ALL", (void *)_cffi_const_SSL_OP_ALL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION", (void *)_cffi_const_SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_CIPHER_SERVER_PREFERENCE", (void *)_cffi_const_SSL_OP_CIPHER_SERVER_PREFERENCE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_COOKIE_EXCHANGE", (void *)_cffi_const_SSL_OP_COOKIE_EXCHANGE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS", (void *)_cffi_const_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_EPHEMERAL_RSA", (void *)_cffi_const_SSL_OP_EPHEMERAL_RSA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_LEGACY_SERVER_CONNECT", (void *)_cffi_const_SSL_OP_LEGACY_SERVER_CONNECT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER", (void *)_cffi_const_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_MICROSOFT_SESS_ID_BUG", (void *)_cffi_const_SSL_OP_MICROSOFT_SESS_ID_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_MSIE_SSLV2_RSA_PADDING", (void *)_cffi_const_SSL_OP_MSIE_SSLV2_RSA_PADDING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NETSCAPE_CA_DN_BUG", (void *)_cffi_const_SSL_OP_NETSCAPE_CA_DN_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NETSCAPE_CHALLENGE_BUG", (void *)_cffi_const_SSL_OP_NETSCAPE_CHALLENGE_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG", (void *)_cffi_const_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG", (void *)_cffi_const_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_COMPRESSION", (void *)_cffi_const_SSL_OP_NO_COMPRESSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_QUERY_MTU", (void *)_cffi_const_SSL_OP_NO_QUERY_MTU, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_SSLv2", (void *)_cffi_const_SSL_OP_NO_SSLv2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_SSLv3", (void *)_cffi_const_SSL_OP_NO_SSLv3, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_TICKET", (void *)_cffi_const_SSL_OP_NO_TICKET, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_TLSv1", (void *)_cffi_const_SSL_OP_NO_TLSv1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_TLSv1_1", (void *)_cffi_const_SSL_OP_NO_TLSv1_1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_NO_TLSv1_2", (void *)_cffi_const_SSL_OP_NO_TLSv1_2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_PKCS1_CHECK_1", (void *)_cffi_const_SSL_OP_PKCS1_CHECK_1, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_PKCS1_CHECK_2", (void *)_cffi_const_SSL_OP_PKCS1_CHECK_2, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_SINGLE_DH_USE", (void *)_cffi_const_SSL_OP_SINGLE_DH_USE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_SINGLE_ECDH_USE", (void *)_cffi_const_SSL_OP_SINGLE_ECDH_USE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_SSLEAY_080_CLIENT_DH_BUG", (void *)_cffi_const_SSL_OP_SSLEAY_080_CLIENT_DH_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG", (void *)_cffi_const_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_TLS_BLOCK_PADDING_BUG", (void *)_cffi_const_SSL_OP_TLS_BLOCK_PADDING_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_TLS_D5_BUG", (void *)_cffi_const_SSL_OP_TLS_D5_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_OP_TLS_ROLLBACK_BUG", (void *)_cffi_const_SSL_OP_TLS_ROLLBACK_BUG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_RECEIVED_SHUTDOWN", (void *)_cffi_const_SSL_RECEIVED_SHUTDOWN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SENT_SHUTDOWN", (void *)_cffi_const_SSL_SENT_SHUTDOWN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESSION_free", (void *)_cffi_f_SSL_SESSION_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3473), (void *)_cffi_d_SSL_SESSION_free },
  { "SSL_SESSION_get_id", (void *)_cffi_f_SSL_SESSION_get_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3010), (void *)_cffi_d_SSL_SESSION_get_id },
  { "SSL_SESSION_get_master_key", (void *)_cffi_f_SSL_SESSION_get_master_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2995), (void *)_cffi_d_SSL_SESSION_get_master_key },
  { "SSL_SESSION_print", (void *)_cffi_f_SSL_SESSION_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1274), (void *)_cffi_d_SSL_SESSION_print },
  { "SSL_SESSION_set1_id_context", (void *)_cffi_f_SSL_SESSION_set1_id_context, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2294), (void *)_cffi_d_SSL_SESSION_set1_id_context },
  { "SSL_SESS_CACHE_BOTH", (void *)_cffi_const_SSL_SESS_CACHE_BOTH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_CLIENT", (void *)_cffi_const_SSL_SESS_CACHE_CLIENT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_NO_AUTO_CLEAR", (void *)_cffi_const_SSL_SESS_CACHE_NO_AUTO_CLEAR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_NO_INTERNAL", (void *)_cffi_const_SSL_SESS_CACHE_NO_INTERNAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_NO_INTERNAL_LOOKUP", (void *)_cffi_const_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_NO_INTERNAL_STORE", (void *)_cffi_const_SSL_SESS_CACHE_NO_INTERNAL_STORE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_OFF", (void *)_cffi_const_SSL_SESS_CACHE_OFF, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_SESS_CACHE_SERVER", (void *)_cffi_const_SSL_SESS_CACHE_SERVER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_ACCEPT", (void *)_cffi_const_SSL_ST_ACCEPT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_BEFORE", (void *)_cffi_const_SSL_ST_BEFORE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_CONNECT", (void *)_cffi_const_SSL_ST_CONNECT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_INIT", (void *)_cffi_const_SSL_ST_INIT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_MASK", (void *)_cffi_const_SSL_ST_MASK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_OK", (void *)_cffi_const_SSL_ST_OK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_ST_RENEGOTIATE", (void *)_cffi_const_SSL_ST_RENEGOTIATE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_TLSEXT_ERR_ALERT_FATAL", (void *)_cffi_const_SSL_TLSEXT_ERR_ALERT_FATAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_TLSEXT_ERR_ALERT_WARNING", (void *)_cffi_const_SSL_TLSEXT_ERR_ALERT_WARNING, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_TLSEXT_ERR_NOACK", (void *)_cffi_const_SSL_TLSEXT_ERR_NOACK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_TLSEXT_ERR_OK", (void *)_cffi_const_SSL_TLSEXT_ERR_OK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_VERIFY_CLIENT_ONCE", (void *)_cffi_const_SSL_VERIFY_CLIENT_ONCE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_VERIFY_FAIL_IF_NO_PEER_CERT", (void *)_cffi_const_SSL_VERIFY_FAIL_IF_NO_PEER_CERT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_VERIFY_NONE", (void *)_cffi_const_SSL_VERIFY_NONE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_VERIFY_PEER", (void *)_cffi_const_SSL_VERIFY_PEER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "SSL_check_private_key", (void *)_cffi_f_SSL_check_private_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_check_private_key },
  { "SSL_do_handshake", (void *)_cffi_f_SSL_do_handshake, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2152), (void *)_cffi_d_SSL_do_handshake },
  { "SSL_free", (void *)_cffi_f_SSL_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3372), (void *)_cffi_d_SSL_free },
  { "SSL_get0_alpn_selected", (void *)_cffi_f_SSL_get0_alpn_selected, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3407), (void *)_cffi_d_SSL_get0_alpn_selected },
  { "SSL_get0_next_proto_negotiated", (void *)_cffi_f_SSL_get0_next_proto_negotiated, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3407), (void *)_cffi_d_SSL_get0_next_proto_negotiated },
  { "SSL_get1_session", (void *)_cffi_f_SSL_get1_session, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 708), (void *)_cffi_d_SSL_get1_session },
  { "SSL_get_SSL_CTX", (void *)_cffi_f_SSL_get_SSL_CTX, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 697), (void *)_cffi_d_SSL_get_SSL_CTX },
  { "SSL_get_app_data", (void *)_cffi_f_SSL_get_app_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 921), (void *)_cffi_d_SSL_get_app_data },
  { "SSL_get_cipher_list", (void *)_cffi_f_SSL_get_cipher_list, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 947), (void *)_cffi_d_SSL_get_cipher_list },
  { "SSL_get_ciphers", (void *)_cffi_f_SSL_get_ciphers, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_SSL_get_ciphers },
  { "SSL_get_client_CA_list", (void *)_cffi_f_SSL_get_client_CA_list, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 264), (void *)_cffi_d_SSL_get_client_CA_list },
  { "SSL_get_client_random", (void *)_cffi_f_SSL_get_client_random, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2985), (void *)_cffi_d_SSL_get_client_random },
  { "SSL_get_current_cipher", (void *)_cffi_f_SSL_get_current_cipher, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 690), (void *)_cffi_d_SSL_get_current_cipher },
  { "SSL_get_current_compression", (void *)_cffi_f_SSL_get_current_compression, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 229), (void *)_cffi_d_SSL_get_current_compression },
  { "SSL_get_current_expansion", (void *)_cffi_f_SSL_get_current_expansion, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 229), (void *)_cffi_d_SSL_get_current_expansion },
  { "SSL_get_error", (void *)_cffi_f_SSL_get_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2235), (void *)_cffi_d_SSL_get_error },
  { "SSL_get_ex_data", (void *)_cffi_f_SSL_get_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3075), (void *)_cffi_d_SSL_get_ex_data },
  { "SSL_get_ex_data_X509_STORE_CTX_idx", (void *)_cffi_f_SSL_get_ex_data_X509_STORE_CTX_idx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_SSL_get_ex_data_X509_STORE_CTX_idx },
  { "SSL_get_ex_new_index", (void *)_cffi_f_SSL_get_ex_new_index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2759), (void *)_cffi_d_SSL_get_ex_new_index },
  { "SSL_get_finished", (void *)_cffi_f_SSL_get_finished, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2990), (void *)_cffi_d_SSL_get_finished },
  { "SSL_get_info_callback", (void *)_cffi_f_SSL_get_info_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3624), (void *)_cffi_d_SSL_get_info_callback },
  { "SSL_get_mode", (void *)_cffi_f_SSL_get_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3019), (void *)_cffi_d_SSL_get_mode },
  { "SSL_get_options", (void *)_cffi_f_SSL_get_options, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3019), (void *)_cffi_d_SSL_get_options },
  { "SSL_get_peer_cert_chain", (void *)_cffi_f_SSL_get_peer_cert_chain, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 254), (void *)_cffi_d_SSL_get_peer_cert_chain },
  { "SSL_get_peer_certificate", (void *)_cffi_f_SSL_get_peer_certificate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 730), (void *)_cffi_d_SSL_get_peer_certificate },
  { "SSL_get_peer_finished", (void *)_cffi_f_SSL_get_peer_finished, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2990), (void *)_cffi_d_SSL_get_peer_finished },
  { "SSL_get_rbio", (void *)_cffi_f_SSL_get_rbio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 185), (void *)_cffi_d_SSL_get_rbio },
  { "SSL_get_secure_renegotiation_support", (void *)_cffi_f_SSL_get_secure_renegotiation_support, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2911), (void *)_cffi_d_SSL_get_secure_renegotiation_support },
  { "SSL_get_server_random", (void *)_cffi_f_SSL_get_server_random, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2985), (void *)_cffi_d_SSL_get_server_random },
  { "SSL_get_server_tmp_key", (void *)_cffi_f_SSL_get_server_tmp_key, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2914), (void *)_cffi_d_SSL_get_server_tmp_key },
  { "SSL_get_servername", (void *)_cffi_f_SSL_get_servername, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 947), (void *)_cffi_d_SSL_get_servername },
  { "SSL_get_session", (void *)_cffi_f_SSL_get_session, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 711), (void *)_cffi_d_SSL_get_session },
  { "SSL_get_shutdown", (void *)_cffi_f_SSL_get_shutdown, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_get_shutdown },
  { "SSL_get_tlsext_status_ocsp_resp", (void *)_cffi_f_SSL_get_tlsext_status_ocsp_resp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2932), (void *)_cffi_d_SSL_get_tlsext_status_ocsp_resp },
  { "SSL_get_verify_callback", (void *)_cffi_f_SSL_get_verify_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2832), (void *)_cffi_d_SSL_get_verify_callback },
  { "SSL_get_verify_depth", (void *)_cffi_f_SSL_get_verify_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_get_verify_depth },
  { "SSL_get_verify_mode", (void *)_cffi_f_SSL_get_verify_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_get_verify_mode },
  { "SSL_get_version", (void *)_cffi_f_SSL_get_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 944), (void *)_cffi_d_SSL_get_version },
  { "SSL_get_wbio", (void *)_cffi_f_SSL_get_wbio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 185), (void *)_cffi_d_SSL_get_wbio },
  { "SSL_library_init", (void *)_cffi_f_SSL_library_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d_SSL_library_init },
  { "SSL_load_client_CA_file", (void *)_cffi_f_SSL_load_client_CA_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 267), (void *)_cffi_d_SSL_load_client_CA_file },
  { "SSL_load_error_strings", (void *)_cffi_f_SSL_load_error_strings, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3622), (void *)_cffi_d_SSL_load_error_strings },
  { "SSL_new", (void *)_cffi_f_SSL_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 683), (void *)_cffi_d_SSL_new },
  { "SSL_peek", (void *)_cffi_f_SSL_peek, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2217), (void *)_cffi_d_SSL_peek },
  { "SSL_pending", (void *)_cffi_f_SSL_pending, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_pending },
  { "SSL_read", (void *)_cffi_f_SSL_read, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2217), (void *)_cffi_d_SSL_read },
  { "SSL_renegotiate", (void *)_cffi_f_SSL_renegotiate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2152), (void *)_cffi_d_SSL_renegotiate },
  { "SSL_renegotiate_pending", (void *)_cffi_f_SSL_renegotiate_pending, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2152), (void *)_cffi_d_SSL_renegotiate_pending },
  { "SSL_select_next_proto", (void *)_cffi_f_SSL_select_next_proto, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2770), (void *)_cffi_d_SSL_select_next_proto },
  { "SSL_session_reused", (void *)_cffi_f_SSL_session_reused, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2911), (void *)_cffi_d_SSL_session_reused },
  { "SSL_set_SSL_CTX", (void *)_cffi_f_SSL_set_SSL_CTX, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 693), (void *)_cffi_d_SSL_set_SSL_CTX },
  { "SSL_set_accept_state", (void *)_cffi_f_SSL_set_accept_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3372), (void *)_cffi_d_SSL_set_accept_state },
  { "SSL_set_alpn_protos", (void *)_cffi_f_SSL_set_alpn_protos, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2208), (void *)_cffi_d_SSL_set_alpn_protos },
  { "SSL_set_app_data", (void *)_cffi_f_SSL_set_app_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3380), (void *)_cffi_d_SSL_set_app_data },
  { "SSL_set_bio", (void *)_cffi_f_SSL_set_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3375), (void *)_cffi_d_SSL_set_bio },
  { "SSL_set_cert_cb", (void *)_cffi_f_SSL_set_cert_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3384), (void *)_cffi_d_SSL_set_cert_cb },
  { "SSL_set_connect_state", (void *)_cffi_f_SSL_set_connect_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3372), (void *)_cffi_d_SSL_set_connect_state },
  { "SSL_set_ex_data", (void *)_cffi_f_SSL_set_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2176), (void *)_cffi_d_SSL_set_ex_data },
  { "SSL_set_fd", (void *)_cffi_f_SSL_set_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2172), (void *)_cffi_d_SSL_set_fd },
  { "SSL_set_info_callback", (void *)_cffi_f_SSL_set_info_callback, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3398), (void *)_cffi_d_SSL_set_info_callback },
  { "SSL_set_mode", (void *)_cffi_f_SSL_set_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3022), (void *)_cffi_d_SSL_set_mode },
  { "SSL_set_options", (void *)_cffi_f_SSL_set_options, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3022), (void *)_cffi_d_SSL_set_options },
  { "SSL_set_read_ahead", (void *)_cffi_f_SSL_set_read_ahead, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3389), (void *)_cffi_d_SSL_set_read_ahead },
  { "SSL_set_session", (void *)_cffi_f_SSL_set_session, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2159), (void *)_cffi_d_SSL_set_session },
  { "SSL_set_shutdown", (void *)_cffi_f_SSL_set_shutdown, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3389), (void *)_cffi_d_SSL_set_shutdown },
  { "SSL_set_tlsext_host_name", (void *)_cffi_f_SSL_set_tlsext_host_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3380), (void *)_cffi_d_SSL_set_tlsext_host_name },
  { "SSL_set_tlsext_status_ocsp_resp", (void *)_cffi_f_SSL_set_tlsext_status_ocsp_resp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2927), (void *)_cffi_d_SSL_set_tlsext_status_ocsp_resp },
  { "SSL_set_tlsext_status_type", (void *)_cffi_f_SSL_set_tlsext_status_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2918), (void *)_cffi_d_SSL_set_tlsext_status_type },
  { "SSL_set_verify", (void *)_cffi_f_SSL_set_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3393), (void *)_cffi_d_SSL_set_verify },
  { "SSL_set_verify_depth", (void *)_cffi_f_SSL_set_verify_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3389), (void *)_cffi_d_SSL_set_verify_depth },
  { "SSL_shutdown", (void *)_cffi_f_SSL_shutdown, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2152), (void *)_cffi_d_SSL_shutdown },
  { "SSL_state_string_long", (void *)_cffi_f_SSL_state_string_long, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 944), (void *)_cffi_d_SSL_state_string_long },
  { "SSL_total_renegotiations", (void *)_cffi_f_SSL_total_renegotiations, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2911), (void *)_cffi_d_SSL_total_renegotiations },
  { "SSL_use_PrivateKey", (void *)_cffi_f_SSL_use_PrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2155), (void *)_cffi_d_SSL_use_PrivateKey },
  { "SSL_use_PrivateKey_ASN1", (void *)_cffi_f_SSL_use_PrivateKey_ASN1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2690), (void *)_cffi_d_SSL_use_PrivateKey_ASN1 },
  { "SSL_use_PrivateKey_file", (void *)_cffi_f_SSL_use_PrivateKey_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2167), (void *)_cffi_d_SSL_use_PrivateKey_file },
  { "SSL_use_certificate", (void *)_cffi_f_SSL_use_certificate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2163), (void *)_cffi_d_SSL_use_certificate },
  { "SSL_use_certificate_ASN1", (void *)_cffi_f_SSL_use_certificate_ASN1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2203), (void *)_cffi_d_SSL_use_certificate_ASN1 },
  { "SSL_use_certificate_file", (void *)_cffi_f_SSL_use_certificate_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2167), (void *)_cffi_d_SSL_use_certificate_file },
  { "SSL_version", (void *)_cffi_f_SSL_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_version },
  { "SSL_want_read", (void *)_cffi_f_SSL_want_read, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_want_read },
  { "SSL_want_write", (void *)_cffi_f_SSL_want_write, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2227), (void *)_cffi_d_SSL_want_write },
  { "SSL_write", (void *)_cffi_f_SSL_write, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2222), (void *)_cffi_d_SSL_write },
  { "SSLeay", (void *)_cffi_f_SSLeay, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 3069), (void *)_cffi_d_SSLeay },
  { "SSLeay_version", (void *)_cffi_f_SSLeay_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 958), (void *)_cffi_d_SSLeay_version },
  { "SSLv23_client_method", (void *)_cffi_f_SSLv23_client_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_SSLv23_client_method },
  { "SSLv23_method", (void *)_cffi_f_SSLv23_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_SSLv23_method },
  { "SSLv23_server_method", (void *)_cffi_f_SSLv23_server_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_SSLv23_server_method },
  { "SSLv3_client_method", (void *)_cffi_f_SSLv3_client_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_SSLv3_client_method },
  { "SSLv3_method", (void *)_cffi_f_SSLv3_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_SSLv3_method },
  { "SSLv3_server_method", (void *)_cffi_f_SSLv3_server_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_SSLv3_server_method },
  { "TLSEXT_NAMETYPE_host_name", (void *)_cffi_const_TLSEXT_NAMETYPE_host_name, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "TLSEXT_STATUSTYPE_ocsp", (void *)_cffi_const_TLSEXT_STATUSTYPE_ocsp, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "TLS_ST_BEFORE", (void *)_cffi_const_TLS_ST_BEFORE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "TLS_ST_OK", (void *)_cffi_const_TLS_ST_OK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "TLSv1_1_client_method", (void *)_cffi_f_TLSv1_1_client_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_1_client_method },
  { "TLSv1_1_method", (void *)_cffi_f_TLSv1_1_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_1_method },
  { "TLSv1_1_server_method", (void *)_cffi_f_TLSv1_1_server_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_1_server_method },
  { "TLSv1_2_client_method", (void *)_cffi_f_TLSv1_2_client_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_2_client_method },
  { "TLSv1_2_method", (void *)_cffi_f_TLSv1_2_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_2_method },
  { "TLSv1_2_server_method", (void *)_cffi_f_TLSv1_2_server_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_2_server_method },
  { "TLSv1_client_method", (void *)_cffi_f_TLSv1_client_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_client_method },
  { "TLSv1_method", (void *)_cffi_f_TLSv1_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_method },
  { "TLSv1_server_method", (void *)_cffi_f_TLSv1_server_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 706), (void *)_cffi_d_TLSv1_server_method },
  { "USERNOTICE_free", (void *)_cffi_f_USERNOTICE_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3476), (void *)_cffi_d_USERNOTICE_free },
  { "USERNOTICE_new", (void *)_cffi_f_USERNOTICE_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 714), (void *)_cffi_d_USERNOTICE_new },
  { "V_ASN1_GENERALIZEDTIME", (void *)_cffi_const_V_ASN1_GENERALIZEDTIME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509V3_EXT_add_alias", (void *)_cffi_f_X509V3_EXT_add_alias, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2706), (void *)_cffi_d_X509V3_EXT_add_alias },
  { "X509V3_EXT_conf_nid", (void *)_cffi_f_X509V3_EXT_conf_nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 783), (void *)_cffi_d_X509V3_EXT_conf_nid },
  { "X509V3_EXT_d2i", (void *)_cffi_f_X509V3_EXT_d2i, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3096), (void *)_cffi_d_X509V3_EXT_d2i },
  { "X509V3_EXT_get", (void *)_cffi_f_X509V3_EXT_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 744), (void *)_cffi_d_X509V3_EXT_get },
  { "X509V3_EXT_get_nid", (void *)_cffi_f_X509V3_EXT_get_nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 747), (void *)_cffi_d_X509V3_EXT_get_nid },
  { "X509V3_EXT_i2d", (void *)_cffi_f_X509V3_EXT_i2d, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 826), (void *)_cffi_d_X509V3_EXT_i2d },
  { "X509V3_EXT_nconf", (void *)_cffi_f_X509V3_EXT_nconf, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 777), (void *)_cffi_d_X509V3_EXT_nconf },
  { "X509V3_EXT_print", (void *)_cffi_f_X509V3_EXT_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1292), (void *)_cffi_d_X509V3_EXT_print },
  { "X509V3_set_ctx", (void *)_cffi_f_X509V3_set_ctx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3482), (void *)_cffi_d_X509V3_set_ctx },
  { "X509V3_set_ctx_nodb", (void *)_cffi_f_X509V3_set_ctx_nodb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3093), (void *)_cffi_d_X509V3_set_ctx_nodb },
  { "X509_CRL_add0_revoked", (void *)_cffi_f_X509_CRL_add0_revoked, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2393), (void *)_cffi_d_X509_CRL_add0_revoked },
  { "X509_CRL_add_ext", (void *)_cffi_f_X509_CRL_add_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2384), (void *)_cffi_d_X509_CRL_add_ext },
  { "X509_CRL_cmp", (void *)_cffi_f_X509_CRL_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2405), (void *)_cffi_d_X509_CRL_cmp },
  { "X509_CRL_free", (void *)_cffi_f_X509_CRL_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3490), (void *)_cffi_d_X509_CRL_free },
  { "X509_CRL_get0_signature", (void *)_cffi_f_X509_CRL_get0_signature, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3493), (void *)_cffi_d_X509_CRL_get0_signature },
  { "X509_CRL_get_REVOKED", (void *)_cffi_f_X509_CRL_get_REVOKED, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 280), (void *)_cffi_d_X509_CRL_get_REVOKED },
  { "X509_CRL_get_ext", (void *)_cffi_f_X509_CRL_get_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 805), (void *)_cffi_d_X509_CRL_get_ext },
  { "X509_CRL_get_ext_count", (void *)_cffi_f_X509_CRL_get_ext_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2368), (void *)_cffi_d_X509_CRL_get_ext_count },
  { "X509_CRL_get_issuer", (void *)_cffi_f_X509_CRL_get_issuer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 843), (void *)_cffi_d_X509_CRL_get_issuer },
  { "X509_CRL_get_lastUpdate", (void *)_cffi_f_X509_CRL_get_lastUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_X509_CRL_get_lastUpdate },
  { "X509_CRL_get_nextUpdate", (void *)_cffi_f_X509_CRL_get_nextUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_X509_CRL_get_nextUpdate },
  { "X509_CRL_get_version", (void *)_cffi_f_X509_CRL_get_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2368), (void *)_cffi_d_X509_CRL_get_version },
  { "X509_CRL_new", (void *)_cffi_f_X509_CRL_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 775), (void *)_cffi_d_X509_CRL_new },
  { "X509_CRL_print", (void *)_cffi_f_X509_CRL_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1288), (void *)_cffi_d_X509_CRL_print },
  { "X509_CRL_set_issuer_name", (void *)_cffi_f_X509_CRL_set_issuer_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2389), (void *)_cffi_d_X509_CRL_set_issuer_name },
  { "X509_CRL_set_lastUpdate", (void *)_cffi_f_X509_CRL_set_lastUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2371), (void *)_cffi_d_X509_CRL_set_lastUpdate },
  { "X509_CRL_set_nextUpdate", (void *)_cffi_f_X509_CRL_set_nextUpdate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2371), (void *)_cffi_d_X509_CRL_set_nextUpdate },
  { "X509_CRL_set_version", (void *)_cffi_f_X509_CRL_set_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2397), (void *)_cffi_d_X509_CRL_set_version },
  { "X509_CRL_sign", (void *)_cffi_f_X509_CRL_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2379), (void *)_cffi_d_X509_CRL_sign },
  { "X509_CRL_sort", (void *)_cffi_f_X509_CRL_sort, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2368), (void *)_cffi_d_X509_CRL_sort },
  { "X509_CRL_verify", (void *)_cffi_f_X509_CRL_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2375), (void *)_cffi_d_X509_CRL_verify },
  { "X509_EXTENSION_create_by_OBJ", (void *)_cffi_f_X509_EXTENSION_create_by_OBJ, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 809), (void *)_cffi_d_X509_EXTENSION_create_by_OBJ },
  { "X509_EXTENSION_dup", (void *)_cffi_f_X509_EXTENSION_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 815), (void *)_cffi_d_X509_EXTENSION_dup },
  { "X509_EXTENSION_free", (void *)_cffi_f_X509_EXTENSION_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3498), (void *)_cffi_d_X509_EXTENSION_free },
  { "X509_EXTENSION_get_critical", (void *)_cffi_f_X509_EXTENSION_get_critical, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2413), (void *)_cffi_d_X509_EXTENSION_get_critical },
  { "X509_EXTENSION_get_data", (void *)_cffi_f_X509_EXTENSION_get_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_X509_EXTENSION_get_data },
  { "X509_EXTENSION_get_object", (void *)_cffi_f_X509_EXTENSION_get_object, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 50), (void *)_cffi_d_X509_EXTENSION_get_object },
  { "X509_FLAG_COMPAT", (void *)_cffi_const_X509_FLAG_COMPAT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_ATTRIBUTES", (void *)_cffi_const_X509_FLAG_NO_ATTRIBUTES, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_AUX", (void *)_cffi_const_X509_FLAG_NO_AUX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_EXTENSIONS", (void *)_cffi_const_X509_FLAG_NO_EXTENSIONS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_HEADER", (void *)_cffi_const_X509_FLAG_NO_HEADER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_ISSUER", (void *)_cffi_const_X509_FLAG_NO_ISSUER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_PUBKEY", (void *)_cffi_const_X509_FLAG_NO_PUBKEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_SERIAL", (void *)_cffi_const_X509_FLAG_NO_SERIAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_SIGDUMP", (void *)_cffi_const_X509_FLAG_NO_SIGDUMP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_SIGNAME", (void *)_cffi_const_X509_FLAG_NO_SIGNAME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_SUBJECT", (void *)_cffi_const_X509_FLAG_NO_SUBJECT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_VALIDITY", (void *)_cffi_const_X509_FLAG_NO_VALIDITY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_FLAG_NO_VERSION", (void *)_cffi_const_X509_FLAG_NO_VERSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_LU_CRL", (void *)_cffi_const_X509_LU_CRL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_LU_X509", (void *)_cffi_const_X509_LU_X509, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_NAME_ENTRY_create_by_OBJ", (void *)_cffi_f_X509_NAME_ENTRY_create_by_OBJ, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 862), (void *)_cffi_d_X509_NAME_ENTRY_create_by_OBJ },
  { "X509_NAME_ENTRY_free", (void *)_cffi_f_X509_NAME_ENTRY_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3507), (void *)_cffi_d_X509_NAME_ENTRY_free },
  { "X509_NAME_ENTRY_get_data", (void *)_cffi_f_X509_NAME_ENTRY_get_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 85), (void *)_cffi_d_X509_NAME_ENTRY_get_data },
  { "X509_NAME_ENTRY_get_object", (void *)_cffi_f_X509_NAME_ENTRY_get_object, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 53), (void *)_cffi_d_X509_NAME_ENTRY_get_object },
  { "X509_NAME_add_entry", (void *)_cffi_f_X509_NAME_add_entry, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2440), (void *)_cffi_d_X509_NAME_add_entry },
  { "X509_NAME_add_entry_by_NID", (void *)_cffi_f_X509_NAME_add_entry_by_NID, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2460), (void *)_cffi_d_X509_NAME_add_entry_by_NID },
  { "X509_NAME_add_entry_by_OBJ", (void *)_cffi_f_X509_NAME_add_entry_by_OBJ, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2431), (void *)_cffi_d_X509_NAME_add_entry_by_OBJ },
  { "X509_NAME_add_entry_by_txt", (void *)_cffi_f_X509_NAME_add_entry_by_txt, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2446), (void *)_cffi_d_X509_NAME_add_entry_by_txt },
  { "X509_NAME_cmp", (void *)_cffi_f_X509_NAME_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2473), (void *)_cffi_d_X509_NAME_cmp },
  { "X509_NAME_delete_entry", (void *)_cffi_f_X509_NAME_delete_entry, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 858), (void *)_cffi_d_X509_NAME_delete_entry },
  { "X509_NAME_dup", (void *)_cffi_f_X509_NAME_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 846), (void *)_cffi_d_X509_NAME_dup },
  { "X509_NAME_entry_count", (void *)_cffi_f_X509_NAME_entry_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2428), (void *)_cffi_d_X509_NAME_entry_count },
  { "X509_NAME_free", (void *)_cffi_f_X509_NAME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3504), (void *)_cffi_d_X509_NAME_free },
  { "X509_NAME_get_entry", (void *)_cffi_f_X509_NAME_get_entry, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 858), (void *)_cffi_d_X509_NAME_get_entry },
  { "X509_NAME_get_index_by_NID", (void *)_cffi_f_X509_NAME_get_index_by_NID, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2455), (void *)_cffi_d_X509_NAME_get_index_by_NID },
  { "X509_NAME_hash", (void *)_cffi_f_X509_NAME_hash, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3048), (void *)_cffi_d_X509_NAME_hash },
  { "X509_NAME_new", (void *)_cffi_f_X509_NAME_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 852), (void *)_cffi_d_X509_NAME_new },
  { "X509_NAME_oneline", (void *)_cffi_f_X509_NAME_oneline, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 929), (void *)_cffi_d_X509_NAME_oneline },
  { "X509_OBJECT_get0_X509", (void *)_cffi_f_X509_OBJECT_get0_X509, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 736), (void *)_cffi_d_X509_OBJECT_get0_X509 },
  { "X509_OBJECT_get_type", (void *)_cffi_f_X509_OBJECT_get_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2480), (void *)_cffi_d_X509_OBJECT_get_type },
  { "X509_REQ_add_extensions", (void *)_cffi_f_X509_REQ_add_extensions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2492), (void *)_cffi_d_X509_REQ_add_extensions },
  { "X509_REQ_digest", (void *)_cffi_f_X509_REQ_digest, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2508), (void *)_cffi_d_X509_REQ_digest },
  { "X509_REQ_free", (void *)_cffi_f_X509_REQ_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3510), (void *)_cffi_d_X509_REQ_free },
  { "X509_REQ_get0_signature", (void *)_cffi_f_X509_REQ_get0_signature, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3513), (void *)_cffi_d_X509_REQ_get0_signature },
  { "X509_REQ_get_extensions", (void *)_cffi_f_X509_REQ_get_extensions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 831), (void *)_cffi_d_X509_REQ_get_extensions },
  { "X509_REQ_get_pubkey", (void *)_cffi_f_X509_REQ_get_pubkey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 501), (void *)_cffi_d_X509_REQ_get_pubkey },
  { "X509_REQ_get_subject_name", (void *)_cffi_f_X509_REQ_get_subject_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 849), (void *)_cffi_d_X509_REQ_get_subject_name },
  { "X509_REQ_get_version", (void *)_cffi_f_X509_REQ_get_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2957), (void *)_cffi_d_X509_REQ_get_version },
  { "X509_REQ_new", (void *)_cffi_f_X509_REQ_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 883), (void *)_cffi_d_X509_REQ_new },
  { "X509_REQ_print", (void *)_cffi_f_X509_REQ_print, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1298), (void *)_cffi_d_X509_REQ_print },
  { "X509_REQ_print_ex", (void *)_cffi_f_X509_REQ_print_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1302), (void *)_cffi_d_X509_REQ_print_ex },
  { "X509_REQ_set_pubkey", (void *)_cffi_f_X509_REQ_set_pubkey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2483), (void *)_cffi_d_X509_REQ_set_pubkey },
  { "X509_REQ_set_subject_name", (void *)_cffi_f_X509_REQ_set_subject_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2496), (void *)_cffi_d_X509_REQ_set_subject_name },
  { "X509_REQ_set_version", (void *)_cffi_f_X509_REQ_set_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2500), (void *)_cffi_d_X509_REQ_set_version },
  { "X509_REQ_sign", (void *)_cffi_f_X509_REQ_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2487), (void *)_cffi_d_X509_REQ_sign },
  { "X509_REQ_verify", (void *)_cffi_f_X509_REQ_verify, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2483), (void *)_cffi_d_X509_REQ_verify },
  { "X509_REVOKED_add1_ext_i2d", (void *)_cffi_f_X509_REVOKED_add1_ext_i2d, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2534), (void *)_cffi_d_X509_REVOKED_add1_ext_i2d },
  { "X509_REVOKED_add_ext", (void *)_cffi_f_X509_REVOKED_add_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2529), (void *)_cffi_d_X509_REVOKED_add_ext },
  { "X509_REVOKED_delete_ext", (void *)_cffi_f_X509_REVOKED_delete_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 822), (void *)_cffi_d_X509_REVOKED_delete_ext },
  { "X509_REVOKED_free", (void *)_cffi_f_X509_REVOKED_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3518), (void *)_cffi_d_X509_REVOKED_free },
  { "X509_REVOKED_get0_revocationDate", (void *)_cffi_f_X509_REVOKED_get0_revocationDate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 96), (void *)_cffi_d_X509_REVOKED_get0_revocationDate },
  { "X509_REVOKED_get0_serialNumber", (void *)_cffi_f_X509_REVOKED_get0_serialNumber, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 32), (void *)_cffi_d_X509_REVOKED_get0_serialNumber },
  { "X509_REVOKED_get_ext", (void *)_cffi_f_X509_REVOKED_get_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 822), (void *)_cffi_d_X509_REVOKED_get_ext },
  { "X509_REVOKED_get_ext_count", (void *)_cffi_f_X509_REVOKED_get_ext_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2518), (void *)_cffi_d_X509_REVOKED_get_ext_count },
  { "X509_REVOKED_new", (void *)_cffi_f_X509_REVOKED_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 892), (void *)_cffi_d_X509_REVOKED_new },
  { "X509_REVOKED_set_revocationDate", (void *)_cffi_f_X509_REVOKED_set_revocationDate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2525), (void *)_cffi_d_X509_REVOKED_set_revocationDate },
  { "X509_REVOKED_set_serialNumber", (void *)_cffi_f_X509_REVOKED_set_serialNumber, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2521), (void *)_cffi_d_X509_REVOKED_set_serialNumber },
  { "X509_R_CERT_ALREADY_IN_HASH_TABLE", (void *)_cffi_const_X509_R_CERT_ALREADY_IN_HASH_TABLE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_STORE_CTX_cleanup", (void *)_cffi_f_X509_STORE_CTX_cleanup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3528), (void *)_cffi_d_X509_STORE_CTX_cleanup },
  { "X509_STORE_CTX_free", (void *)_cffi_f_X509_STORE_CTX_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3528), (void *)_cffi_d_X509_STORE_CTX_free },
  { "X509_STORE_CTX_get0_cert", (void *)_cffi_f_X509_STORE_CTX_get0_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 739), (void *)_cffi_d_X509_STORE_CTX_get0_cert },
  { "X509_STORE_CTX_get0_param", (void *)_cffi_f_X509_STORE_CTX_get0_param, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 904), (void *)_cffi_d_X509_STORE_CTX_get0_param },
  { "X509_STORE_CTX_get1_chain", (void *)_cffi_f_X509_STORE_CTX_get1_chain, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 257), (void *)_cffi_d_X509_STORE_CTX_get1_chain },
  { "X509_STORE_CTX_get1_issuer", (void *)_cffi_f_X509_STORE_CTX_get1_issuer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2299), (void *)_cffi_d_X509_STORE_CTX_get1_issuer },
  { "X509_STORE_CTX_get_chain", (void *)_cffi_f_X509_STORE_CTX_get_chain, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 257), (void *)_cffi_d_X509_STORE_CTX_get_chain },
  { "X509_STORE_CTX_get_current_cert", (void *)_cffi_f_X509_STORE_CTX_get_current_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 739), (void *)_cffi_d_X509_STORE_CTX_get_current_cert },
  { "X509_STORE_CTX_get_error", (void *)_cffi_f_X509_STORE_CTX_get_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2565), (void *)_cffi_d_X509_STORE_CTX_get_error },
  { "X509_STORE_CTX_get_error_depth", (void *)_cffi_f_X509_STORE_CTX_get_error_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2565), (void *)_cffi_d_X509_STORE_CTX_get_error_depth },
  { "X509_STORE_CTX_get_ex_data", (void *)_cffi_f_X509_STORE_CTX_get_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3099), (void *)_cffi_d_X509_STORE_CTX_get_ex_data },
  { "X509_STORE_CTX_get_ex_new_index", (void *)_cffi_f_X509_STORE_CTX_get_ex_new_index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2759), (void *)_cffi_d_X509_STORE_CTX_get_ex_new_index },
  { "X509_STORE_CTX_init", (void *)_cffi_f_X509_STORE_CTX_init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2568), (void *)_cffi_d_X509_STORE_CTX_init },
  { "X509_STORE_CTX_new", (void *)_cffi_f_X509_STORE_CTX_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 899), (void *)_cffi_d_X509_STORE_CTX_new },
  { "X509_STORE_CTX_set0_crls", (void *)_cffi_f_X509_STORE_CTX_set0_crls, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3535), (void *)_cffi_d_X509_STORE_CTX_set0_crls },
  { "X509_STORE_CTX_set0_param", (void *)_cffi_f_X509_STORE_CTX_set0_param, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3543), (void *)_cffi_d_X509_STORE_CTX_set0_param },
  { "X509_STORE_CTX_set_cert", (void *)_cffi_f_X509_STORE_CTX_set_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3539), (void *)_cffi_d_X509_STORE_CTX_set_cert },
  { "X509_STORE_CTX_set_chain", (void *)_cffi_f_X509_STORE_CTX_set_chain, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3531), (void *)_cffi_d_X509_STORE_CTX_set_chain },
  { "X509_STORE_CTX_set_default", (void *)_cffi_f_X509_STORE_CTX_set_default, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2574), (void *)_cffi_d_X509_STORE_CTX_set_default },
  { "X509_STORE_CTX_set_error", (void *)_cffi_f_X509_STORE_CTX_set_error, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3551), (void *)_cffi_d_X509_STORE_CTX_set_error },
  { "X509_STORE_CTX_set_ex_data", (void *)_cffi_f_X509_STORE_CTX_set_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2578), (void *)_cffi_d_X509_STORE_CTX_set_ex_data },
  { "X509_STORE_CTX_set_verify_cb", (void *)_cffi_f_X509_STORE_CTX_set_verify_cb, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3547), (void *)_cffi_d_X509_STORE_CTX_set_verify_cb },
  { "X509_STORE_CTX_trusted_stack", (void *)_cffi_f_X509_STORE_CTX_trusted_stack, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3531), (void *)_cffi_d_X509_STORE_CTX_trusted_stack },
  { "X509_STORE_add_cert", (void *)_cffi_f_X509_STORE_add_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2544), (void *)_cffi_d_X509_STORE_add_cert },
  { "X509_STORE_add_crl", (void *)_cffi_f_X509_STORE_add_crl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2548), (void *)_cffi_d_X509_STORE_add_crl },
  { "X509_STORE_free", (void *)_cffi_f_X509_STORE_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3521), (void *)_cffi_d_X509_STORE_free },
  { "X509_STORE_get0_objects", (void *)_cffi_f_X509_STORE_get0_objects, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 277), (void *)_cffi_d_X509_STORE_get0_objects },
  { "X509_STORE_get0_param", (void *)_cffi_f_X509_STORE_get0_param, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 901), (void *)_cffi_d_X509_STORE_get0_param },
  { "X509_STORE_get_get_issuer", (void *)_cffi_f_X509_STORE_get_get_issuer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2838), (void *)_cffi_d_X509_STORE_get_get_issuer },
  { "X509_STORE_load_locations", (void *)_cffi_f_X509_STORE_load_locations, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2556), (void *)_cffi_d_X509_STORE_load_locations },
  { "X509_STORE_new", (void *)_cffi_f_X509_STORE_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 897), (void *)_cffi_d_X509_STORE_new },
  { "X509_STORE_set1_param", (void *)_cffi_f_X509_STORE_set1_param, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2552), (void *)_cffi_d_X509_STORE_set1_param },
  { "X509_STORE_set_default_paths", (void *)_cffi_f_X509_STORE_set_default_paths, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2541), (void *)_cffi_d_X509_STORE_set_default_paths },
  { "X509_STORE_set_flags", (void *)_cffi_f_X509_STORE_set_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2561), (void *)_cffi_d_X509_STORE_set_flags },
  { "X509_STORE_set_get_issuer", (void *)_cffi_f_X509_STORE_set_get_issuer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3524), (void *)_cffi_d_X509_STORE_set_get_issuer },
  { "X509_VERIFY_PARAM_add0_policy", (void *)_cffi_f_X509_VERIFY_PARAM_add0_policy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2587), (void *)_cffi_d_X509_VERIFY_PARAM_add0_policy },
  { "X509_VERIFY_PARAM_clear_flags", (void *)_cffi_f_X509_VERIFY_PARAM_clear_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2613), (void *)_cffi_d_X509_VERIFY_PARAM_clear_flags },
  { "X509_VERIFY_PARAM_free", (void *)_cffi_f_X509_VERIFY_PARAM_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3555), (void *)_cffi_d_X509_VERIFY_PARAM_free },
  { "X509_VERIFY_PARAM_get_depth", (void *)_cffi_f_X509_VERIFY_PARAM_get_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2617), (void *)_cffi_d_X509_VERIFY_PARAM_get_depth },
  { "X509_VERIFY_PARAM_get_flags", (void *)_cffi_f_X509_VERIFY_PARAM_get_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3051), (void *)_cffi_d_X509_VERIFY_PARAM_get_flags },
  { "X509_VERIFY_PARAM_new", (void *)_cffi_f_X509_VERIFY_PARAM_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 907), (void *)_cffi_d_X509_VERIFY_PARAM_new },
  { "X509_VERIFY_PARAM_set1_email", (void *)_cffi_f_X509_VERIFY_PARAM_set1_email, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2599), (void *)_cffi_d_X509_VERIFY_PARAM_set1_email },
  { "X509_VERIFY_PARAM_set1_host", (void *)_cffi_f_X509_VERIFY_PARAM_set1_host, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2599), (void *)_cffi_d_X509_VERIFY_PARAM_set1_host },
  { "X509_VERIFY_PARAM_set1_ip", (void *)_cffi_f_X509_VERIFY_PARAM_set1_ip, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2608), (void *)_cffi_d_X509_VERIFY_PARAM_set1_ip },
  { "X509_VERIFY_PARAM_set1_ip_asc", (void *)_cffi_f_X509_VERIFY_PARAM_set1_ip_asc, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2595), (void *)_cffi_d_X509_VERIFY_PARAM_set1_ip_asc },
  { "X509_VERIFY_PARAM_set1_policies", (void *)_cffi_f_X509_VERIFY_PARAM_set1_policies, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2591), (void *)_cffi_d_X509_VERIFY_PARAM_set1_policies },
  { "X509_VERIFY_PARAM_set_depth", (void *)_cffi_f_X509_VERIFY_PARAM_set_depth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3558), (void *)_cffi_d_X509_VERIFY_PARAM_set_depth },
  { "X509_VERIFY_PARAM_set_flags", (void *)_cffi_f_X509_VERIFY_PARAM_set_flags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2613), (void *)_cffi_d_X509_VERIFY_PARAM_set_flags },
  { "X509_VERIFY_PARAM_set_hostflags", (void *)_cffi_f_X509_VERIFY_PARAM_set_hostflags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3566), (void *)_cffi_d_X509_VERIFY_PARAM_set_hostflags },
  { "X509_VERIFY_PARAM_set_purpose", (void *)_cffi_f_X509_VERIFY_PARAM_set_purpose, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2604), (void *)_cffi_d_X509_VERIFY_PARAM_set_purpose },
  { "X509_VERIFY_PARAM_set_time", (void *)_cffi_f_X509_VERIFY_PARAM_set_time, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3562), (void *)_cffi_d_X509_VERIFY_PARAM_set_time },
  { "X509_VERIFY_PARAM_set_trust", (void *)_cffi_f_X509_VERIFY_PARAM_set_trust, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2604), (void *)_cffi_d_X509_VERIFY_PARAM_set_trust },
  { "X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH", (void *)_cffi_const_X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_AKID_SKID_MISMATCH", (void *)_cffi_const_X509_V_ERR_AKID_SKID_MISMATCH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_APPLICATION_VERIFICATION", (void *)_cffi_const_X509_V_ERR_APPLICATION_VERIFICATION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_CHAIN_TOO_LONG", (void *)_cffi_const_X509_V_ERR_CERT_CHAIN_TOO_LONG, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_HAS_EXPIRED", (void *)_cffi_const_X509_V_ERR_CERT_HAS_EXPIRED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_NOT_YET_VALID", (void *)_cffi_const_X509_V_ERR_CERT_NOT_YET_VALID, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_REJECTED", (void *)_cffi_const_X509_V_ERR_CERT_REJECTED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_REVOKED", (void *)_cffi_const_X509_V_ERR_CERT_REVOKED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_SIGNATURE_FAILURE", (void *)_cffi_const_X509_V_ERR_CERT_SIGNATURE_FAILURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CERT_UNTRUSTED", (void *)_cffi_const_X509_V_ERR_CERT_UNTRUSTED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CRL_HAS_EXPIRED", (void *)_cffi_const_X509_V_ERR_CRL_HAS_EXPIRED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CRL_NOT_YET_VALID", (void *)_cffi_const_X509_V_ERR_CRL_NOT_YET_VALID, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CRL_PATH_VALIDATION_ERROR", (void *)_cffi_const_X509_V_ERR_CRL_PATH_VALIDATION_ERROR, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_CRL_SIGNATURE_FAILURE", (void *)_cffi_const_X509_V_ERR_CRL_SIGNATURE_FAILURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT", (void *)_cffi_const_X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_DIFFERENT_CRL_SCOPE", (void *)_cffi_const_X509_V_ERR_DIFFERENT_CRL_SCOPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_EMAIL_MISMATCH", (void *)_cffi_const_X509_V_ERR_EMAIL_MISMATCH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD", (void *)_cffi_const_X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD", (void *)_cffi_const_X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD", (void *)_cffi_const_X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD", (void *)_cffi_const_X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_EXCLUDED_VIOLATION", (void *)_cffi_const_X509_V_ERR_EXCLUDED_VIOLATION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_HOSTNAME_MISMATCH", (void *)_cffi_const_X509_V_ERR_HOSTNAME_MISMATCH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_INVALID_CA", (void *)_cffi_const_X509_V_ERR_INVALID_CA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_INVALID_EXTENSION", (void *)_cffi_const_X509_V_ERR_INVALID_EXTENSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_INVALID_NON_CA", (void *)_cffi_const_X509_V_ERR_INVALID_NON_CA, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_INVALID_POLICY_EXTENSION", (void *)_cffi_const_X509_V_ERR_INVALID_POLICY_EXTENSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_INVALID_PURPOSE", (void *)_cffi_const_X509_V_ERR_INVALID_PURPOSE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_IP_ADDRESS_MISMATCH", (void *)_cffi_const_X509_V_ERR_IP_ADDRESS_MISMATCH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_KEYUSAGE_NO_CERTSIGN", (void *)_cffi_const_X509_V_ERR_KEYUSAGE_NO_CERTSIGN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_KEYUSAGE_NO_CRL_SIGN", (void *)_cffi_const_X509_V_ERR_KEYUSAGE_NO_CRL_SIGN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE", (void *)_cffi_const_X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_NO_EXPLICIT_POLICY", (void *)_cffi_const_X509_V_ERR_NO_EXPLICIT_POLICY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_OUT_OF_MEM", (void *)_cffi_const_X509_V_ERR_OUT_OF_MEM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_PATH_LENGTH_EXCEEDED", (void *)_cffi_const_X509_V_ERR_PATH_LENGTH_EXCEEDED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_PERMITTED_VIOLATION", (void *)_cffi_const_X509_V_ERR_PERMITTED_VIOLATION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED", (void *)_cffi_const_X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED", (void *)_cffi_const_X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN", (void *)_cffi_const_X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUBJECT_ISSUER_MISMATCH", (void *)_cffi_const_X509_V_ERR_SUBJECT_ISSUER_MISMATCH, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUBTREE_MINMAX", (void *)_cffi_const_X509_V_ERR_SUBTREE_MINMAX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256", (void *)_cffi_const_X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUITE_B_INVALID_ALGORITHM", (void *)_cffi_const_X509_V_ERR_SUITE_B_INVALID_ALGORITHM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUITE_B_INVALID_CURVE", (void *)_cffi_const_X509_V_ERR_SUITE_B_INVALID_CURVE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM", (void *)_cffi_const_X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUITE_B_INVALID_VERSION", (void *)_cffi_const_X509_V_ERR_SUITE_B_INVALID_VERSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED", (void *)_cffi_const_X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_GET_CRL", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_GET_CRL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE", (void *)_cffi_const_X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION", (void *)_cffi_const_X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION", (void *)_cffi_const_X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNNESTED_RESOURCE", (void *)_cffi_const_X509_V_ERR_UNNESTED_RESOURCE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX", (void *)_cffi_const_X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE", (void *)_cffi_const_X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE", (void *)_cffi_const_X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_ERR_UNSUPPORTED_NAME_SYNTAX", (void *)_cffi_const_X509_V_ERR_UNSUPPORTED_NAME_SYNTAX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_ALLOW_PROXY_CERTS", (void *)_cffi_const_X509_V_FLAG_ALLOW_PROXY_CERTS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_CB_ISSUER_CHECK", (void *)_cffi_const_X509_V_FLAG_CB_ISSUER_CHECK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_CHECK_SS_SIGNATURE", (void *)_cffi_const_X509_V_FLAG_CHECK_SS_SIGNATURE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_CRL_CHECK", (void *)_cffi_const_X509_V_FLAG_CRL_CHECK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_CRL_CHECK_ALL", (void *)_cffi_const_X509_V_FLAG_CRL_CHECK_ALL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_EXPLICIT_POLICY", (void *)_cffi_const_X509_V_FLAG_EXPLICIT_POLICY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_EXTENDED_CRL_SUPPORT", (void *)_cffi_const_X509_V_FLAG_EXTENDED_CRL_SUPPORT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_IGNORE_CRITICAL", (void *)_cffi_const_X509_V_FLAG_IGNORE_CRITICAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_INHIBIT_ANY", (void *)_cffi_const_X509_V_FLAG_INHIBIT_ANY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_INHIBIT_MAP", (void *)_cffi_const_X509_V_FLAG_INHIBIT_MAP, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_NOTIFY_POLICY", (void *)_cffi_const_X509_V_FLAG_NOTIFY_POLICY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_PARTIAL_CHAIN", (void *)_cffi_const_X509_V_FLAG_PARTIAL_CHAIN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_POLICY_CHECK", (void *)_cffi_const_X509_V_FLAG_POLICY_CHECK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_SUITEB_128_LOS", (void *)_cffi_const_X509_V_FLAG_SUITEB_128_LOS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_SUITEB_128_LOS_ONLY", (void *)_cffi_const_X509_V_FLAG_SUITEB_128_LOS_ONLY, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_SUITEB_192_LOS", (void *)_cffi_const_X509_V_FLAG_SUITEB_192_LOS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_TRUSTED_FIRST", (void *)_cffi_const_X509_V_FLAG_TRUSTED_FIRST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_USE_CHECK_TIME", (void *)_cffi_const_X509_V_FLAG_USE_CHECK_TIME, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_USE_DELTAS", (void *)_cffi_const_X509_V_FLAG_USE_DELTAS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_FLAG_X509_STRICT", (void *)_cffi_const_X509_V_FLAG_X509_STRICT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_V_OK", (void *)_cffi_const_X509_V_OK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "X509_add_ext", (void *)_cffi_f_X509_add_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2324), (void *)_cffi_d_X509_add_ext },
  { "X509_alias_get0", (void *)_cffi_f_X509_alias_get0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3006), (void *)_cffi_d_X509_alias_get0 },
  { "X509_check_ca", (void *)_cffi_f_X509_check_ca, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2304), (void *)_cffi_d_X509_check_ca },
  { "X509_cmp", (void *)_cffi_f_X509_cmp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2360), (void *)_cffi_d_X509_cmp },
  { "X509_delete_ext", (void *)_cffi_f_X509_delete_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 801), (void *)_cffi_d_X509_delete_ext },
  { "X509_digest", (void *)_cffi_f_X509_digest, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2354), (void *)_cffi_d_X509_digest },
  { "X509_dup", (void *)_cffi_f_X509_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 733), (void *)_cffi_d_X509_dup },
  { "X509_free", (void *)_cffi_f_X509_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3479), (void *)_cffi_d_X509_free },
  { "X509_get0_signature", (void *)_cffi_f_X509_get0_signature, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3143), (void *)_cffi_d_X509_get0_signature },
  { "X509_get0_tbs_sigalg", (void *)_cffi_f_X509_get0_tbs_sigalg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 750), (void *)_cffi_d_X509_get0_tbs_sigalg },
  { "X509_get_default_cert_area", (void *)_cffi_f_X509_get_default_cert_area, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 967), (void *)_cffi_d_X509_get_default_cert_area },
  { "X509_get_default_cert_dir", (void *)_cffi_f_X509_get_default_cert_dir, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 967), (void *)_cffi_d_X509_get_default_cert_dir },
  { "X509_get_default_cert_dir_env", (void *)_cffi_f_X509_get_default_cert_dir_env, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 967), (void *)_cffi_d_X509_get_default_cert_dir_env },
  { "X509_get_default_cert_file", (void *)_cffi_f_X509_get_default_cert_file, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 967), (void *)_cffi_d_X509_get_default_cert_file },
  { "X509_get_default_cert_file_env", (void *)_cffi_f_X509_get_default_cert_file_env, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 967), (void *)_cffi_d_X509_get_default_cert_file_env },
  { "X509_get_default_private_dir", (void *)_cffi_f_X509_get_default_private_dir, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 967), (void *)_cffi_d_X509_get_default_private_dir },
  { "X509_get_ex_data", (void *)_cffi_f_X509_get_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3083), (void *)_cffi_d_X509_get_ex_data },
  { "X509_get_ex_new_index", (void *)_cffi_f_X509_get_ex_new_index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2759), (void *)_cffi_d_X509_get_ex_new_index },
  { "X509_get_ext", (void *)_cffi_f_X509_get_ext, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 801), (void *)_cffi_d_X509_get_ext },
  { "X509_get_ext_by_NID", (void *)_cffi_f_X509_get_ext_by_NID, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2333), (void *)_cffi_d_X509_get_ext_by_NID },
  { "X509_get_ext_count", (void *)_cffi_f_X509_get_ext_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2304), (void *)_cffi_d_X509_get_ext_count },
  { "X509_get_ext_d2i", (void *)_cffi_f_X509_get_ext_d2i, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3087), (void *)_cffi_d_X509_get_ext_d2i },
  { "X509_get_issuer_name", (void *)_cffi_f_X509_get_issuer_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 840), (void *)_cffi_d_X509_get_issuer_name },
  { "X509_get_notAfter", (void *)_cffi_f_X509_get_notAfter, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 76), (void *)_cffi_d_X509_get_notAfter },
  { "X509_get_notBefore", (void *)_cffi_f_X509_get_notBefore, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 76), (void *)_cffi_d_X509_get_notBefore },
  { "X509_get_pubkey", (void *)_cffi_f_X509_get_pubkey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 498), (void *)_cffi_d_X509_get_pubkey },
  { "X509_get_serialNumber", (void *)_cffi_f_X509_get_serialNumber, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 27), (void *)_cffi_d_X509_get_serialNumber },
  { "X509_get_signature_nid", (void *)_cffi_f_X509_get_signature_nid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2351), (void *)_cffi_d_X509_get_signature_nid },
  { "X509_get_subject_name", (void *)_cffi_f_X509_get_subject_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 840), (void *)_cffi_d_X509_get_subject_name },
  { "X509_get_version", (void *)_cffi_f_X509_get_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2954), (void *)_cffi_d_X509_get_version },
  { "X509_gmtime_adj", (void *)_cffi_f_X509_gmtime_adj, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 68), (void *)_cffi_d_X509_gmtime_adj },
  { "X509_new", (void *)_cffi_f_X509_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 742), (void *)_cffi_d_X509_new },
  { "X509_print_ex", (void *)_cffi_f_X509_print_ex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1282), (void *)_cffi_d_X509_print_ex },
  { "X509_set_ex_data", (void *)_cffi_f_X509_set_ex_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2338), (void *)_cffi_d_X509_set_ex_data },
  { "X509_set_issuer_name", (void *)_cffi_f_X509_set_issuer_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2329), (void *)_cffi_d_X509_set_issuer_name },
  { "X509_set_notAfter", (void *)_cffi_f_X509_set_notAfter, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2311), (void *)_cffi_d_X509_set_notAfter },
  { "X509_set_notBefore", (void *)_cffi_f_X509_set_notBefore, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2311), (void *)_cffi_d_X509_set_notBefore },
  { "X509_set_pubkey", (void *)_cffi_f_X509_set_pubkey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2315), (void *)_cffi_d_X509_set_pubkey },
  { "X509_set_serialNumber", (void *)_cffi_f_X509_set_serialNumber, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2307), (void *)_cffi_d_X509_set_serialNumber },
  { "X509_set_subject_name", (void *)_cffi_f_X509_set_subject_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2329), (void *)_cffi_d_X509_set_subject_name },
  { "X509_set_version", (void *)_cffi_f_X509_set_version, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2343), (void *)_cffi_d_X509_set_version },
  { "X509_sign", (void *)_cffi_f_X509_sign, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2319), (void *)_cffi_d_X509_sign },
  { "X509_subject_name_hash", (void *)_cffi_f_X509_subject_name_hash, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3045), (void *)_cffi_d_X509_subject_name_hash },
  { "X509_verify_cert", (void *)_cffi_f_X509_verify_cert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2565), (void *)_cffi_d_X509_verify_cert },
  { "X509_verify_cert_error_string", (void *)_cffi_f_X509_verify_cert_error_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 961), (void *)_cffi_d_X509_verify_cert_error_string },
  { "XN_FLAG_COMPAT", (void *)_cffi_const_XN_FLAG_COMPAT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_DN_REV", (void *)_cffi_const_XN_FLAG_DN_REV, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_DUMP_UNKNOWN_FIELDS", (void *)_cffi_const_XN_FLAG_DUMP_UNKNOWN_FIELDS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_FN_ALIGN", (void *)_cffi_const_XN_FLAG_FN_ALIGN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_FN_LN", (void *)_cffi_const_XN_FLAG_FN_LN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_FN_MASK", (void *)_cffi_const_XN_FLAG_FN_MASK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_FN_NONE", (void *)_cffi_const_XN_FLAG_FN_NONE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_FN_OID", (void *)_cffi_const_XN_FLAG_FN_OID, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_FN_SN", (void *)_cffi_const_XN_FLAG_FN_SN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_MULTILINE", (void *)_cffi_const_XN_FLAG_MULTILINE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_ONELINE", (void *)_cffi_const_XN_FLAG_ONELINE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_RFC2253", (void *)_cffi_const_XN_FLAG_RFC2253, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_SEP_COMMA_PLUS", (void *)_cffi_const_XN_FLAG_SEP_COMMA_PLUS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_SEP_CPLUS_SPC", (void *)_cffi_const_XN_FLAG_SEP_CPLUS_SPC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_SEP_MASK", (void *)_cffi_const_XN_FLAG_SEP_MASK, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_SEP_MULTILINE", (void *)_cffi_const_XN_FLAG_SEP_MULTILINE, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_SEP_SPLUS_SPC", (void *)_cffi_const_XN_FLAG_SEP_SPLUS_SPC, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "XN_FLAG_SPC_EQ", (void *)_cffi_const_XN_FLAG_SPC_EQ, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
  { "_setup_ssl_threads", (void *)_cffi_f__setup_ssl_threads, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 2830), (void *)_cffi_d__setup_ssl_threads },
  { "d2i_ASN1_OBJECT", (void *)_cffi_f_d2i_ASN1_OBJECT, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 38), (void *)_cffi_d_d2i_ASN1_OBJECT },
  { "d2i_ASN1_TYPE", (void *)_cffi_f_d2i_ASN1_TYPE, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 99), (void *)_cffi_d_d2i_ASN1_TYPE },
  { "d2i_DHparams", (void *)_cffi_f_d2i_DHparams, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 293), (void *)_cffi_d_d2i_DHparams },
  { "d2i_DHparams_bio", (void *)_cffi_f_d2i_DHparams_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 283), (void *)_cffi_d_d2i_DHparams_bio },
  { "d2i_DSAPrivateKey", (void *)_cffi_f_d2i_DSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 327), (void *)_cffi_d_d2i_DSAPrivateKey },
  { "d2i_DSAPrivateKey_bio", (void *)_cffi_f_d2i_DSAPrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 317), (void *)_cffi_d_d2i_DSAPrivateKey_bio },
  { "d2i_DSAPublicKey", (void *)_cffi_f_d2i_DSAPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 327), (void *)_cffi_d_d2i_DSAPublicKey },
  { "d2i_DSA_PUBKEY", (void *)_cffi_f_d2i_DSA_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 327), (void *)_cffi_d_d2i_DSA_PUBKEY },
  { "d2i_DSA_PUBKEY_bio", (void *)_cffi_f_d2i_DSA_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 317), (void *)_cffi_d_d2i_DSA_PUBKEY_bio },
  { "d2i_ECDSA_SIG", (void *)_cffi_f_d2i_ECDSA_SIG, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 343), (void *)_cffi_d_d2i_ECDSA_SIG },
  { "d2i_ECPrivateKey", (void *)_cffi_f_d2i_ECPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 381), (void *)_cffi_d_d2i_ECPrivateKey },
  { "d2i_ECPrivateKey_bio", (void *)_cffi_f_d2i_ECPrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 377), (void *)_cffi_d_d2i_ECPrivateKey_bio },
  { "d2i_EC_PUBKEY", (void *)_cffi_f_d2i_EC_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 381), (void *)_cffi_d_d2i_EC_PUBKEY },
  { "d2i_EC_PUBKEY_bio", (void *)_cffi_f_d2i_EC_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 377), (void *)_cffi_d_d2i_EC_PUBKEY_bio },
  { "d2i_GENERAL_NAMES", (void *)_cffi_f_d2i_GENERAL_NAMES, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 523), (void *)_cffi_d_d2i_GENERAL_NAMES },
  { "d2i_OCSP_REQUEST_bio", (void *)_cffi_f_d2i_OCSP_REQUEST_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 560), (void *)_cffi_d_d2i_OCSP_REQUEST_bio },
  { "d2i_OCSP_RESPONSE_bio", (void *)_cffi_f_d2i_OCSP_RESPONSE_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 566), (void *)_cffi_d_d2i_OCSP_RESPONSE_bio },
  { "d2i_PKCS12_bio", (void *)_cffi_f_d2i_PKCS12_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 589), (void *)_cffi_d_d2i_PKCS12_bio },
  { "d2i_PKCS7_bio", (void *)_cffi_f_d2i_PKCS7_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 609), (void *)_cffi_d_d2i_PKCS7_bio },
  { "d2i_PKCS8PrivateKey_bio", (void *)_cffi_f_d2i_PKCS8PrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 480), (void *)_cffi_d_d2i_PKCS8PrivateKey_bio },
  { "d2i_PKCS8_PRIV_KEY_INFO_bio", (void *)_cffi_f_d2i_PKCS8_PRIV_KEY_INFO_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_d2i_PKCS8_PRIV_KEY_INFO_bio },
  { "d2i_PUBKEY_bio", (void *)_cffi_f_d2i_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 476), (void *)_cffi_d_d2i_PUBKEY_bio },
  { "d2i_PrivateKey_bio", (void *)_cffi_f_d2i_PrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 476), (void *)_cffi_d_d2i_PrivateKey_bio },
  { "d2i_RSAPrivateKey", (void *)_cffi_f_d2i_RSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 666), (void *)_cffi_d_d2i_RSAPrivateKey },
  { "d2i_RSAPrivateKey_bio", (void *)_cffi_f_d2i_RSAPrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 653), (void *)_cffi_d_d2i_RSAPrivateKey_bio },
  { "d2i_RSAPublicKey", (void *)_cffi_f_d2i_RSAPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 666), (void *)_cffi_d_d2i_RSAPublicKey },
  { "d2i_RSAPublicKey_bio", (void *)_cffi_f_d2i_RSAPublicKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 653), (void *)_cffi_d_d2i_RSAPublicKey_bio },
  { "d2i_RSA_PUBKEY", (void *)_cffi_f_d2i_RSA_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 666), (void *)_cffi_d_d2i_RSA_PUBKEY },
  { "d2i_RSA_PUBKEY_bio", (void *)_cffi_f_d2i_RSA_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 653), (void *)_cffi_d_d2i_RSA_PUBKEY_bio },
  { "d2i_X509_CRL_bio", (void *)_cffi_f_d2i_X509_CRL_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 761), (void *)_cffi_d_d2i_X509_CRL_bio },
  { "d2i_X509_REQ_bio", (void *)_cffi_f_d2i_X509_REQ_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 873), (void *)_cffi_d_d2i_X509_REQ_bio },
  { "d2i_X509_bio", (void *)_cffi_f_d2i_X509_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 716), (void *)_cffi_d_d2i_X509_bio },
  { "i2a_ASN1_INTEGER", (void *)_cffi_f_i2a_ASN1_INTEGER, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1143), (void *)_cffi_d_i2a_ASN1_INTEGER },
  { "i2d_ASN1_BIT_STRING", (void *)_cffi_f_i2d_ASN1_BIT_STRING, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1041), (void *)_cffi_d_i2d_ASN1_BIT_STRING },
  { "i2d_ASN1_ENUMERATED", (void *)_cffi_f_i2d_ASN1_ENUMERATED, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 983), (void *)_cffi_d_i2d_ASN1_ENUMERATED },
  { "i2d_ASN1_GENERALIZEDTIME", (void *)_cffi_f_i2d_ASN1_GENERALIZEDTIME, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 994), (void *)_cffi_d_i2d_ASN1_GENERALIZEDTIME },
  { "i2d_ASN1_INTEGER", (void *)_cffi_f_i2d_ASN1_INTEGER, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1006), (void *)_cffi_d_i2d_ASN1_INTEGER },
  { "i2d_ASN1_OBJECT", (void *)_cffi_f_i2d_ASN1_OBJECT, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1010), (void *)_cffi_d_i2d_ASN1_OBJECT },
  { "i2d_ASN1_OCTET_STRING", (void *)_cffi_f_i2d_ASN1_OCTET_STRING, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1041), (void *)_cffi_d_i2d_ASN1_OCTET_STRING },
  { "i2d_ASN1_TYPE", (void *)_cffi_f_i2d_ASN1_TYPE, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1055), (void *)_cffi_d_i2d_ASN1_TYPE },
  { "i2d_CMS_bio_stream", (void *)_cffi_f_i2d_CMS_bio_stream, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1155), (void *)_cffi_d_i2d_CMS_bio_stream },
  { "i2d_DHparams", (void *)_cffi_f_i2d_DHparams, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1515), (void *)_cffi_d_i2d_DHparams },
  { "i2d_DHparams_bio", (void *)_cffi_f_i2d_DHparams_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1161), (void *)_cffi_d_i2d_DHparams_bio },
  { "i2d_DSAPrivateKey", (void *)_cffi_f_i2d_DSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1542), (void *)_cffi_d_i2d_DSAPrivateKey },
  { "i2d_DSAPrivateKey_bio", (void *)_cffi_f_i2d_DSAPrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1169), (void *)_cffi_d_i2d_DSAPrivateKey_bio },
  { "i2d_DSAPublicKey", (void *)_cffi_f_i2d_DSAPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1542), (void *)_cffi_d_i2d_DSAPublicKey },
  { "i2d_DSA_PUBKEY", (void *)_cffi_f_i2d_DSA_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1542), (void *)_cffi_d_i2d_DSA_PUBKEY },
  { "i2d_DSA_PUBKEY_bio", (void *)_cffi_f_i2d_DSA_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1169), (void *)_cffi_d_i2d_DSA_PUBKEY_bio },
  { "i2d_ECDSA_SIG", (void *)_cffi_f_i2d_ECDSA_SIG, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1549), (void *)_cffi_d_i2d_ECDSA_SIG },
  { "i2d_ECPrivateKey", (void *)_cffi_f_i2d_ECPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1713), (void *)_cffi_d_i2d_ECPrivateKey },
  { "i2d_ECPrivateKey_bio", (void *)_cffi_f_i2d_ECPrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1182), (void *)_cffi_d_i2d_ECPrivateKey_bio },
  { "i2d_EC_PUBKEY", (void *)_cffi_f_i2d_EC_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1713), (void *)_cffi_d_i2d_EC_PUBKEY },
  { "i2d_EC_PUBKEY_bio", (void *)_cffi_f_i2d_EC_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1182), (void *)_cffi_d_i2d_EC_PUBKEY_bio },
  { "i2d_GENERAL_NAMES", (void *)_cffi_f_i2d_GENERAL_NAMES, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1989), (void *)_cffi_d_i2d_GENERAL_NAMES },
  { "i2d_OCSP_REQUEST_bio", (void *)_cffi_f_i2d_OCSP_REQUEST_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1230), (void *)_cffi_d_i2d_OCSP_REQUEST_bio },
  { "i2d_OCSP_RESPONSE_bio", (void *)_cffi_f_i2d_OCSP_RESPONSE_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1234), (void *)_cffi_d_i2d_OCSP_RESPONSE_bio },
  { "i2d_PKCS12_bio", (void *)_cffi_f_i2d_PKCS12_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1238), (void *)_cffi_d_i2d_PKCS12_bio },
  { "i2d_PKCS7_bio", (void *)_cffi_f_i2d_PKCS7_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1242), (void *)_cffi_d_i2d_PKCS7_bio },
  { "i2d_PKCS8PrivateKey_bio", (void *)_cffi_f_i2d_PKCS8PrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1199), (void *)_cffi_d_i2d_PKCS8PrivateKey_bio },
  { "i2d_PKCS8PrivateKey_nid_bio", (void *)_cffi_f_i2d_PKCS8PrivateKey_nid_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1217), (void *)_cffi_d_i2d_PKCS8PrivateKey_nid_bio },
  { "i2d_PUBKEY_bio", (void *)_cffi_f_i2d_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1195), (void *)_cffi_d_i2d_PUBKEY_bio },
  { "i2d_PrivateKey_bio", (void *)_cffi_f_i2d_PrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1195), (void *)_cffi_d_i2d_PrivateKey_bio },
  { "i2d_RSAPrivateKey", (void *)_cffi_f_i2d_RSAPrivateKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2127), (void *)_cffi_d_i2d_RSAPrivateKey },
  { "i2d_RSAPrivateKey_bio", (void *)_cffi_f_i2d_RSAPrivateKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1252), (void *)_cffi_d_i2d_RSAPrivateKey_bio },
  { "i2d_RSAPublicKey", (void *)_cffi_f_i2d_RSAPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2127), (void *)_cffi_d_i2d_RSAPublicKey },
  { "i2d_RSAPublicKey_bio", (void *)_cffi_f_i2d_RSAPublicKey_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1252), (void *)_cffi_d_i2d_RSAPublicKey_bio },
  { "i2d_RSA_PUBKEY", (void *)_cffi_f_i2d_RSA_PUBKEY, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2127), (void *)_cffi_d_i2d_RSA_PUBKEY },
  { "i2d_RSA_PUBKEY_bio", (void *)_cffi_f_i2d_RSA_PUBKEY_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1252), (void *)_cffi_d_i2d_RSA_PUBKEY_bio },
  { "i2d_X509", (void *)_cffi_f_i2d_X509, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2347), (void *)_cffi_d_i2d_X509 },
  { "i2d_X509_CINF", (void *)_cffi_f_i2d_X509_CINF, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2364), (void *)_cffi_d_i2d_X509_CINF },
  { "i2d_X509_CRL_INFO", (void *)_cffi_f_i2d_X509_CRL_INFO, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2409), (void *)_cffi_d_i2d_X509_CRL_INFO },
  { "i2d_X509_CRL_bio", (void *)_cffi_f_i2d_X509_CRL_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1288), (void *)_cffi_d_i2d_X509_CRL_bio },
  { "i2d_X509_NAME", (void *)_cffi_f_i2d_X509_NAME, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2469), (void *)_cffi_d_i2d_X509_NAME },
  { "i2d_X509_REQ_INFO", (void *)_cffi_f_i2d_X509_REQ_INFO, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2514), (void *)_cffi_d_i2d_X509_REQ_INFO },
  { "i2d_X509_REQ_bio", (void *)_cffi_f_i2d_X509_REQ_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1298), (void *)_cffi_d_i2d_X509_REQ_bio },
  { "i2d_X509_bio", (void *)_cffi_f_i2d_X509_bio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1278), (void *)_cffi_d_i2d_X509_bio },
  { "i2d_re_X509_CRL_tbs", (void *)_cffi_f_i2d_re_X509_CRL_tbs, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2401), (void *)_cffi_d_i2d_re_X509_CRL_tbs },
  { "i2d_re_X509_REQ_tbs", (void *)_cffi_f_i2d_re_X509_REQ_tbs, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2504), (void *)_cffi_d_i2d_re_X509_REQ_tbs },
  { "i2d_re_X509_tbs", (void *)_cffi_f_i2d_re_X509_tbs, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2347), (void *)_cffi_d_i2d_re_X509_tbs },
  { "i2o_ECPublicKey", (void *)_cffi_f_i2o_ECPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1713), (void *)_cffi_d_i2o_ECPublicKey },
  { "o2i_ECPublicKey", (void *)_cffi_f_o2i_ECPublicKey, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 381), (void *)_cffi_d_o2i_ECPublicKey },
  { "sk_ACCESS_DESCRIPTION_free", (void *)_cffi_f_sk_ACCESS_DESCRIPTION_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3180), (void *)_cffi_d_sk_ACCESS_DESCRIPTION_free },
  { "sk_ACCESS_DESCRIPTION_new_null", (void *)_cffi_f_sk_ACCESS_DESCRIPTION_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 232), (void *)_cffi_d_sk_ACCESS_DESCRIPTION_new_null },
  { "sk_ACCESS_DESCRIPTION_num", (void *)_cffi_f_sk_ACCESS_DESCRIPTION_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1389), (void *)_cffi_d_sk_ACCESS_DESCRIPTION_num },
  { "sk_ACCESS_DESCRIPTION_push", (void *)_cffi_f_sk_ACCESS_DESCRIPTION_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1392), (void *)_cffi_d_sk_ACCESS_DESCRIPTION_push },
  { "sk_ACCESS_DESCRIPTION_value", (void *)_cffi_f_sk_ACCESS_DESCRIPTION_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_sk_ACCESS_DESCRIPTION_value },
  { "sk_ASN1_INTEGER_free", (void *)_cffi_f_sk_ASN1_INTEGER_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3183), (void *)_cffi_d_sk_ASN1_INTEGER_free },
  { "sk_ASN1_INTEGER_new_null", (void *)_cffi_f_sk_ASN1_INTEGER_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 234), (void *)_cffi_d_sk_ASN1_INTEGER_new_null },
  { "sk_ASN1_INTEGER_num", (void *)_cffi_f_sk_ASN1_INTEGER_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1396), (void *)_cffi_d_sk_ASN1_INTEGER_num },
  { "sk_ASN1_INTEGER_push", (void *)_cffi_f_sk_ASN1_INTEGER_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1399), (void *)_cffi_d_sk_ASN1_INTEGER_push },
  { "sk_ASN1_INTEGER_value", (void *)_cffi_f_sk_ASN1_INTEGER_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 23), (void *)_cffi_d_sk_ASN1_INTEGER_value },
  { "sk_ASN1_OBJECT_free", (void *)_cffi_f_sk_ASN1_OBJECT_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3186), (void *)_cffi_d_sk_ASN1_OBJECT_free },
  { "sk_ASN1_OBJECT_new_null", (void *)_cffi_f_sk_ASN1_OBJECT_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 236), (void *)_cffi_d_sk_ASN1_OBJECT_new_null },
  { "sk_ASN1_OBJECT_num", (void *)_cffi_f_sk_ASN1_OBJECT_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1403), (void *)_cffi_d_sk_ASN1_OBJECT_num },
  { "sk_ASN1_OBJECT_push", (void *)_cffi_f_sk_ASN1_OBJECT_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1406), (void *)_cffi_d_sk_ASN1_OBJECT_push },
  { "sk_ASN1_OBJECT_value", (void *)_cffi_f_sk_ASN1_OBJECT_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 46), (void *)_cffi_d_sk_ASN1_OBJECT_value },
  { "sk_DIST_POINT_free", (void *)_cffi_f_sk_DIST_POINT_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3189), (void *)_cffi_d_sk_DIST_POINT_free },
  { "sk_DIST_POINT_new_null", (void *)_cffi_f_sk_DIST_POINT_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 238), (void *)_cffi_d_sk_DIST_POINT_new_null },
  { "sk_DIST_POINT_num", (void *)_cffi_f_sk_DIST_POINT_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1410), (void *)_cffi_d_sk_DIST_POINT_num },
  { "sk_DIST_POINT_pop_free", (void *)_cffi_f_sk_DIST_POINT_pop_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3192), (void *)_cffi_d_sk_DIST_POINT_pop_free },
  { "sk_DIST_POINT_push", (void *)_cffi_f_sk_DIST_POINT_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1413), (void *)_cffi_d_sk_DIST_POINT_push },
  { "sk_DIST_POINT_value", (void *)_cffi_f_sk_DIST_POINT_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 309), (void *)_cffi_d_sk_DIST_POINT_value },
  { "sk_GENERAL_NAME_num", (void *)_cffi_f_sk_GENERAL_NAME_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1982), (void *)_cffi_d_sk_GENERAL_NAME_num },
  { "sk_GENERAL_NAME_pop_free", (void *)_cffi_f_sk_GENERAL_NAME_pop_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3311), (void *)_cffi_d_sk_GENERAL_NAME_pop_free },
  { "sk_GENERAL_NAME_push", (void *)_cffi_f_sk_GENERAL_NAME_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1985), (void *)_cffi_d_sk_GENERAL_NAME_push },
  { "sk_GENERAL_NAME_value", (void *)_cffi_f_sk_GENERAL_NAME_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 517), (void *)_cffi_d_sk_GENERAL_NAME_value },
  { "sk_GENERAL_SUBTREE_free", (void *)_cffi_f_sk_GENERAL_SUBTREE_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3196), (void *)_cffi_d_sk_GENERAL_SUBTREE_free },
  { "sk_GENERAL_SUBTREE_new_null", (void *)_cffi_f_sk_GENERAL_SUBTREE_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 240), (void *)_cffi_d_sk_GENERAL_SUBTREE_new_null },
  { "sk_GENERAL_SUBTREE_num", (void *)_cffi_f_sk_GENERAL_SUBTREE_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1417), (void *)_cffi_d_sk_GENERAL_SUBTREE_num },
  { "sk_GENERAL_SUBTREE_push", (void *)_cffi_f_sk_GENERAL_SUBTREE_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1420), (void *)_cffi_d_sk_GENERAL_SUBTREE_push },
  { "sk_GENERAL_SUBTREE_value", (void *)_cffi_f_sk_GENERAL_SUBTREE_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 530), (void *)_cffi_d_sk_GENERAL_SUBTREE_value },
  { "sk_POLICYINFO_free", (void *)_cffi_f_sk_POLICYINFO_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3199), (void *)_cffi_d_sk_POLICYINFO_free },
  { "sk_POLICYINFO_new_null", (void *)_cffi_f_sk_POLICYINFO_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 242), (void *)_cffi_d_sk_POLICYINFO_new_null },
  { "sk_POLICYINFO_num", (void *)_cffi_f_sk_POLICYINFO_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1424), (void *)_cffi_d_sk_POLICYINFO_num },
  { "sk_POLICYINFO_pop_free", (void *)_cffi_f_sk_POLICYINFO_pop_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 3202), (void *)_cffi_d_sk_POLICYINFO_pop_free },
  { "sk_POLICYINFO_push", (void *)_cffi_f_sk_POLICYINFO_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1427), (void *)_cffi_d_sk_POLICYINFO_push },
  { "sk_POLICYINFO_value", (void *)_cffi_f_sk_POLICYINFO_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 636), (void *)_cffi_d_sk_POLICYINFO_value },
  { "sk_POLICYQUALINFO_free", (void *)_cffi_f_sk_POLICYQUALINFO_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3206), (void *)_cffi_d_sk_POLICYQUALINFO_free },
  { "sk_POLICYQUALINFO_new_null", (void *)_cffi_f_sk_POLICYQUALINFO_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 244), (void *)_cffi_d_sk_POLICYQUALINFO_new_null },
  { "sk_POLICYQUALINFO_num", (void *)_cffi_f_sk_POLICYQUALINFO_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1431), (void *)_cffi_d_sk_POLICYQUALINFO_num },
  { "sk_POLICYQUALINFO_push", (void *)_cffi_f_sk_POLICYQUALINFO_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1434), (void *)_cffi_d_sk_POLICYQUALINFO_push },
  { "sk_POLICYQUALINFO_value", (void *)_cffi_f_sk_POLICYQUALINFO_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 642), (void *)_cffi_d_sk_POLICYQUALINFO_value },
  { "sk_SCT_num", (void *)_cffi_f_sk_SCT_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1438), (void *)_cffi_d_sk_SCT_num },
  { "sk_SCT_value", (void *)_cffi_f_sk_SCT_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 679), (void *)_cffi_d_sk_SCT_value },
  { "sk_SSL_CIPHER_num", (void *)_cffi_f_sk_SSL_CIPHER_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1441), (void *)_cffi_d_sk_SSL_CIPHER_num },
  { "sk_SSL_CIPHER_value", (void *)_cffi_f_sk_SSL_CIPHER_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 686), (void *)_cffi_d_sk_SSL_CIPHER_value },
  { "sk_X509_CRL_free", (void *)_cffi_f_sk_X509_CRL_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3215), (void *)_cffi_d_sk_X509_CRL_free },
  { "sk_X509_CRL_new_null", (void *)_cffi_f_sk_X509_CRL_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 262), (void *)_cffi_d_sk_X509_CRL_new_null },
  { "sk_X509_CRL_num", (void *)_cffi_f_sk_X509_CRL_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1451), (void *)_cffi_d_sk_X509_CRL_num },
  { "sk_X509_CRL_push", (void *)_cffi_f_sk_X509_CRL_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1454), (void *)_cffi_d_sk_X509_CRL_push },
  { "sk_X509_CRL_value", (void *)_cffi_f_sk_X509_CRL_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 771), (void *)_cffi_d_sk_X509_CRL_value },
  { "sk_X509_EXTENSION_delete", (void *)_cffi_f_sk_X509_EXTENSION_delete, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 818), (void *)_cffi_d_sk_X509_EXTENSION_delete },
  { "sk_X509_EXTENSION_free", (void *)_cffi_f_sk_X509_EXTENSION_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3501), (void *)_cffi_d_sk_X509_EXTENSION_free },
  { "sk_X509_EXTENSION_insert", (void *)_cffi_f_sk_X509_EXTENSION_insert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2423), (void *)_cffi_d_sk_X509_EXTENSION_insert },
  { "sk_X509_EXTENSION_new_null", (void *)_cffi_f_sk_X509_EXTENSION_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 834), (void *)_cffi_d_sk_X509_EXTENSION_new_null },
  { "sk_X509_EXTENSION_num", (void *)_cffi_f_sk_X509_EXTENSION_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 2416), (void *)_cffi_d_sk_X509_EXTENSION_num },
  { "sk_X509_EXTENSION_push", (void *)_cffi_f_sk_X509_EXTENSION_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 2419), (void *)_cffi_d_sk_X509_EXTENSION_push },
  { "sk_X509_EXTENSION_value", (void *)_cffi_f_sk_X509_EXTENSION_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 818), (void *)_cffi_d_sk_X509_EXTENSION_value },
  { "sk_X509_NAME_ENTRY_dup", (void *)_cffi_f_sk_X509_NAME_ENTRY_dup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 272), (void *)_cffi_d_sk_X509_NAME_ENTRY_dup },
  { "sk_X509_NAME_ENTRY_new_null", (void *)_cffi_f_sk_X509_NAME_ENTRY_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 275), (void *)_cffi_d_sk_X509_NAME_ENTRY_new_null },
  { "sk_X509_NAME_ENTRY_num", (void *)_cffi_f_sk_X509_NAME_ENTRY_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1465), (void *)_cffi_d_sk_X509_NAME_ENTRY_num },
  { "sk_X509_NAME_ENTRY_push", (void *)_cffi_f_sk_X509_NAME_ENTRY_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1468), (void *)_cffi_d_sk_X509_NAME_ENTRY_push },
  { "sk_X509_NAME_ENTRY_value", (void *)_cffi_f_sk_X509_NAME_ENTRY_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 854), (void *)_cffi_d_sk_X509_NAME_ENTRY_value },
  { "sk_X509_NAME_free", (void *)_cffi_f_sk_X509_NAME_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3218), (void *)_cffi_d_sk_X509_NAME_free },
  { "sk_X509_NAME_new_null", (void *)_cffi_f_sk_X509_NAME_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 270), (void *)_cffi_d_sk_X509_NAME_new_null },
  { "sk_X509_NAME_num", (void *)_cffi_f_sk_X509_NAME_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1458), (void *)_cffi_d_sk_X509_NAME_num },
  { "sk_X509_NAME_push", (void *)_cffi_f_sk_X509_NAME_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1461), (void *)_cffi_d_sk_X509_NAME_push },
  { "sk_X509_NAME_value", (void *)_cffi_f_sk_X509_NAME_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 836), (void *)_cffi_d_sk_X509_NAME_value },
  { "sk_X509_OBJECT_num", (void *)_cffi_f_sk_X509_OBJECT_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1472), (void *)_cffi_d_sk_X509_OBJECT_num },
  { "sk_X509_OBJECT_value", (void *)_cffi_f_sk_X509_OBJECT_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 869), (void *)_cffi_d_sk_X509_OBJECT_value },
  { "sk_X509_REVOKED_num", (void *)_cffi_f_sk_X509_REVOKED_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1475), (void *)_cffi_d_sk_X509_REVOKED_num },
  { "sk_X509_REVOKED_value", (void *)_cffi_f_sk_X509_REVOKED_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 885), (void *)_cffi_d_sk_X509_REVOKED_value },
  { "sk_X509_free", (void *)_cffi_f_sk_X509_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 3212), (void *)_cffi_d_sk_X509_free },
  { "sk_X509_new_null", (void *)_cffi_f_sk_X509_new_null, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 260), (void *)_cffi_d_sk_X509_new_null },
  { "sk_X509_num", (void *)_cffi_f_sk_X509_num, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 1444), (void *)_cffi_d_sk_X509_num },
  { "sk_X509_push", (void *)_cffi_f_sk_X509_push, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 1447), (void *)_cffi_d_sk_X509_push },
  { "sk_X509_value", (void *)_cffi_f_sk_X509_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 726), (void *)_cffi_d_sk_X509_value },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "method", offsetof(ACCESS_DESCRIPTION, method),
              sizeof(((ACCESS_DESCRIPTION *)0)->method),
              _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "location", offsetof(ACCESS_DESCRIPTION, location),
                sizeof(((ACCESS_DESCRIPTION *)0)->location),
                _CFFI_OP(_CFFI_OP_NOOP, 1228) },
  { "keyid", offsetof(AUTHORITY_KEYID, keyid),
             sizeof(((AUTHORITY_KEYID *)0)->keyid),
             _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "issuer", offsetof(AUTHORITY_KEYID, issuer),
              sizeof(((AUTHORITY_KEYID *)0)->issuer),
              _CFFI_OP(_CFFI_OP_NOOP, 518) },
  { "serial", offsetof(AUTHORITY_KEYID, serial),
              sizeof(((AUTHORITY_KEYID *)0)->serial),
              _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "ca", offsetof(BASIC_CONSTRAINTS, ca),
          sizeof(((BASIC_CONSTRAINTS *)0)->ca),
          _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "pathlen", offsetof(BASIC_CONSTRAINTS, pathlen),
               sizeof(((BASIC_CONSTRAINTS *)0)->pathlen),
               _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "password", offsetof(CRYPTOGRAPHY_PASSWORD_DATA, password),
                sizeof(((CRYPTOGRAPHY_PASSWORD_DATA *)0)->password),
                _CFFI_OP(_CFFI_OP_NOOP, 594) },
  { "length", offsetof(CRYPTOGRAPHY_PASSWORD_DATA, length),
              sizeof(((CRYPTOGRAPHY_PASSWORD_DATA *)0)->length),
              _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "called", offsetof(CRYPTOGRAPHY_PASSWORD_DATA, called),
              sizeof(((CRYPTOGRAPHY_PASSWORD_DATA *)0)->called),
              _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "error", offsetof(CRYPTOGRAPHY_PASSWORD_DATA, error),
             sizeof(((CRYPTOGRAPHY_PASSWORD_DATA *)0)->error),
             _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "maxsize", offsetof(CRYPTOGRAPHY_PASSWORD_DATA, maxsize),
               sizeof(((CRYPTOGRAPHY_PASSWORD_DATA *)0)->maxsize),
               _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "distpoint", offsetof(DIST_POINT, distpoint),
                 sizeof(((DIST_POINT *)0)->distpoint),
                 _CFFI_OP(_CFFI_OP_NOOP, 3239) },
  { "reasons", offsetof(DIST_POINT, reasons),
               sizeof(((DIST_POINT *)0)->reasons),
               _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "CRLissuer", offsetof(DIST_POINT, CRLissuer),
                 sizeof(((DIST_POINT *)0)->CRLissuer),
                 _CFFI_OP(_CFFI_OP_NOOP, 518) },
  { "type", offsetof(DIST_POINT_NAME, type),
            sizeof(((DIST_POINT_NAME *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "name", offsetof(DIST_POINT_NAME, name),
            sizeof(((DIST_POINT_NAME *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 3789) },
  { "nid", offsetof(EC_builtin_curve, nid),
           sizeof(((EC_builtin_curve *)0)->nid),
           _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "comment", offsetof(EC_builtin_curve, comment),
               sizeof(((EC_builtin_curve *)0)->comment),
               _CFFI_OP(_CFFI_OP_NOOP, 57) },
  { "type", offsetof(GENERAL_NAME, type),
            sizeof(((GENERAL_NAME *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "d", offsetof(GENERAL_NAME, d),
         sizeof(((GENERAL_NAME *)0)->d),
         _CFFI_OP(_CFFI_OP_NOOP, 3788) },
  { "base", offsetof(GENERAL_SUBTREE, base),
            sizeof(((GENERAL_SUBTREE *)0)->base),
            _CFFI_OP(_CFFI_OP_NOOP, 1228) },
  { "minimum", offsetof(GENERAL_SUBTREE, minimum),
               sizeof(((GENERAL_SUBTREE *)0)->minimum),
               _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "maximum", offsetof(GENERAL_SUBTREE, maximum),
               sizeof(((GENERAL_SUBTREE *)0)->maximum),
               _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "permittedSubtrees", offsetof(NAME_CONSTRAINTS, permittedSubtrees),
                         sizeof(((NAME_CONSTRAINTS *)0)->permittedSubtrees),
                         _CFFI_OP(_CFFI_OP_NOOP, 531) },
  { "excludedSubtrees", offsetof(NAME_CONSTRAINTS, excludedSubtrees),
                        sizeof(((NAME_CONSTRAINTS *)0)->excludedSubtrees),
                        _CFFI_OP(_CFFI_OP_NOOP, 531) },
  { "organization", offsetof(NOTICEREF, organization),
                    sizeof(((NOTICEREF *)0)->organization),
                    _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "noticenos", offsetof(NOTICEREF, noticenos),
                 sizeof(((NOTICEREF *)0)->noticenos),
                 _CFFI_OP(_CFFI_OP_NOOP, 24) },
  { "type", offsetof(OBJ_NAME, type),
            sizeof(((OBJ_NAME *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "alias", offsetof(OBJ_NAME, alias),
             sizeof(((OBJ_NAME *)0)->alias),
             _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "name", offsetof(OBJ_NAME, name),
            sizeof(((OBJ_NAME *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 57) },
  { "data", offsetof(OBJ_NAME, data),
            sizeof(((OBJ_NAME *)0)->data),
            _CFFI_OP(_CFFI_OP_NOOP, 57) },
  { "type_id", offsetof(OTHERNAME, type_id),
               sizeof(((OTHERNAME *)0)->type_id),
               _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "value", offsetof(OTHERNAME, value),
             sizeof(((OTHERNAME *)0)->value),
             _CFFI_OP(_CFFI_OP_NOOP, 1056) },
  { "type", offsetof(PKCS7, type),
            sizeof(((PKCS7 *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "d", offsetof(PKCS7, d),
         sizeof(((PKCS7 *)0)->d),
         _CFFI_OP(_CFFI_OP_NOOP, 3791) },
  { "cert", offsetof(PKCS7_SIGNED, cert),
            sizeof(((PKCS7_SIGNED *)0)->cert),
            _CFFI_OP(_CFFI_OP_NOOP, 210) },
  { "crl", offsetof(PKCS7_SIGNED, crl),
           sizeof(((PKCS7_SIGNED *)0)->crl),
           _CFFI_OP(_CFFI_OP_NOOP, 772) },
  { "cert", offsetof(PKCS7_SIGN_ENVELOPE, cert),
            sizeof(((PKCS7_SIGN_ENVELOPE *)0)->cert),
            _CFFI_OP(_CFFI_OP_NOOP, 210) },
  { "crl", offsetof(PKCS7_SIGN_ENVELOPE, crl),
           sizeof(((PKCS7_SIGN_ENVELOPE *)0)->crl),
           _CFFI_OP(_CFFI_OP_NOOP, 772) },
  { "policyid", offsetof(POLICYINFO, policyid),
                sizeof(((POLICYINFO *)0)->policyid),
                _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "qualifiers", offsetof(POLICYINFO, qualifiers),
                  sizeof(((POLICYINFO *)0)->qualifiers),
                  _CFFI_OP(_CFFI_OP_NOOP, 643) },
  { "pqualid", offsetof(POLICYQUALINFO, pqualid),
               sizeof(((POLICYQUALINFO *)0)->pqualid),
               _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "d", offsetof(POLICYQUALINFO, d),
         sizeof(((POLICYQUALINFO *)0)->d),
         _CFFI_OP(_CFFI_OP_NOOP, 3790) },
  { "requireExplicitPolicy", offsetof(POLICY_CONSTRAINTS, requireExplicitPolicy),
                             sizeof(((POLICY_CONSTRAINTS *)0)->requireExplicitPolicy),
                             _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "inhibitPolicyMapping", offsetof(POLICY_CONSTRAINTS, inhibitPolicyMapping),
                            sizeof(((POLICY_CONSTRAINTS *)0)->inhibitPolicyMapping),
                            _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "bytes", offsetof(RAND_METHOD, bytes),
             sizeof(((RAND_METHOD *)0)->bytes),
             _CFFI_OP(_CFFI_OP_NOOP, 3781) },
  { "pseudorand", offsetof(RAND_METHOD, pseudorand),
                  sizeof(((RAND_METHOD *)0)->pseudorand),
                  _CFFI_OP(_CFFI_OP_NOOP, 3781) },
  { "status", offsetof(RAND_METHOD, status),
              sizeof(((RAND_METHOD *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 3782) },
  { "noticeref", offsetof(USERNOTICE, noticeref),
                 sizeof(((USERNOTICE *)0)->noticeref),
                 _CFFI_OP(_CFFI_OP_NOOP, 3325) },
  { "exptext", offsetof(USERNOTICE, exptext),
               sizeof(((USERNOTICE *)0)->exptext),
               _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "issuer_cert", offsetof(X509V3_CTX, issuer_cert),
                   sizeof(((X509V3_CTX *)0)->issuer_cert),
                   _CFFI_OP(_CFFI_OP_NOOP, 28) },
  { "subject_cert", offsetof(X509V3_CTX, subject_cert),
                    sizeof(((X509V3_CTX *)0)->subject_cert),
                    _CFFI_OP(_CFFI_OP_NOOP, 28) },
  { "it", offsetof(X509V3_EXT_METHOD, it),
          sizeof(((X509V3_EXT_METHOD *)0)->it),
          _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "d2i", offsetof(X509V3_EXT_METHOD, d2i),
           sizeof(((X509V3_EXT_METHOD *)0)->d2i),
           _CFFI_OP(_CFFI_OP_NOOP, 3793) },
  { "algorithm", offsetof(X509_ALGOR, algorithm),
                 sizeof(((X509_ALGOR *)0)->algorithm),
                 _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "error", offsetof(ERR_STRING_DATA, error),
             sizeof(((ERR_STRING_DATA *)0)->error),
             _CFFI_OP(_CFFI_OP_NOOP, 935) },
  { "string", offsetof(ERR_STRING_DATA, string),
              sizeof(((ERR_STRING_DATA *)0)->string),
              _CFFI_OP(_CFFI_OP_NOOP, 57) },
  { "length", offsetof(ASN1_OCTET_STRING, length),
              sizeof(((ASN1_OCTET_STRING *)0)->length),
              _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "type", offsetof(ASN1_OCTET_STRING, type),
            sizeof(((ASN1_OCTET_STRING *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "data", offsetof(ASN1_OCTET_STRING, data),
            sizeof(((ASN1_OCTET_STRING *)0)->data),
            _CFFI_OP(_CFFI_OP_NOOP, 975) },
  { "flags", offsetof(ASN1_OCTET_STRING, flags),
             sizeof(((ASN1_OCTET_STRING *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 41) },
  { "ptr", (size_t)-1,
           (size_t)-1,
           _CFFI_OP(_CFFI_OP_NOOP, 594) },
  { "otherName", (size_t)-1,
                 (size_t)-1,
                 _CFFI_OP(_CFFI_OP_NOOP, 3338) },
  { "rfc822Name", (size_t)-1,
                  (size_t)-1,
                  _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "dNSName", (size_t)-1,
               (size_t)-1,
               _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "x400Address", (size_t)-1,
                   (size_t)-1,
                   _CFFI_OP(_CFFI_OP_NOOP, 1056) },
  { "directoryName", (size_t)-1,
                     (size_t)-1,
                     _CFFI_OP(_CFFI_OP_NOOP, 847) },
  { "ediPartyName", (size_t)-1,
                    (size_t)-1,
                    _CFFI_OP(_CFFI_OP_NOOP, 3698) },
  { "uniformResourceIdentifier", (size_t)-1,
                                 (size_t)-1,
                                 _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "iPAddress", (size_t)-1,
                 (size_t)-1,
                 _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "registeredID", (size_t)-1,
                    (size_t)-1,
                    _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "ip", (size_t)-1,
          (size_t)-1,
          _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "dirn", (size_t)-1,
            (size_t)-1,
            _CFFI_OP(_CFFI_OP_NOOP, 847) },
  { "ia5", (size_t)-1,
           (size_t)-1,
           _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "rid", (size_t)-1,
           (size_t)-1,
           _CFFI_OP(_CFFI_OP_NOOP, 811) },
  { "other", (size_t)-1,
             (size_t)-1,
             _CFFI_OP(_CFFI_OP_NOOP, 1056) },
  { "fullname", (size_t)-1,
                (size_t)-1,
                _CFFI_OP(_CFFI_OP_NOOP, 518) },
  { "relativename", (size_t)-1,
                    (size_t)-1,
                    _CFFI_OP(_CFFI_OP_NOOP, 273) },
  { "cpsuri", (size_t)-1,
              (size_t)-1,
              _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "usernotice", (size_t)-1,
                  (size_t)-1,
                  _CFFI_OP(_CFFI_OP_NOOP, 3477) },
  { "other", (size_t)-1,
             (size_t)-1,
             _CFFI_OP(_CFFI_OP_NOOP, 1056) },
  { "ptr", (size_t)-1,
           (size_t)-1,
           _CFFI_OP(_CFFI_OP_NOOP, 594) },
  { "data", (size_t)-1,
            (size_t)-1,
            _CFFI_OP(_CFFI_OP_NOOP, 13) },
  { "sign", (size_t)-1,
            (size_t)-1,
            _CFFI_OP(_CFFI_OP_NOOP, 3736) },
  { "enveloped", (size_t)-1,
                 (size_t)-1,
                 _CFFI_OP(_CFFI_OP_NOOP, 3734) },
  { "signed_and_enveloped", (size_t)-1,
                            (size_t)-1,
                            _CFFI_OP(_CFFI_OP_NOOP, 3738) },
  { "digest", (size_t)-1,
              (size_t)-1,
              _CFFI_OP(_CFFI_OP_NOOP, 3730) },
  { "encrypted", (size_t)-1,
                 (size_t)-1,
                 _CFFI_OP(_CFFI_OP_NOOP, 3732) },
  { "other", (size_t)-1,
             (size_t)-1,
             _CFFI_OP(_CFFI_OP_NOOP, 1056) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$$ENGINE_CIPHERS_PTR", 3784, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$$ENGINE_CTRL_FUNC_PTR", 3785, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$$ENGINE_DIGESTS_PTR", 3786, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$$ENGINE_LOAD_KEY_PTR", 3787, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$1", 3788, _CFFI_F_UNION|_CFFI_F_CHECK_FIELDS,
    (size_t)-2, -2, 62, 15 /* unnamed */ },
  { "$2", 3789, _CFFI_F_UNION|_CFFI_F_CHECK_FIELDS,
    (size_t)-2, -2, 77, 2 /* unnamed */ },
  { "$3", 3790, _CFFI_F_UNION|_CFFI_F_CHECK_FIELDS,
    (size_t)-2, -2, 79, 3 /* unnamed */ },
  { "$4", 3791, _CFFI_F_UNION|_CFFI_F_CHECK_FIELDS,
    (size_t)-2, -2, 82, 8 /* unnamed */ },
  { "$ACCESS_DESCRIPTION", 3632, _CFFI_F_CHECK_FIELDS,
    sizeof(ACCESS_DESCRIPTION), offsetof(struct _cffi_align_typedef_ACCESS_DESCRIPTION, y), 0, 2 },
  { "$ASN1_ENUMERATED", 3634, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_GENERALIZEDTIME", 3635, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_INTEGER", 3637, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_ITEM", 3638, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_ITEM_EXP", 3639, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_OBJECT", 3640, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_TYPE", 3643, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_UTCTIME", 3644, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ASN1_VALUE", 3646, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$AUTHORITY_KEYID", 3647, _CFFI_F_CHECK_FIELDS,
    sizeof(AUTHORITY_KEYID), offsetof(struct _cffi_align_typedef_AUTHORITY_KEYID, y), 2, 3 },
  { "$BASIC_CONSTRAINTS", 3648, _CFFI_F_CHECK_FIELDS,
    sizeof(BASIC_CONSTRAINTS), offsetof(struct _cffi_align_typedef_BASIC_CONSTRAINTS, y), 5, 2 },
  { "$BIGNUM", 3649, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$BIO_METHOD", 3651, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$BN_CTX", 3652, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$BN_GENCB", 3653, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$BUF_MEM", 3654, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMAC_CTX", 3655, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_CertificateChoices", 3656, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_ContentInfo", 3657, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_Receipt", 3658, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_ReceiptRequest", 3659, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_RecipientInfo", 3660, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_RevocationInfoChoice", 3661, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CMS_SignerInfo", 3663, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$COMP_METHOD", 3664, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CONF", 3665, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CRYPTOGRAPHY_PASSWORD_DATA", 3666, _CFFI_F_CHECK_FIELDS,
    sizeof(CRYPTOGRAPHY_PASSWORD_DATA), offsetof(struct _cffi_align_typedef_CRYPTOGRAPHY_PASSWORD_DATA, y), 7, 5 },
  { "$CRYPTO_EX_dup", 3667, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CRYPTO_EX_free", 3668, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$CRYPTO_EX_new", 3669, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_LHASH_OF_CONF_VALUE", 3670, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_ACCESS_DESCRIPTION", 3671, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_ASN1_INTEGER", 3672, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_ASN1_OBJECT", 3673, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_DIST_POINT", 3674, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_GENERAL_SUBTREE", 3675, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_POLICYINFO", 3676, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_POLICYQUALINFO", 3677, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_SCT", 3678, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_SSL_CIPHER", 3679, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_X509", 3680, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_X509_CRL", 3681, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_X509_NAME", 3682, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_X509_NAME_ENTRY", 3683, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_X509_OBJECT", 3684, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$Cryptography_STACK_OF_X509_REVOKED", 3685, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$DH", 3686, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$DH_METHOD", 3687, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$DIST_POINT", 3688, 0,
    sizeof(DIST_POINT), offsetof(struct _cffi_align_typedef_DIST_POINT, y), 12, 3 },
  { "$DIST_POINT_NAME", 3689, 0,
    sizeof(DIST_POINT_NAME), offsetof(struct _cffi_align_typedef_DIST_POINT_NAME, y), 15, 2 },
  { "$DSA", 3690, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$DSA_METHOD", 3691, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ECDSA_SIG", 3692, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EC_GROUP", 3693, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EC_KEY", 3694, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EC_METHOD", 3695, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EC_POINT", 3696, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EC_builtin_curve", 3697, _CFFI_F_CHECK_FIELDS,
    sizeof(EC_builtin_curve), offsetof(struct _cffi_align_typedef_EC_builtin_curve, y), 17, 2 },
  { "$EDIPARTYNAME", 3699, 0,
    sizeof(EDIPARTYNAME), offsetof(struct _cffi_align_typedef_EDIPARTYNAME, y), 19, 0 },
  { "$ENGINE", 3700, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ENGINE_CMD_DEFN", 3701, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$ERR_STATE", 3703, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EVP_CIPHER", 3705, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EVP_CIPHER_CTX", 3706, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EVP_MD", 3707, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EVP_MD_CTX", 3708, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EVP_PKEY", 3709, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EVP_PKEY_CTX", 3710, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$EXTENDED_KEY_USAGE", 3711, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$GENERAL_NAME", 3713, 0,
    sizeof(GENERAL_NAME), offsetof(struct _cffi_align_typedef_GENERAL_NAME, y), 19, 2 },
  { "$GENERAL_SUBTREE", 3715, _CFFI_F_CHECK_FIELDS,
    sizeof(GENERAL_SUBTREE), offsetof(struct _cffi_align_typedef_GENERAL_SUBTREE, y), 21, 3 },
  { "$HMAC_CTX", 3716, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$NAME_CONSTRAINTS", 3717, _CFFI_F_CHECK_FIELDS,
    sizeof(NAME_CONSTRAINTS), offsetof(struct _cffi_align_typedef_NAME_CONSTRAINTS, y), 24, 2 },
  { "$NETSCAPE_SPKI", 3718, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$NOTICEREF", 3719, _CFFI_F_CHECK_FIELDS,
    sizeof(NOTICEREF), offsetof(struct _cffi_align_typedef_NOTICEREF, y), 26, 2 },
  { "$OBJ_NAME", 3720, _CFFI_F_CHECK_FIELDS,
    sizeof(OBJ_NAME), offsetof(struct _cffi_align_typedef_OBJ_NAME, y), 28, 4 },
  { "$OCSP_BASICRESP", 3721, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$OCSP_CERTID", 3722, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$OCSP_ONEREQ", 3723, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$OCSP_REQUEST", 3724, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$OCSP_RESPONSE", 3725, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$OCSP_SINGLERESP", 3726, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$OTHERNAME", 3727, _CFFI_F_CHECK_FIELDS,
    sizeof(OTHERNAME), offsetof(struct _cffi_align_typedef_OTHERNAME, y), 32, 2 },
  { "$PKCS12", 3728, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$PKCS7", 3729, 0,
    sizeof(PKCS7), offsetof(struct _cffi_align_typedef_PKCS7, y), 34, 2 },
  { "$PKCS7_DIGEST", 3731, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$PKCS7_ENCRYPT", 3733, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$PKCS7_ENVELOPE", 3735, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$PKCS7_SIGNED", 3737, 0,
    sizeof(PKCS7_SIGNED), offsetof(struct _cffi_align_typedef_PKCS7_SIGNED, y), 36, 2 },
  { "$PKCS7_SIGN_ENVELOPE", 3739, 0,
    sizeof(PKCS7_SIGN_ENVELOPE), offsetof(struct _cffi_align_typedef_PKCS7_SIGN_ENVELOPE, y), 38, 2 },
  { "$PKCS8_PRIV_KEY_INFO", 3740, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$POLICYINFO", 3741, _CFFI_F_CHECK_FIELDS,
    sizeof(POLICYINFO), offsetof(struct _cffi_align_typedef_POLICYINFO, y), 40, 2 },
  { "$POLICYQUALINFO", 3742, _CFFI_F_CHECK_FIELDS,
    sizeof(POLICYQUALINFO), offsetof(struct _cffi_align_typedef_POLICYQUALINFO, y), 42, 2 },
  { "$POLICY_CONSTRAINTS", 3743, _CFFI_F_CHECK_FIELDS,
    sizeof(POLICY_CONSTRAINTS), offsetof(struct _cffi_align_typedef_POLICY_CONSTRAINTS, y), 44, 2 },
  { "$RAND_METHOD", 3744, 0,
    sizeof(RAND_METHOD), offsetof(struct _cffi_align_typedef_RAND_METHOD, y), 46, 3 },
  { "$RSA", 3745, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$RSA_METHOD", 3746, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$SCT", 3747, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$SSL", 3748, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$SSL_CIPHER", 3749, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$SSL_CTX", 3750, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$SSL_METHOD", 3752, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$SSL_SESSION", 3753, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$UI_METHOD", 3754, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$USERNOTICE", 3755, _CFFI_F_CHECK_FIELDS,
    sizeof(USERNOTICE), offsetof(struct _cffi_align_typedef_USERNOTICE, y), 49, 2 },
  { "$X509", 3756, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509V3_CTX", 3757, 0,
    sizeof(X509V3_CTX), offsetof(struct _cffi_align_typedef_X509V3_CTX, y), 51, 2 },
  { "$X509V3_EXT_METHOD", 3759, 0,
    sizeof(X509V3_EXT_METHOD), offsetof(struct _cffi_align_typedef_X509V3_EXT_METHOD, y), 53, 2 },
  { "$X509_ALGOR", 3762, 0,
    sizeof(X509_ALGOR), offsetof(struct _cffi_align_typedef_X509_ALGOR, y), 55, 1 },
  { "$X509_ATTRIBUTE", 3763, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_CINF", 3764, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_CRL", 3765, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_CRL_INFO", 3766, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_EXTENSION", 3767, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_EXTENSIONS", 3768, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_NAME", 3769, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_NAME_ENTRY", 3770, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_OBJECT", 3771, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_REQ", 3772, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_REQ_INFO", 3773, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_REVOKED", 3774, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_STORE", 3775, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_STORE_CTX", 3776, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$X509_VERIFY_PARAM", 3777, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "$bio_st", 3778, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ERR_string_data_st", 3704, _CFFI_F_CHECK_FIELDS,
    sizeof(ERR_STRING_DATA), offsetof(struct _cffi_align__ERR_STRING_DATA, y), 56, 2 },
  { "_IO_FILE", 3712, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "aes_key_st", 3633, 0,
    sizeof(AES_KEY), offsetof(struct _cffi_align__AES_KEY, y), 58, 0 },
  { "asn1_string_st", 3642, _CFFI_F_CHECK_FIELDS,
    sizeof(ASN1_OCTET_STRING), offsetof(struct _cffi_align__ASN1_OCTET_STRING, y), 58, 4 },
  { "bio_st", 3650, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "stack_st_GENERAL_NAME", 3714, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
};

static const struct _cffi_enum_s _cffi_enums[] = {
  { "$ct_log_entry_type_t", 3780, _cffi_prim_int(sizeof(ct_log_entry_type_t), ((ct_log_entry_type_t)-1) <= 0),
    "CT_LOG_ENTRY_TYPE_NOT_SET,CT_LOG_ENTRY_TYPE_X509,CT_LOG_ENTRY_TYPE_PRECERT" },
  { "$point_conversion_form_t", 143, _cffi_prim_int(sizeof(point_conversion_form_t), ((point_conversion_form_t)-1) <= 0),
    "POINT_CONVERSION_COMPRESSED,POINT_CONVERSION_UNCOMPRESSED,POINT_CONVERSION_HYBRID" },
  { "$sct_source_t", 2150, _cffi_prim_int(sizeof(sct_source_t), ((sct_source_t)-1) <= 0),
    "SCT_SOURCE_UNKNOWN,SCT_SOURCE_TLS_EXTENSION,SCT_SOURCE_X509V3_EXTENSION,SCT_SOURCE_OCSP_STAPLED_RESPONSE" },
  { "$sct_version_t", 3783, _cffi_prim_int(sizeof(sct_version_t), ((sct_version_t)-1) <= 0),
    "SCT_VERSION_NOT_SET,SCT_VERSION_V1" },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "ACCESS_DESCRIPTION", 3632 },
  { "AES_KEY", 3633 },
  { "ASN1_BIT_STRING", 3642 },
  { "ASN1_BOOLEAN", 2 },
  { "ASN1_ENUMERATED", 3634 },
  { "ASN1_GENERALIZEDTIME", 3635 },
  { "ASN1_IA5STRING", 3642 },
  { "ASN1_INTEGER", 3637 },
  { "ASN1_ITEM", 3638 },
  { "ASN1_ITEM_EXP", 3639 },
  { "ASN1_OBJECT", 3640 },
  { "ASN1_OCTET_STRING", 3642 },
  { "ASN1_STRING", 3642 },
  { "ASN1_TIME", 3642 },
  { "ASN1_TYPE", 3643 },
  { "ASN1_UTCTIME", 3644 },
  { "ASN1_UTF8STRING", 3642 },
  { "ASN1_VALUE", 3646 },
  { "AUTHORITY_KEYID", 3647 },
  { "BASIC_CONSTRAINTS", 3648 },
  { "BIGNUM", 3649 },
  { "BIO", 3650 },
  { "BIO_METHOD", 3651 },
  { "BN_CTX", 3652 },
  { "BN_GENCB", 3653 },
  { "BN_ULONG", 1119 },
  { "BUF_MEM", 3654 },
  { "CMAC_CTX", 3655 },
  { "CMS_CertificateChoices", 3656 },
  { "CMS_ContentInfo", 3657 },
  { "CMS_Receipt", 3658 },
  { "CMS_ReceiptRequest", 3659 },
  { "CMS_RecipientInfo", 3660 },
  { "CMS_RevocationInfoChoice", 3661 },
  { "CMS_SignerInfo", 3663 },
  { "COMP_METHOD", 3664 },
  { "CONF", 3665 },
  { "CRYPTOGRAPHY_PASSWORD_DATA", 3666 },
  { "CRYPTO_EX_dup", 3667 },
  { "CRYPTO_EX_free", 3668 },
  { "CRYPTO_EX_new", 3669 },
  { "Cryptography_LHASH_OF_CONF_VALUE", 3670 },
  { "Cryptography_STACK_OF_ACCESS_DESCRIPTION", 3671 },
  { "Cryptography_STACK_OF_ASN1_INTEGER", 3672 },
  { "Cryptography_STACK_OF_ASN1_OBJECT", 3673 },
  { "Cryptography_STACK_OF_DIST_POINT", 3674 },
  { "Cryptography_STACK_OF_GENERAL_SUBTREE", 3675 },
  { "Cryptography_STACK_OF_POLICYINFO", 3676 },
  { "Cryptography_STACK_OF_POLICYQUALINFO", 3677 },
  { "Cryptography_STACK_OF_SCT", 3678 },
  { "Cryptography_STACK_OF_SSL_CIPHER", 3679 },
  { "Cryptography_STACK_OF_X509", 3680 },
  { "Cryptography_STACK_OF_X509_CRL", 3681 },
  { "Cryptography_STACK_OF_X509_NAME", 3682 },
  { "Cryptography_STACK_OF_X509_NAME_ENTRY", 3683 },
  { "Cryptography_STACK_OF_X509_OBJECT", 3684 },
  { "Cryptography_STACK_OF_X509_REVOKED", 3685 },
  { "DH", 3686 },
  { "DH_METHOD", 3687 },
  { "DIST_POINT", 3688 },
  { "DIST_POINT_NAME", 3689 },
  { "DSA", 3690 },
  { "DSA_METHOD", 3691 },
  { "ECDSA_SIG", 3692 },
  { "EC_GROUP", 3693 },
  { "EC_KEY", 3694 },
  { "EC_METHOD", 3695 },
  { "EC_POINT", 3696 },
  { "EC_builtin_curve", 3697 },
  { "EDIPARTYNAME", 3699 },
  { "ENGINE", 3700 },
  { "ENGINE_CIPHERS_PTR", 1740 },
  { "ENGINE_CMD_DEFN", 3701 },
  { "ENGINE_CTRL_FUNC_PTR", 1748 },
  { "ENGINE_DIGESTS_PTR", 1752 },
  { "ENGINE_GEN_INT_FUNC_PTR", 1786 },
  { "ENGINE_LOAD_KEY_PTR", 1756 },
  { "ERR_STATE", 3703 },
  { "ERR_STRING_DATA", 3704 },
  { "EVP_CIPHER", 3705 },
  { "EVP_CIPHER_CTX", 3706 },
  { "EVP_MD", 3707 },
  { "EVP_MD_CTX", 3708 },
  { "EVP_PKEY", 3709 },
  { "EVP_PKEY_CTX", 3710 },
  { "EXTENDED_KEY_USAGE", 3711 },
  { "FILE", 3712 },
  { "GENERAL_NAME", 3713 },
  { "GENERAL_NAMES", 3714 },
  { "GENERAL_SUBTREE", 3715 },
  { "HMAC_CTX", 3716 },
  { "NAME_CONSTRAINTS", 3717 },
  { "NETSCAPE_SPKI", 3718 },
  { "NOTICEREF", 3719 },
  { "OBJ_NAME", 3720 },
  { "OCSP_BASICRESP", 3721 },
  { "OCSP_CERTID", 3722 },
  { "OCSP_ONEREQ", 3723 },
  { "OCSP_REQUEST", 3724 },
  { "OCSP_RESPONSE", 3725 },
  { "OCSP_SINGLERESP", 3726 },
  { "OTHERNAME", 3727 },
  { "PKCS12", 3728 },
  { "PKCS7", 3729 },
  { "PKCS7_DIGEST", 3731 },
  { "PKCS7_ENCRYPT", 3733 },
  { "PKCS7_ENVELOPE", 3735 },
  { "PKCS7_SIGNED", 3737 },
  { "PKCS7_SIGN_ENVELOPE", 3739 },
  { "PKCS8_PRIV_KEY_INFO", 3740 },
  { "POLICYINFO", 3741 },
  { "POLICYQUALINFO", 3742 },
  { "POLICY_CONSTRAINTS", 3743 },
  { "RAND_METHOD", 3744 },
  { "RSA", 3745 },
  { "RSA_METHOD", 3746 },
  { "SCT", 3747 },
  { "SSL", 3748 },
  { "SSL_CIPHER", 3749 },
  { "SSL_CTX", 3750 },
  { "SSL_METHOD", 3752 },
  { "SSL_SESSION", 3753 },
  { "UI_METHOD", 3754 },
  { "USERNOTICE", 3755 },
  { "X509", 3756 },
  { "X509V3_CTX", 3757 },
  { "X509V3_EXT_D2I", 3793 },
  { "X509V3_EXT_METHOD", 3759 },
  { "X509_ALGOR", 3762 },
  { "X509_ATTRIBUTE", 3763 },
  { "X509_CINF", 3764 },
  { "X509_CRL", 3765 },
  { "X509_CRL_INFO", 3766 },
  { "X509_EXTENSION", 3767 },
  { "X509_EXTENSIONS", 3768 },
  { "X509_NAME", 3769 },
  { "X509_NAME_ENTRY", 3770 },
  { "X509_OBJECT", 3771 },
  { "X509_REQ", 3772 },
  { "X509_REQ_INFO", 3773 },
  { "X509_REVOKED", 3774 },
  { "X509_STORE", 3775 },
  { "X509_STORE_CTX", 3776 },
  { "X509_STORE_CTX_get_issuer_fn", 3526 },
  { "X509_VERIFY_PARAM", 3777 },
  { "bio_info_cb", 3166 },
  { "bio_st", 3778 },
  { "ct_log_entry_type_t", 3780 },
  { "pem_password_cb", 2629 },
  { "point_conversion_form_t", 143 },
  { "sct_source_t", 2150 },
  { "sct_version_t", 3783 },
  { "sk_DIST_POINT_freefunc", 3194 },
  { "sk_GENERAL_NAME_freefunc", 3313 },
  { "sk_POLICYINFO_freefunc", 3204 },
  { "time_t", 10 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  _cffi_enums,
  _cffi_typenames,
  2031,  /* num_globals */
  140,  /* num_struct_unions */
  4,  /* num_enums */
  156,  /* num_typenames */
  NULL,  /* no includes */
  3796,  /* num_types */
  0,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#if PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__cryptography_openssl(void)
{
  return _cffi_init("_cryptography_openssl", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_cryptography_openssl(void)
{
  _cffi_init("_cryptography_openssl", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
